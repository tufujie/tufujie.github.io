<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.0" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.0" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://mister-hope.github.io/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html"><meta property="og:site_name" content="Jef Blog"><meta property="og:title" content="技术栈对比"><meta property="og:description" content="Java基础 集合 List Arraylist 与 LinkedList ★★★ ArrayList 是一种顺序存储的线性表，底层使用数组实现 LinkedList是一种链式存储的线性表，本质是一个双向链表，实现了List、Deque接口，可以当成双向链表、队列、栈使用。 是否保证线程安全： ArrayList和LinkedList都是不同步的，也就是不保证线程安全； 底层数据结构： Arraylist 底层使用的是 Object 数组；LinkedList底层使用的是 双向链表 数据结构（JDK1.6 之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表） 插入和删除是否受元素位置的影响：ArrayList采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。比如：执行add(E e)方法的时候， ArrayList会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i和第 i个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。LinkedList采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（add(E e)、addFirst(E e)、addLast(E e)、removeFirst() 、removeLast()），时间复杂度为 O(1)，如果是要在指定位置 i插入和删除元素的话（add(int index, E element)，remove(Object o)），时间复杂度为 O(n) ，因为需要先移动到指定位置再插入。 是否支持快速随机访问： LinkedList因为使用链表储存，无法通过元素索引快速访问，不支持高效的随机元素访问，而ArrayList因为底层采用Object数组储存，可以通过索引快速随机访问。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而LinkedList 是 O(n)。 内存空间占用： ArrayList 的空间浪费主要体现在在 List列表的结尾会预留一定的容量空间，而 LinkedList的空间花费则体现在它的每一个元素都需要消耗比 ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。"><meta property="og:type" content="article"><meta property="og:image" content="https://mister-hope.github.io/"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2024-02-02T09:17:20.000Z"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image:alt" content="技术栈对比"><meta property="article:author" content="Jef"><meta property="article:modified_time" content="2024-02-02T09:17:20.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"技术栈对比","image":["https://mister-hope.github.io/"],"dateModified":"2024-02-02T09:17:20.000Z","author":[{"@type":"Person","name":"Jef","url":"https://mister-hope.com"}]}</script><title>技术栈对比 | Jef Blog</title><meta name="description" content="Java基础 集合 List Arraylist 与 LinkedList ★★★ ArrayList 是一种顺序存储的线性表，底层使用数组实现 LinkedList是一种链式存储的线性表，本质是一个双向链表，实现了List、Deque接口，可以当成双向链表、队列、栈使用。 是否保证线程安全： ArrayList和LinkedList都是不同步的，也就是不保证线程安全； 底层数据结构： Arraylist 底层使用的是 Object 数组；LinkedList底层使用的是 双向链表 数据结构（JDK1.6 之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表） 插入和删除是否受元素位置的影响：ArrayList采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。比如：执行add(E e)方法的时候， ArrayList会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i和第 i个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。LinkedList采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（add(E e)、addFirst(E e)、addLast(E e)、removeFirst() 、removeLast()），时间复杂度为 O(1)，如果是要在指定位置 i插入和删除元素的话（add(int index, E element)，remove(Object o)），时间复杂度为 O(n) ，因为需要先移动到指定位置再插入。 是否支持快速随机访问： LinkedList因为使用链表储存，无法通过元素索引快速访问，不支持高效的随机元素访问，而ArrayList因为底层采用Object数组储存，可以通过索引快速随机访问。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而LinkedList 是 O(n)。 内存空间占用： ArrayList 的空间浪费主要体现在在 List列表的结尾会预留一定的容量空间，而 LinkedList的空间花费则体现在它的每一个元素都需要消耗比 ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。">
    <link rel="preload" href="/assets/style-7vJm_Iuf.css" as="style"><link rel="stylesheet" href="/assets/style-7vJm_Iuf.css">
    <link rel="modulepreload" href="/assets/app-AuAuVshg.js"><link rel="modulepreload" href="/assets/技术栈对比.html-__GGKoPC.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-x3n3nnut.js"><link rel="modulepreload" href="/assets/技术栈对比.html-ogrbgtBz.js">
    <link rel="prefetch" href="/assets/intro.html-1QsZxAxl.js" as="script"><link rel="prefetch" href="/assets/index.html-Wieu_Bg-.js" as="script"><link rel="prefetch" href="/assets/Java技术可行性分析指南.html-So0DT_pI.js" as="script"><link rel="prefetch" href="/assets/index.html-QKL9y779.js" as="script"><link rel="prefetch" href="/assets/系统架构设计.html-S2Rtciyz.js" as="script"><link rel="prefetch" href="/assets/index.html-uLE-APO_.js" as="script"><link rel="prefetch" href="/assets/index.html-eGoUGM3j.js" as="script"><link rel="prefetch" href="/assets/Arthas.html-PWkFAlkY.js" as="script"><link rel="prefetch" href="/assets/Kibana.html-nCpcWNbI.js" as="script"><link rel="prefetch" href="/assets/Linux常用命令.html-_Pu0lwv8.js" as="script"><link rel="prefetch" href="/assets/Postman.html-IqbALetj.js" as="script"><link rel="prefetch" href="/assets/index.html-hsRFUPKH.js" as="script"><link rel="prefetch" href="/assets/功能触发方式.html-CFeDF_lP.js" as="script"><link rel="prefetch" href="/assets/常用工具和软件.html-Jn2ouysX.js" as="script"><link rel="prefetch" href="/assets/Java基础.html-biPLgpZN.js" as="script"><link rel="prefetch" href="/assets/index.html-6dQYapeM.js" as="script"><link rel="prefetch" href="/assets/参数校验(javax.validation).html-HCLtFXAA.js" as="script"><link rel="prefetch" href="/assets/类加载器.html-yl8Wka8i.js" as="script"><link rel="prefetch" href="/assets/代码优化，即代码提交前应该做的一些事情.html-jD6WuIwY.js" as="script"><link rel="prefetch" href="/assets/代码重构的一些方法.html-sF7wazlA.js" as="script"><link rel="prefetch" href="/assets/去除if else的常用方法.html-hRVBXew7.js" as="script"><link rel="prefetch" href="/assets/Gossip协议详解.html-PK1jPxVA.js" as="script"><link rel="prefetch" href="/assets/Paxos算法.html-G4bajiUL.js" as="script"><link rel="prefetch" href="/assets/Raft算法.html-1-s2lOg2.js" as="script"><link rel="prefetch" href="/assets/index.html-BHIkVqgo.js" as="script"><link rel="prefetch" href="/assets/RPC.html-IeIbgzw8.js" as="script"><link rel="prefetch" href="/assets/Zookeeper核心知识点.html-3xs-5uYS.js" as="script"><link rel="prefetch" href="/assets/一致性hash算法.html-nCAGHS8j.js" as="script"><link rel="prefetch" href="/assets/分布式ID.html-kuwtW3cl.js" as="script"><link rel="prefetch" href="/assets/分布式Session的实现方案.html--irKJrhk.js" as="script"><link rel="prefetch" href="/assets/分布式事务.html-CHP5L4gk.js" as="script"><link rel="prefetch" href="/assets/分布式锁.html-XGfVjN_R.js" as="script"><link rel="prefetch" href="/assets/微服务网关总结.html-9iJBT2DB.js" as="script"><link rel="prefetch" href="/assets/电商超卖问题解决.html-gvozdBhO.js" as="script"><link rel="prefetch" href="/assets/Dubbo与SpringCloud区别.html-AOAcENFQ.js" as="script"><link rel="prefetch" href="/assets/index.html-lLsNLDNT.js" as="script"><link rel="prefetch" href="/assets/ElasticSearch.html-h0SwM9K6.js" as="script"><link rel="prefetch" href="/assets/index.html-9QmtFRfF.js" as="script"><link rel="prefetch" href="/assets/index.html-u-EDTuYp.js" as="script"><link rel="prefetch" href="/assets/index.html-kCppjaYa.js" as="script"><link rel="prefetch" href="/assets/分库分表方案.html-ZVI5IB77.js" as="script"><link rel="prefetch" href="/assets/如何保障MySQL和Redis的数据一致性.html-aCTOKPGG.js" as="script"><link rel="prefetch" href="/assets/如何解决MySQL主从复制延时问题.html-0IUt9o20.js" as="script"><link rel="prefetch" href="/assets/数据库性能优化策略详解.html-mfwiEBuS.js" as="script"><link rel="prefetch" href="/assets/示例表结构.html-lxMAC80y.js" as="script"><link rel="prefetch" href="/assets/index.html-NgcCQ6aw.js" as="script"><link rel="prefetch" href="/assets/排序.html-NQFj51uC.js" as="script"><link rel="prefetch" href="/assets/搜索.html-UZGxBiQy.js" as="script"><link rel="prefetch" href="/assets/数据结构与算法总结.html-n020Eoos.js" as="script"><link rel="prefetch" href="/assets/index.html-yeyNNUDf.js" as="script"><link rel="prefetch" href="/assets/软件系统中的上游与下游.html-sTsJetut.js" as="script"><link rel="prefetch" href="/assets/bitmap.html-Er8f8d_D.js" as="script"><link rel="prefetch" href="/assets/index.html-6uEVHMg8.js" as="script"><link rel="prefetch" href="/assets/TopK-排序.html-Retu3yK7.js" as="script"><link rel="prefetch" href="/assets/大数据处理方案.html-ch5dPbwr.js" as="script"><link rel="prefetch" href="/assets/相同数据.html-LeU8mPag.js" as="script"><link rel="prefetch" href="/assets/统计不同号码的个数.html-5hRaOW1I.js" as="script"><link rel="prefetch" href="/assets/ArrayList源码分析.html-X9jgLtNd.js" as="script"><link rel="prefetch" href="/assets/HashMap源码分析.html-XeUXNuTy.js" as="script"><link rel="prefetch" href="/assets/index.html-AZW25IUn.js" as="script"><link rel="prefetch" href="/assets/10w级别数据Excel导入如何优化.html-5HKeCXs3.js" as="script"><link rel="prefetch" href="/assets/Java后端接口响应慢的排查方法及解决方案.html-XihDkZua.js" as="script"><link rel="prefetch" href="/assets/Java定时任务详解.html-uRLgovdX.js" as="script"><link rel="prefetch" href="/assets/Java对接支付渠道.html-sb3u_RHH.js" as="script"><link rel="prefetch" href="/assets/Java系统问题排查方法.html-WiYa55Pv.js" as="script"><link rel="prefetch" href="/assets/JWT基本概念详解.html-ge9JnJWA.js" as="script"><link rel="prefetch" href="/assets/JWT身份认证优缺点分析.html-545rZzgl.js" as="script"><link rel="prefetch" href="/assets/OAuth2-流程原理.html-Wh6PN4P5.js" as="script"><link rel="prefetch" href="/assets/index.html-e6-oH-fB.js" as="script"><link rel="prefetch" href="/assets/SSO 单点登录详解.html-bzC4OmnI.js" as="script"><link rel="prefetch" href="/assets/Web 实时消息推送详解.html-uWMF_Cti.js" as="script"><link rel="prefetch" href="/assets/如何统计网站UV.html-UBKfCjnq.js" as="script"><link rel="prefetch" href="/assets/如何解决大文件上传问题.html-FQjfPR2l.js" as="script"><link rel="prefetch" href="/assets/如何设计一个排行榜.html-grphw0ye.js" as="script"><link rel="prefetch" href="/assets/如何设计一个注册中心.html-7L-Cfo9C.js" as="script"><link rel="prefetch" href="/assets/如何设计一个秒杀系统.html-i0Ouv2xg.js" as="script"><link rel="prefetch" href="/assets/如何设计一个高并发系统.html-m2hmSJVH.js" as="script"><link rel="prefetch" href="/assets/如何设计微博Feed流、信息流系统.html-Aed6GCrG.js" as="script"><link rel="prefetch" href="/assets/实时订阅推送设计与实现.html-97NiE23D.js" as="script"><link rel="prefetch" href="/assets/常用加密算法总结.html-JmJcHYyF.js" as="script"><link rel="prefetch" href="/assets/常见的限流算法的原理以及优缺点.html-2KypkFSy.js" as="script"><link rel="prefetch" href="/assets/微信红包系统如何设计.html-iTFlAcOK.js" as="script"><link rel="prefetch" href="/assets/扫码登录原理.html-yZxzo3dH.js" as="script"><link rel="prefetch" href="/assets/敏感词过滤方案总结.html-of-Y74xU.js" as="script"><link rel="prefetch" href="/assets/数据脱敏方案总结.html-mue7VF9M.js" as="script"><link rel="prefetch" href="/assets/权限系统设计详解.html-ZNaapCFn.js" as="script"><link rel="prefetch" href="/assets/短链系统设计.html-aR22j94S.js" as="script"><link rel="prefetch" href="/assets/网站安全漏洞-大全.html-39-AFDw9.js" as="script"><link rel="prefetch" href="/assets/认证授权基础概念详解.html-Tf9WwKRO.js" as="script"><link rel="prefetch" href="/assets/购物车系统如何设计.html-WSrCQdQr.js" as="script"><link rel="prefetch" href="/assets/超时订单自动取消.html-HsXxCStd.js" as="script"><link rel="prefetch" href="/assets/index.html-ngRaY0ek.js" as="script"><link rel="prefetch" href="/assets/万物都是增删改查.html-d0txN4dj.js" as="script"><link rel="prefetch" href="/assets/性能优化.html-hyqb7uiL.js" as="script"><link rel="prefetch" href="/assets/手动调用Dubbo接口方案.html-Qlfu615T.js" as="script"><link rel="prefetch" href="/assets/线程安全的日期处理.html-rf_LP00X.js" as="script"><link rel="prefetch" href="/assets/index.html-zz2zhqnK.js" as="script"><link rel="prefetch" href="/assets/index.html-50x0iHPI.js" as="script"><link rel="prefetch" href="/assets/index.html-IOS7zUfT.js" as="script"><link rel="prefetch" href="/assets/设计模式伪代码.html-hTaQ7fuI.js" as="script"><link rel="prefetch" href="/assets/设计模式总结.html-XwyaKr7v.js" as="script"><link rel="prefetch" href="/assets/面向对象的六原则一法则.html-eStpQX3O.js" as="script"><link rel="prefetch" href="/assets/Nacos配置中心交互模型是 push 还是 pull ？（原理_源码分析）.html-EyamjHWA.js" as="script"><link rel="prefetch" href="/assets/index.html-5oy139D4.js" as="script"><link rel="prefetch" href="/assets/index.html--9MpjKyf.js" as="script"><link rel="prefetch" href="/assets/个人亮点.html-uzrsyY6H.js" as="script"><link rel="prefetch" href="/assets/项目开发中常遇到的各种难点以及解决思路和方案.html-TPPOATAt.js" as="script"><link rel="prefetch" href="/assets/index.html-vgeLLrZJ.js" as="script"><link rel="prefetch" href="/assets/消息队列常见问题和解决方案.html-_iGpzKiY.js" as="script"><link rel="prefetch" href="/assets/index.html-mLtLhUwd.js" as="script"><link rel="prefetch" href="/assets/index.html-aEYW3o6V.js" as="script"><link rel="prefetch" href="/assets/index.html-F36WAfWB.js" as="script"><link rel="prefetch" href="/assets/index.html-AlcTczYk.js" as="script"><link rel="prefetch" href="/assets/index.html-d4xsOdA-.js" as="script"><link rel="prefetch" href="/assets/必读经典.html-W28KQci_.js" as="script"><link rel="prefetch" href="/assets/index.html-qt6pN228.js" as="script"><link rel="prefetch" href="/assets/index.html-P4mGSwR1.js" as="script"><link rel="prefetch" href="/assets/信息系统项目管理师-上午选择题.html-CkOV0MDc.js" as="script"><link rel="prefetch" href="/assets/信息系统项目管理师-下午案例分析.html-quuy49Xp.js" as="script"><link rel="prefetch" href="/assets/信息系统项目管理师-总结-Jef.html-bJ1Pxsp4.js" as="script"><link rel="prefetch" href="/assets/系统架构设计师复习策略.html-SIfnaMJD.js" as="script"><link rel="prefetch" href="/assets/Apollo.html-4f-uAJS1.js" as="script"><link rel="prefetch" href="/assets/CURL.html-XDj5fxvn.js" as="script"><link rel="prefetch" href="/assets/index.html-K241_fJQ.js" as="script"><link rel="prefetch" href="/assets/浏览器Debug.html-79W2OysF.js" as="script"><link rel="prefetch" href="/assets/浏览器控制台.html--AZjEEGM.js" as="script"><link rel="prefetch" href="/assets/bat文件运用.html-yJy9IQKm.js" as="script"><link rel="prefetch" href="/assets/sh文件运用.html-6S0BffkE.js" as="script"><link rel="prefetch" href="/assets/Git常用命令.html-3849-1EN.js" as="script"><link rel="prefetch" href="/assets/Git常用设置.html-VSNZm511.js" as="script"><link rel="prefetch" href="/assets/Docker常用命令.html-2p77wuAa.js" as="script"><link rel="prefetch" href="/assets/Docker常用组件安装.html-4LzUFPdV.js" as="script"><link rel="prefetch" href="/assets/skywalking-docker-compose.html-P0OyL0UF.js" as="script"><link rel="prefetch" href="/assets/DBeaver使用.html-PKYWFG-H.js" as="script"><link rel="prefetch" href="/assets/Debug.html-5McdJkuf.js" as="script"><link rel="prefetch" href="/assets/Debug回到某一行代码.html-ZEGLi4oc.js" as="script"><link rel="prefetch" href="/assets/HttpClient.html---4tpZF2.js" as="script"><link rel="prefetch" href="/assets/IDEA Build构建菜单.html--BUsscQO.js" as="script"><link rel="prefetch" href="/assets/IDEA jar相关.html-DACBR8X8.js" as="script"><link rel="prefetch" href="/assets/IDEA常用设置与使用.html-wQCbKaRI.js" as="script"><link rel="prefetch" href="/assets/IDEA快捷键.html-fwQviBeq.js" as="script"><link rel="prefetch" href="/assets/IDEA推荐安装的插件列表.html-a3kzMU8V.js" as="script"><link rel="prefetch" href="/assets/index.html-of3JxzZ9.js" as="script"><link rel="prefetch" href="/assets/Markdown示例.html--H89NP2_.js" as="script"><link rel="prefetch" href="/assets/Typora快捷键.html-k00vK82I.js" as="script"><link rel="prefetch" href="/assets/Typora设置.html-RXajaXmH.js" as="script"><link rel="prefetch" href="/assets/word转Markdown文件.html-Sn4Ku3N2.js" as="script"><link rel="prefetch" href="/assets/Maven命令.html-MFskoCK2.js" as="script"><link rel="prefetch" href="/assets/maven配置与安装.html-3-ZPuxLn.js" as="script"><link rel="prefetch" href="/assets/RocketMQ本地搭建.html-9aD41ZQq.js" as="script"><link rel="prefetch" href="/assets/Sublime Text Key Bindings.html-gLR0MPvV.js" as="script"><link rel="prefetch" href="/assets/Sublime Text Settings.html-Sp9JpZrt.js" as="script"><link rel="prefetch" href="/assets/Sublime text将一列转换为excel中的多列.html-D5ruyzgm.js" as="script"><link rel="prefetch" href="/assets/Sublime Text将指定符号替换成换行符.html-1n_1eXw8.js" as="script"><link rel="prefetch" href="/assets/Sublime Text快捷键.html-Khhg-qfx.js" as="script"><link rel="prefetch" href="/assets/Sublime text批量删除空白行.html-LA4PV6n6.js" as="script"><link rel="prefetch" href="/assets/Sublime Text插件.html-dFsTTnml.js" as="script"><link rel="prefetch" href="/assets/Sublime Text生成SQL.html-4sY94JmE.js" as="script"><link rel="prefetch" href="/assets/jdk8常用示例.html-MgQwL0Wv.js" as="script"><link rel="prefetch" href="/assets/Tomcat安装与配置.html-ve3-vz7r.js" as="script"><link rel="prefetch" href="/assets/接口和抽象类.html-uPop_jTZ.js" as="script"><link rel="prefetch" href="/assets/注册中心–Eureka、Zookeeper、Nacos、Consul的区别.html-BSfRE1_1.js" as="script"><link rel="prefetch" href="/assets/消息队列对比.html-4Ffny8ub.js" as="script"><link rel="prefetch" href="/assets/Redis总结.html-LrHxvOnE.js" as="script"><link rel="prefetch" href="/assets/Redis的使用场景.html-FxpItV7q.js" as="script"><link rel="prefetch" href="/assets/Redis问题和解决方案.html-xnvelTJx.js" as="script"><link rel="prefetch" href="/assets/布隆过滤器.html-LhVKoZrt.js" as="script"><link rel="prefetch" href="/assets/企业信息化战略与实施.html-nTLZmaV7.js" as="script"><link rel="prefetch" href="/assets/计算机组成与体系结构.html-F4xehMAk.js" as="script"><link rel="prefetch" href="/assets/软件工程.html-9lRufR9n.js" as="script"><link rel="prefetch" href="/assets/软件架构设计师考试背记精要.html-2Q6yKHvt.js" as="script"><link rel="prefetch" href="/assets/信息系统项目管理师-我的论文.html-8vlnhOIO.js" as="script"><link rel="prefetch" href="/assets/信息系统项目管理师-论文指导.html-GpL7Ukfn.js" as="script"><link rel="prefetch" href="/assets/信息系统项目管理师-论文范文.html-__yVTVAv.js" as="script"><link rel="prefetch" href="/assets/项目管理过程组、知识领域、49个过程.html-0vazWSWm.js" as="script"><link rel="prefetch" href="/assets/系统架构设计师-分析设计流程.html-afAvlDff.js" as="script"><link rel="prefetch" href="/assets/论区块链技术及应用.html-PtcDRqSB.js" as="script"><link rel="prefetch" href="/assets/论基于构件的软件开发方法及其应用.html-xziGhDM4.js" as="script"><link rel="prefetch" href="/assets/论微服务架构及应用-范文.html-wTEclZ26.js" as="script"><link rel="prefetch" href="/assets/论湖仓一体架构及其应用.html-vCJTLxCC.js" as="script"><link rel="prefetch" href="/assets/论软件维护方法及其应用.html-j2luTcPH.js" as="script"><link rel="prefetch" href="/assets/404.html-kVS10UL-.js" as="script"><link rel="prefetch" href="/assets/index.html--LLdOg4A.js" as="script"><link rel="prefetch" href="/assets/index.html-0xsVgAKH.js" as="script"><link rel="prefetch" href="/assets/index.html-c-o1zLwx.js" as="script"><link rel="prefetch" href="/assets/index.html-gLry51Cl.js" as="script"><link rel="prefetch" href="/assets/index.html-A_XO48T5.js" as="script"><link rel="prefetch" href="/assets/index.html-VW5jLcQi.js" as="script"><link rel="prefetch" href="/assets/index.html-QBObi--N.js" as="script"><link rel="prefetch" href="/assets/index.html-8P2p36A-.js" as="script"><link rel="prefetch" href="/assets/index.html-N94jdPtD.js" as="script"><link rel="prefetch" href="/assets/index.html-rJiclVPy.js" as="script"><link rel="prefetch" href="/assets/index.html-p83v92HU.js" as="script"><link rel="prefetch" href="/assets/index.html-HLMjQn-U.js" as="script"><link rel="prefetch" href="/assets/index.html-z4OYe-M4.js" as="script"><link rel="prefetch" href="/assets/index.html-sJZGF7Tl.js" as="script"><link rel="prefetch" href="/assets/index.html-wD5-9xKU.js" as="script"><link rel="prefetch" href="/assets/index.html-ItcU2MA9.js" as="script"><link rel="prefetch" href="/assets/index.html-Ekp2F77M.js" as="script"><link rel="prefetch" href="/assets/index.html-bqK0Y8I5.js" as="script"><link rel="prefetch" href="/assets/index.html-N_xpMleG.js" as="script"><link rel="prefetch" href="/assets/index.html-fIy5NXrF.js" as="script"><link rel="prefetch" href="/assets/index.html-nYoXl-i4.js" as="script"><link rel="prefetch" href="/assets/index.html-lOJSG09C.js" as="script"><link rel="prefetch" href="/assets/index.html-RDy9cG7N.js" as="script"><link rel="prefetch" href="/assets/index.html-NVYO2BTD.js" as="script"><link rel="prefetch" href="/assets/index.html-YRJz5QqU.js" as="script"><link rel="prefetch" href="/assets/index.html-H7uhv2M0.js" as="script"><link rel="prefetch" href="/assets/index.html-v-4UCsAJ.js" as="script"><link rel="prefetch" href="/assets/index.html-Uqslq-ye.js" as="script"><link rel="prefetch" href="/assets/index.html-VlK84g66.js" as="script"><link rel="prefetch" href="/assets/index.html-2gNMWrC3.js" as="script"><link rel="prefetch" href="/assets/index.html-GETh7yr3.js" as="script"><link rel="prefetch" href="/assets/index.html-qpfj_coM.js" as="script"><link rel="prefetch" href="/assets/index.html-J7yH0izU.js" as="script"><link rel="prefetch" href="/assets/index.html-NpFoiryi.js" as="script"><link rel="prefetch" href="/assets/index.html-x1VFwPRF.js" as="script"><link rel="prefetch" href="/assets/index.html-VALKWimr.js" as="script"><link rel="prefetch" href="/assets/index.html-3AwPayal.js" as="script"><link rel="prefetch" href="/assets/index.html-Rg4rsrq1.js" as="script"><link rel="prefetch" href="/assets/index.html-Co5EYSwQ.js" as="script"><link rel="prefetch" href="/assets/index.html-tO3qZVo6.js" as="script"><link rel="prefetch" href="/assets/index.html-POAy09z-.js" as="script"><link rel="prefetch" href="/assets/index.html-oh-vyU1I.js" as="script"><link rel="prefetch" href="/assets/index.html-H3i6BZF0.js" as="script"><link rel="prefetch" href="/assets/index.html-Metm_8QS.js" as="script"><link rel="prefetch" href="/assets/index.html-fBpP9nTd.js" as="script"><link rel="prefetch" href="/assets/intro.html-Y0ixGsYi.js" as="script"><link rel="prefetch" href="/assets/index.html-xfz2_DkN.js" as="script"><link rel="prefetch" href="/assets/Java技术可行性分析指南.html-JFHOAp2d.js" as="script"><link rel="prefetch" href="/assets/index.html-Jg8sGTBP.js" as="script"><link rel="prefetch" href="/assets/系统架构设计.html-Yi5A38aI.js" as="script"><link rel="prefetch" href="/assets/index.html-yHQg5efz.js" as="script"><link rel="prefetch" href="/assets/index.html-WqTd1C9w.js" as="script"><link rel="prefetch" href="/assets/Arthas.html-oL5Zsz4m.js" as="script"><link rel="prefetch" href="/assets/Kibana.html-Z5gGewsb.js" as="script"><link rel="prefetch" href="/assets/Linux常用命令.html-4Dt4HwYk.js" as="script"><link rel="prefetch" href="/assets/Postman.html-NP-g-oov.js" as="script"><link rel="prefetch" href="/assets/index.html-2Ry7Ikfu.js" as="script"><link rel="prefetch" href="/assets/功能触发方式.html-nJ12fJLx.js" as="script"><link rel="prefetch" href="/assets/常用工具和软件.html-fiCZRIg-.js" as="script"><link rel="prefetch" href="/assets/Java基础.html-wlHlQ_2I.js" as="script"><link rel="prefetch" href="/assets/index.html-CPDw_7Ti.js" as="script"><link rel="prefetch" href="/assets/参数校验(javax.validation).html-0t2sczfJ.js" as="script"><link rel="prefetch" href="/assets/类加载器.html-O_N4E4Qd.js" as="script"><link rel="prefetch" href="/assets/代码优化，即代码提交前应该做的一些事情.html-qlN62054.js" as="script"><link rel="prefetch" href="/assets/代码重构的一些方法.html-h5XlLLo6.js" as="script"><link rel="prefetch" href="/assets/去除if else的常用方法.html-s0LNQ8az.js" as="script"><link rel="prefetch" href="/assets/Gossip协议详解.html-K7ID5sPD.js" as="script"><link rel="prefetch" href="/assets/Paxos算法.html-ey0XVHsm.js" as="script"><link rel="prefetch" href="/assets/Raft算法.html-VtXNYdLC.js" as="script"><link rel="prefetch" href="/assets/index.html-SgTGj6sX.js" as="script"><link rel="prefetch" href="/assets/RPC.html-UMFisG97.js" as="script"><link rel="prefetch" href="/assets/Zookeeper核心知识点.html-awpJklc4.js" as="script"><link rel="prefetch" href="/assets/一致性hash算法.html-3PzMh8fr.js" as="script"><link rel="prefetch" href="/assets/分布式ID.html--LWcWAAO.js" as="script"><link rel="prefetch" href="/assets/分布式Session的实现方案.html-fSLIpFtT.js" as="script"><link rel="prefetch" href="/assets/分布式事务.html-Prj-Pbvf.js" as="script"><link rel="prefetch" href="/assets/分布式锁.html-7QgRBGAq.js" as="script"><link rel="prefetch" href="/assets/微服务网关总结.html-0jS1eKUY.js" as="script"><link rel="prefetch" href="/assets/电商超卖问题解决.html-Uf-7QpCy.js" as="script"><link rel="prefetch" href="/assets/Dubbo与SpringCloud区别.html-wGcQIVu5.js" as="script"><link rel="prefetch" href="/assets/index.html-ojchkWHT.js" as="script"><link rel="prefetch" href="/assets/ElasticSearch.html-qOcHrrZR.js" as="script"><link rel="prefetch" href="/assets/index.html-lkoxCC3I.js" as="script"><link rel="prefetch" href="/assets/index.html-vBv73N1h.js" as="script"><link rel="prefetch" href="/assets/index.html-RhFWlesS.js" as="script"><link rel="prefetch" href="/assets/分库分表方案.html-QuJqww9p.js" as="script"><link rel="prefetch" href="/assets/如何保障MySQL和Redis的数据一致性.html-Fr7WxUVo.js" as="script"><link rel="prefetch" href="/assets/如何解决MySQL主从复制延时问题.html-h9tdnEiT.js" as="script"><link rel="prefetch" href="/assets/数据库性能优化策略详解.html-SXG4xtS5.js" as="script"><link rel="prefetch" href="/assets/示例表结构.html-SnOyk9CS.js" as="script"><link rel="prefetch" href="/assets/index.html-stvNzp8s.js" as="script"><link rel="prefetch" href="/assets/排序.html-hNhQs0lH.js" as="script"><link rel="prefetch" href="/assets/搜索.html-ZOHsBjcA.js" as="script"><link rel="prefetch" href="/assets/数据结构与算法总结.html-gV8fnjqW.js" as="script"><link rel="prefetch" href="/assets/index.html-RHfd1IcK.js" as="script"><link rel="prefetch" href="/assets/软件系统中的上游与下游.html-mAtniMpg.js" as="script"><link rel="prefetch" href="/assets/bitmap.html-fFcP7Y0E.js" as="script"><link rel="prefetch" href="/assets/index.html-ulxSINDa.js" as="script"><link rel="prefetch" href="/assets/TopK-排序.html-lkNsPqQL.js" as="script"><link rel="prefetch" href="/assets/大数据处理方案.html-M1XEaSsk.js" as="script"><link rel="prefetch" href="/assets/相同数据.html-mdm_bUFL.js" as="script"><link rel="prefetch" href="/assets/统计不同号码的个数.html-w5_3aM6d.js" as="script"><link rel="prefetch" href="/assets/ArrayList源码分析.html-TOzTHLpg.js" as="script"><link rel="prefetch" href="/assets/HashMap源码分析.html-Rp8Xpmvd.js" as="script"><link rel="prefetch" href="/assets/index.html-5tvAINVk.js" as="script"><link rel="prefetch" href="/assets/10w级别数据Excel导入如何优化.html-QW_F0EgB.js" as="script"><link rel="prefetch" href="/assets/Java后端接口响应慢的排查方法及解决方案.html-2xZjAmHm.js" as="script"><link rel="prefetch" href="/assets/Java定时任务详解.html-e-fqAymP.js" as="script"><link rel="prefetch" href="/assets/Java对接支付渠道.html-XhwdW3gz.js" as="script"><link rel="prefetch" href="/assets/Java系统问题排查方法.html-cS8ujLH3.js" as="script"><link rel="prefetch" href="/assets/JWT基本概念详解.html-qZvNee5D.js" as="script"><link rel="prefetch" href="/assets/JWT身份认证优缺点分析.html-xo_vnLB6.js" as="script"><link rel="prefetch" href="/assets/OAuth2-流程原理.html-ejaZwQ8w.js" as="script"><link rel="prefetch" href="/assets/index.html-AJdQFVh8.js" as="script"><link rel="prefetch" href="/assets/SSO 单点登录详解.html-x-teFZeT.js" as="script"><link rel="prefetch" href="/assets/Web 实时消息推送详解.html-z7_Rv4NJ.js" as="script"><link rel="prefetch" href="/assets/如何统计网站UV.html-1sd3FxWp.js" as="script"><link rel="prefetch" href="/assets/如何解决大文件上传问题.html-HRzLL4No.js" as="script"><link rel="prefetch" href="/assets/如何设计一个排行榜.html-G0iNonVN.js" as="script"><link rel="prefetch" href="/assets/如何设计一个注册中心.html-lW5dTOeG.js" as="script"><link rel="prefetch" href="/assets/如何设计一个秒杀系统.html-WzlB_USV.js" as="script"><link rel="prefetch" href="/assets/如何设计一个高并发系统.html--HBvR0rM.js" as="script"><link rel="prefetch" href="/assets/如何设计微博Feed流、信息流系统.html-iKmMyPsN.js" as="script"><link rel="prefetch" href="/assets/实时订阅推送设计与实现.html-cftEU0P9.js" as="script"><link rel="prefetch" href="/assets/常用加密算法总结.html-J__6bWSn.js" as="script"><link rel="prefetch" href="/assets/常见的限流算法的原理以及优缺点.html-8Kv0rhpL.js" as="script"><link rel="prefetch" href="/assets/微信红包系统如何设计.html-RLKwoz6V.js" as="script"><link rel="prefetch" href="/assets/扫码登录原理.html-XKhFx7JG.js" as="script"><link rel="prefetch" href="/assets/敏感词过滤方案总结.html-jEhFkH_R.js" as="script"><link rel="prefetch" href="/assets/数据脱敏方案总结.html-IQHUdjmC.js" as="script"><link rel="prefetch" href="/assets/权限系统设计详解.html-1bH7A3-T.js" as="script"><link rel="prefetch" href="/assets/短链系统设计.html-uhKX7VmF.js" as="script"><link rel="prefetch" href="/assets/网站安全漏洞-大全.html-PAOKf_Vo.js" as="script"><link rel="prefetch" href="/assets/认证授权基础概念详解.html-IVX0g7va.js" as="script"><link rel="prefetch" href="/assets/购物车系统如何设计.html-ynGf7yMr.js" as="script"><link rel="prefetch" href="/assets/超时订单自动取消.html-YE2jELlh.js" as="script"><link rel="prefetch" href="/assets/index.html-S6q5-pdh.js" as="script"><link rel="prefetch" href="/assets/万物都是增删改查.html-Onu1-5Wm.js" as="script"><link rel="prefetch" href="/assets/性能优化.html-GTxhvnpe.js" as="script"><link rel="prefetch" href="/assets/手动调用Dubbo接口方案.html-tPhfDrW-.js" as="script"><link rel="prefetch" href="/assets/线程安全的日期处理.html-4DBi-9j-.js" as="script"><link rel="prefetch" href="/assets/index.html-MtuddqEZ.js" as="script"><link rel="prefetch" href="/assets/index.html-wwiKpFWY.js" as="script"><link rel="prefetch" href="/assets/index.html-PNvL7bri.js" as="script"><link rel="prefetch" href="/assets/设计模式伪代码.html-CuCCT0gl.js" as="script"><link rel="prefetch" href="/assets/设计模式总结.html-3z3zERGp.js" as="script"><link rel="prefetch" href="/assets/面向对象的六原则一法则.html-9jc_NSuh.js" as="script"><link rel="prefetch" href="/assets/Nacos配置中心交互模型是 push 还是 pull ？（原理_源码分析）.html-bXLpqsEN.js" as="script"><link rel="prefetch" href="/assets/index.html-H9Nnx3Jp.js" as="script"><link rel="prefetch" href="/assets/index.html-PexTThQO.js" as="script"><link rel="prefetch" href="/assets/个人亮点.html-mXTA3RoQ.js" as="script"><link rel="prefetch" href="/assets/项目开发中常遇到的各种难点以及解决思路和方案.html-LxWa1YHr.js" as="script"><link rel="prefetch" href="/assets/index.html-4freO7gf.js" as="script"><link rel="prefetch" href="/assets/消息队列常见问题和解决方案.html-CCUpcsE8.js" as="script"><link rel="prefetch" href="/assets/index.html-L-7s5Mqp.js" as="script"><link rel="prefetch" href="/assets/index.html-sWWLJwU-.js" as="script"><link rel="prefetch" href="/assets/index.html-Cog-q6up.js" as="script"><link rel="prefetch" href="/assets/index.html-dz5mM4Cv.js" as="script"><link rel="prefetch" href="/assets/index.html-471tRzTt.js" as="script"><link rel="prefetch" href="/assets/必读经典.html-0YPs-ugp.js" as="script"><link rel="prefetch" href="/assets/index.html-0s-N3jNq.js" as="script"><link rel="prefetch" href="/assets/index.html-z3FKfMtn.js" as="script"><link rel="prefetch" href="/assets/信息系统项目管理师-上午选择题.html-fOFid5NI.js" as="script"><link rel="prefetch" href="/assets/信息系统项目管理师-下午案例分析.html-2tt3LS6_.js" as="script"><link rel="prefetch" href="/assets/信息系统项目管理师-总结-Jef.html-b-enMIsJ.js" as="script"><link rel="prefetch" href="/assets/系统架构设计师复习策略.html-rnB3moir.js" as="script"><link rel="prefetch" href="/assets/Apollo.html-DMDOUjhl.js" as="script"><link rel="prefetch" href="/assets/CURL.html-s7i3oqNG.js" as="script"><link rel="prefetch" href="/assets/index.html-stfb31DR.js" as="script"><link rel="prefetch" href="/assets/浏览器Debug.html-BL55fZWn.js" as="script"><link rel="prefetch" href="/assets/浏览器控制台.html-3qsc0uSB.js" as="script"><link rel="prefetch" href="/assets/bat文件运用.html-XNMl99Qx.js" as="script"><link rel="prefetch" href="/assets/sh文件运用.html-isIcXg4K.js" as="script"><link rel="prefetch" href="/assets/Git常用命令.html-_0LLp8FB.js" as="script"><link rel="prefetch" href="/assets/Git常用设置.html-qlc7P6Nc.js" as="script"><link rel="prefetch" href="/assets/Docker常用命令.html-KeWLASMR.js" as="script"><link rel="prefetch" href="/assets/Docker常用组件安装.html-lfw5GWSD.js" as="script"><link rel="prefetch" href="/assets/skywalking-docker-compose.html-C-Nc491p.js" as="script"><link rel="prefetch" href="/assets/DBeaver使用.html-nyYllpj8.js" as="script"><link rel="prefetch" href="/assets/Debug.html-WGMcNA2V.js" as="script"><link rel="prefetch" href="/assets/Debug回到某一行代码.html-kmje1anD.js" as="script"><link rel="prefetch" href="/assets/HttpClient.html-PObX4Hw9.js" as="script"><link rel="prefetch" href="/assets/IDEA Build构建菜单.html-4M4BpmEo.js" as="script"><link rel="prefetch" href="/assets/IDEA jar相关.html-f5j-t0bS.js" as="script"><link rel="prefetch" href="/assets/IDEA常用设置与使用.html-IXlreTQN.js" as="script"><link rel="prefetch" href="/assets/IDEA快捷键.html-q7Pe4YND.js" as="script"><link rel="prefetch" href="/assets/IDEA推荐安装的插件列表.html-JViNTMJI.js" as="script"><link rel="prefetch" href="/assets/index.html-_JO5srRD.js" as="script"><link rel="prefetch" href="/assets/Markdown示例.html-fWNEFmHu.js" as="script"><link rel="prefetch" href="/assets/Typora快捷键.html-sWMEcq7P.js" as="script"><link rel="prefetch" href="/assets/Typora设置.html-Eh1SGsLq.js" as="script"><link rel="prefetch" href="/assets/word转Markdown文件.html--KhAfpRr.js" as="script"><link rel="prefetch" href="/assets/Maven命令.html-BRmoatRm.js" as="script"><link rel="prefetch" href="/assets/maven配置与安装.html-fcWevA10.js" as="script"><link rel="prefetch" href="/assets/RocketMQ本地搭建.html-sObYmr-_.js" as="script"><link rel="prefetch" href="/assets/Sublime Text Key Bindings.html-t3v9AJfA.js" as="script"><link rel="prefetch" href="/assets/Sublime Text Settings.html-TKnCoM2b.js" as="script"><link rel="prefetch" href="/assets/Sublime text将一列转换为excel中的多列.html-6FojlAle.js" as="script"><link rel="prefetch" href="/assets/Sublime Text将指定符号替换成换行符.html-0Q22rT0o.js" as="script"><link rel="prefetch" href="/assets/Sublime Text快捷键.html-0YEgjVg7.js" as="script"><link rel="prefetch" href="/assets/Sublime text批量删除空白行.html-QzV-h3eH.js" as="script"><link rel="prefetch" href="/assets/Sublime Text插件.html-NFiAnTYH.js" as="script"><link rel="prefetch" href="/assets/Sublime Text生成SQL.html-wtElSmGx.js" as="script"><link rel="prefetch" href="/assets/jdk8常用示例.html-DJV79CiI.js" as="script"><link rel="prefetch" href="/assets/Tomcat安装与配置.html-qN9kWXWr.js" as="script"><link rel="prefetch" href="/assets/接口和抽象类.html-nKoZRScv.js" as="script"><link rel="prefetch" href="/assets/注册中心–Eureka、Zookeeper、Nacos、Consul的区别.html-Tftge7fP.js" as="script"><link rel="prefetch" href="/assets/消息队列对比.html-L2O-9I56.js" as="script"><link rel="prefetch" href="/assets/Redis总结.html-sXu83P4z.js" as="script"><link rel="prefetch" href="/assets/Redis的使用场景.html-fSjQNoq2.js" as="script"><link rel="prefetch" href="/assets/Redis问题和解决方案.html-pnzxRrcg.js" as="script"><link rel="prefetch" href="/assets/布隆过滤器.html-bbiq3jsC.js" as="script"><link rel="prefetch" href="/assets/企业信息化战略与实施.html-5JozXvfM.js" as="script"><link rel="prefetch" href="/assets/计算机组成与体系结构.html-deDc8hlx.js" as="script"><link rel="prefetch" href="/assets/软件工程.html-NEofaQs9.js" as="script"><link rel="prefetch" href="/assets/软件架构设计师考试背记精要.html-yBAY0L5g.js" as="script"><link rel="prefetch" href="/assets/信息系统项目管理师-我的论文.html-8gT0gsWT.js" as="script"><link rel="prefetch" href="/assets/信息系统项目管理师-论文指导.html-wqgkuZuv.js" as="script"><link rel="prefetch" href="/assets/信息系统项目管理师-论文范文.html-1_DVvd2n.js" as="script"><link rel="prefetch" href="/assets/项目管理过程组、知识领域、49个过程.html-8ePLq_Z3.js" as="script"><link rel="prefetch" href="/assets/系统架构设计师-分析设计流程.html-nAe9MTgt.js" as="script"><link rel="prefetch" href="/assets/论区块链技术及应用.html-iTc4q_Ku.js" as="script"><link rel="prefetch" href="/assets/论基于构件的软件开发方法及其应用.html-ktILApor.js" as="script"><link rel="prefetch" href="/assets/论微服务架构及应用-范文.html-JYa6QUbT.js" as="script"><link rel="prefetch" href="/assets/论湖仓一体架构及其应用.html-qva-Jy1t.js" as="script"><link rel="prefetch" href="/assets/论软件维护方法及其应用.html-3UuruI-y.js" as="script"><link rel="prefetch" href="/assets/404.html-fuJ7FVIi.js" as="script"><link rel="prefetch" href="/assets/index.html-hGgbCqAS.js" as="script"><link rel="prefetch" href="/assets/index.html-Q9lFKTqL.js" as="script"><link rel="prefetch" href="/assets/index.html-NLClQqQz.js" as="script"><link rel="prefetch" href="/assets/index.html-_lbwxHm4.js" as="script"><link rel="prefetch" href="/assets/index.html-S8kvtSuT.js" as="script"><link rel="prefetch" href="/assets/index.html-fUJrDGpr.js" as="script"><link rel="prefetch" href="/assets/index.html-y6_hWUsw.js" as="script"><link rel="prefetch" href="/assets/index.html-Kp7flGyQ.js" as="script"><link rel="prefetch" href="/assets/index.html-Yl5uz8s5.js" as="script"><link rel="prefetch" href="/assets/index.html-iPvxi81E.js" as="script"><link rel="prefetch" href="/assets/index.html-RlmsDMZC.js" as="script"><link rel="prefetch" href="/assets/index.html-jr4s0O8v.js" as="script"><link rel="prefetch" href="/assets/index.html-Ia6YU0BW.js" as="script"><link rel="prefetch" href="/assets/index.html-Tdraqt_x.js" as="script"><link rel="prefetch" href="/assets/index.html-msIr0sVW.js" as="script"><link rel="prefetch" href="/assets/index.html-AaOW2LfS.js" as="script"><link rel="prefetch" href="/assets/index.html-pPSqty7Z.js" as="script"><link rel="prefetch" href="/assets/index.html-Vm5SMuYz.js" as="script"><link rel="prefetch" href="/assets/index.html-5OxInI95.js" as="script"><link rel="prefetch" href="/assets/index.html-EECLr0zM.js" as="script"><link rel="prefetch" href="/assets/index.html-0zKkZKsd.js" as="script"><link rel="prefetch" href="/assets/index.html-8qMVZt6x.js" as="script"><link rel="prefetch" href="/assets/index.html-YjfH4p2z.js" as="script"><link rel="prefetch" href="/assets/index.html-qM0jcj1h.js" as="script"><link rel="prefetch" href="/assets/index.html-CbWCE13r.js" as="script"><link rel="prefetch" href="/assets/index.html-oH61Ivxw.js" as="script"><link rel="prefetch" href="/assets/index.html-b2EcrwPo.js" as="script"><link rel="prefetch" href="/assets/index.html-sDF0_ArJ.js" as="script"><link rel="prefetch" href="/assets/index.html-dnyCc4W4.js" as="script"><link rel="prefetch" href="/assets/index.html-maK3Rwus.js" as="script"><link rel="prefetch" href="/assets/index.html-tZhEG1Si.js" as="script"><link rel="prefetch" href="/assets/index.html-UQX2AjAG.js" as="script"><link rel="prefetch" href="/assets/index.html-LrCjl5ZS.js" as="script"><link rel="prefetch" href="/assets/index.html-HYk3pQM-.js" as="script"><link rel="prefetch" href="/assets/index.html--DIf5je0.js" as="script"><link rel="prefetch" href="/assets/index.html-myXpzGms.js" as="script"><link rel="prefetch" href="/assets/index.html-arMZ15ql.js" as="script"><link rel="prefetch" href="/assets/index.html-tAqwGZWw.js" as="script"><link rel="prefetch" href="/assets/index.html-4doQXSKe.js" as="script"><link rel="prefetch" href="/assets/index.html-C7kmBOTj.js" as="script"><link rel="prefetch" href="/assets/index.html-GdzAkSq9.js" as="script"><link rel="prefetch" href="/assets/index.html-tf-7ONgh.js" as="script"><link rel="prefetch" href="/assets/index.html-x7Zd7cgx.js" as="script"><link rel="prefetch" href="/assets/index.html-PP8uPwCK.js" as="script"><link rel="prefetch" href="/assets/index.html-Wld-hBLF.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-mC0Qcr12.js" as="script"><link rel="prefetch" href="/assets/SearchResult-MMu3L8Qp.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="vp-link vp-brand vp-brand" href="/"><img class="vp-nav-logo" src="https://theme-hope-assets.vuejs.press/logo.svg" alt="Jef Blog"><!----><span class="vp-site-name hide-in-pad">Jef Blog</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><nav class="vp-nav-links"><div class="nav-item hide-in-mobile"><a aria-label="主页" class="vp-link nav-link nav-link" href="/"><span class="font-icon icon fa-fw fa-sm fas fa-home" style=""></span>主页<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="技术栈" class="vp-link nav-link active nav-link active" href="/home.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>技术栈<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="软件工具" class="vp-link nav-link nav-link" href="/tool.html"><span class="font-icon icon fa-fw fa-sm fas fa-lock" style=""></span>软件工具<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="技术书籍" class="vp-link nav-link nav-link" href="/books.html"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span>技术书籍<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="学习" class="vp-link nav-link nav-link" href="/study.html"><!---->学习<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="网站相关" class="vp-link nav-link nav-link" href="/intro.html"><span class="font-icon icon fa-fw fa-sm fas fa-circle-info" style=""></span>网站相关<!----></a></div></nav><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><div class="nav-item vp-repo"><a class="vp-repo-link" href="https://github.com/tufujie/jef-docx" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!--[--><button type="button" class="search-pro-button" role="search" aria-label="搜索"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg><div class="search-pro-placeholder">搜索</div><div class="search-pro-key-hints"><kbd class="search-pro-key">Ctrl</kbd><kbd class="search-pro-key">K</kbd></div></button><!--]--><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><span class="vp-sidebar-title">常用框架</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">代码优化</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><span class="vp-sidebar-title">分布式</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><span class="vp-sidebar-title">概念</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><span class="vp-sidebar-title">高可用</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><span class="vp-sidebar-title">高性能</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><span class="vp-sidebar-title">海量数据</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><span class="vp-sidebar-title">计算机基础</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable active" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><span class="vp-sidebar-title">技术选型</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable active" type="button"><!----><span class="vp-sidebar-title">技术栈对比</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><!--[--><a aria-label="技术栈对比" class="vp-link nav-link active vp-sidebar-link vp-sidebar-page active nav-link active vp-sidebar-link vp-sidebar-page active" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html"><!---->技术栈对比<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="Java基础" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#java基础"><!---->Java基础<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="集合" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#集合"><!---->集合<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="IO" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#io"><!---->IO<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="异常" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#异常"><!---->异常<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="String、StringBuffer和StringBuilder★★★" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#string、stringbuffer和stringbuilder★★★"><!---->String、StringBuffer和StringBuilder★★★<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="equals()和hashCode()★★★" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#equals-和hashcode-★★★"><!---->equals()和hashCode()★★★<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="==和equals() ★★★" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#和equals-★★★"><!---->==和equals() ★★★<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="面向对象和面向过程★★★" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#面向对象和面向过程★★★"><!---->面向对象和面向过程★★★<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="成员变量与局部变量★★★" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#成员变量与局部变量★★★"><!---->成员变量与局部变量★★★<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="深拷贝和浅拷贝★" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#深拷贝和浅拷贝★"><!---->深拷贝和浅拷贝★<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="重载（Overload）和重写（Override）★★★" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#重载-overload-和重写-override-★★★"><!---->重载（Overload）和重写（Override）★★★<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="String##equals()和Object##equals()" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#string-equals-和object-equals"><!---->String##equals()和Object##equals()<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Iterator和ListIterator" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#iterator和listiterator"><!---->Iterator和ListIterator<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Statement和PreparedStatement" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#statement和preparedstatement"><!---->Statement和PreparedStatement<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="@Before和@BeforeClass" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#before和-beforeclass"><!---->@Before和@BeforeClass<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="java.util.Date与java.sql.Date" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#java-util-date与java-sql-date"><!---->java.util.Date与java.sql.Date<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Java和JavaSciprt" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#java和javasciprt"><!---->Java和JavaSciprt<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Java和C++" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#java和c"><!---->Java和C++<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="JDK、JRE和JVM" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#jdk、jre和jvm"><!---->JDK、JRE和JVM<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Java和C++" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#java和c-1"><!---->Java和C++<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="基本类型和包装类型" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#基本类型和包装类型"><!---->基本类型和包装类型<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="++i与i++" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#i与i"><!---->++i与i++<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="int和Integer" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#int和integer"><!---->int和Integer<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="a=a+b与a+=b" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#a-a-b与a-b"><!---->a=a+b与a+=b<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="字符型常量和字符串常量" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#字符型常量和字符串常量"><!---->字符型常量和字符串常量<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="标识符和关键字是什么" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#标识符和关键字是什么"><!---->标识符和关键字是什么<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="continue、break和return" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#continue、break和return"><!---->continue、break和return<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="public，private，protected，以及不写（默认）" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#public-private-protected-以及不写-默认"><!---->public，private，protected，以及不写（默认）<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="&amp;和&amp;&amp;" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#和"><!---->&amp;和&amp;&amp;<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="final、finally、finalize" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#final、finally、finalize"><!---->final、finally、finalize<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="形参与实参" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#形参与实参"><!---->形参与实参<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="静态变量和实例变量" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#静态变量和实例变量"><!---->静态变量和实例变量<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="对象的相等和引用相等" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#对象的相等和引用相等"><!---->对象的相等和引用相等<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="普通类和抽象类" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#普通类和抽象类"><!---->普通类和抽象类<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="组合、聚合和关联" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#组合、聚合和关联"><!---->组合、聚合和关联<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="嵌套公共静态类与顶级类" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#嵌套公共静态类与顶级类"><!---->嵌套公共静态类与顶级类<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="数据库" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#数据库"><!---->数据库<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="InnoDB与MyISAM★★★" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#innodb与myisam★★★"><!---->InnoDB与MyISAM★★★<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="B+树索引和哈希索引★★★" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#b-树索引和哈希索引★★★"><!---->B+树索引和哈希索引★★★<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="乐观锁和悲观锁★★★" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#乐观锁和悲观锁★★★"><!---->乐观锁和悲观锁★★★<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="表级锁、行级锁和页面锁★★★" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#表级锁、行级锁和页面锁★★★"><!---->表级锁、行级锁和页面锁★★★<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="共享锁和排他锁" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#共享锁和排他锁"><!---->共享锁和排他锁<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="乐观锁和悲观锁" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#乐观锁和悲观锁"><!---->乐观锁和悲观锁<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="公平锁和非公平锁" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#公平锁和非公平锁"><!---->公平锁和非公平锁<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="MyISAM Static和MyISAM Dynamic" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#myisam-static和myisam-dynamic"><!---->MyISAM Static和MyISAM Dynamic<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="binlog录入格式statement，row和mixed" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#binlog录入格式statement-row和mixed"><!---->binlog录入格式statement，row和mixed<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="外连接、内连接与自连接" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#外连接、内连接与自连接"><!---->外连接、内连接与自连接<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="内连接、左连接、右连接" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#内连接、左连接、右连接"><!---->内连接、左连接、右连接<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="drop、delete与truncate的区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#drop、delete与truncate的区别"><!---->drop、delete与truncate的区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="char 和 varchar" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#char-和-varchar"><!---->char 和 varchar<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="float 和 double" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#float-和-double"><!---->float 和 double<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="BLOB和TEXT" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#blob和text"><!---->BLOB和TEXT<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="NOW()和CURRENT_DATE()" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#now-和current-date"><!---->NOW()和CURRENT_DATE()<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="主键和候选键" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#主键和候选键"><!---->主键和候选键<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="主键和外键" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#主键和外键"><!---->主键和外键<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="主键、外键和索引" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#主键、外键和索引"><!---->主键、外键和索引<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="主键与唯一索引" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#主键与唯一索引"><!---->主键与唯一索引<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="索引，主键，唯一索引，联合索引" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#索引-主键-唯一索引-联合索引"><!---->索引，主键，唯一索引，联合索引<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="MySQL_fetch_array和MySQL_fetch_object" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#mysql-fetch-array和mysql-fetch-object"><!---->MySQL_fetch_array和MySQL_fetch_object<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="计算机网络" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#计算机网络"><!---->计算机网络<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="TCP与UDP★★★" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#tcp与udp★★★"><!---->TCP与UDP★★★<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="HTTP和HTTPS★★★" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#http和https★★★"><!---->HTTP和HTTPS★★★<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="HTTP1.0、HTTP1.1和HTTP2.0" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#http1-0、http1-1和http2-0"><!---->HTTP1.0、HTTP1.1和HTTP2.0<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="HTTP的长连接与短连接" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#http的长连接与短连接"><!---->HTTP的长连接与短连接<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="GET和POST★★★" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#get和post★★★"><!---->GET和POST★★★<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="URI和URL的区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#uri和url的区别"><!---->URI和URL的区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="TIME WAIT和CLOSE WAIT的区别在哪?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#time-wait和close-wait的区别在哪"><!---->TIME WAIT和CLOSE WAIT的区别在哪?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="http响应吗301和302" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#http响应吗301和302"><!---->http响应吗301和302<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Forward和Redirect★★★" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#forward和redirect★★★"><!---->Forward和Redirect★★★<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="缓存" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#缓存-1"><!---->缓存<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="Redis与Memcache" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#redis与memcache"><!---->Redis与Memcache<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Redis，Memcache，MongoDB" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#redis-memcache-mongodb"><!---->Redis，Memcache，MongoDB<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Redis锁Zookeeper锁" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#redis锁zookeeper锁"><!---->Redis锁Zookeeper锁<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="RDB和AOF" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#rdb和aof"><!---->RDB和AOF<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="框架" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#框架"><!---->框架<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="SpringBoot和SpringCloud" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#springboot和springcloud"><!---->SpringBoot和SpringCloud<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Spring Boot、Spring MVC和Spring" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#spring-boot、spring-mvc和spring"><!---->Spring Boot、Spring MVC和Spring<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Spring Boo 1.X和t2.X" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#spring-boo-1-x和t2-x"><!---->Spring Boo 1.X和t2.X<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Spring Boot打成的jar和普通的jar" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#spring-boot打成的jar和普通的jar"><!---->Spring Boot打成的jar和普通的jar<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="在Spring AOP中，关注点和横切关注点" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#在spring-aop中-关注点和横切关注点"><!---->在Spring AOP中，关注点和横切关注点<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Spring AOP和AspectJ AOP" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#spring-aop和aspectj-aop"><!---->Spring AOP和AspectJ AOP<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="ApplicationContext和BeanFactory" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#applicationcontext和beanfactory"><!---->ApplicationContext和BeanFactory<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="BeanFactory和FactoryBean" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#beanfactory和factorybean"><!---->BeanFactory和FactoryBean<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="@Component和@Bean" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#component和-bean"><!---->@Component和@Bean<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="@Autowired和@Resource★★★" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#autowired和-resource★★★"><!---->@Autowired和@Resource★★★<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="@Component，@Controller，@Repository，@Service" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#component-controller-repository-service"><!---->@Component，@Controller，@Repository，@Service<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Dubbo和SpringCloud" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#dubbo和springcloud"><!---->Dubbo和SpringCloud<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="REST和RPC" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#rest和rpc"><!---->REST和RPC<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="RPC和HTTP" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#rpc和http"><!---->RPC和HTTP<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="RPC和消息队列" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#rpc和消息队列"><!---->RPC和消息队列<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Dubbo和Dubbox" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#dubbo和dubbox"><!---->Dubbo和Dubbox<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Dubbo SPI和Java SPI" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#dubbo-spi和java-spi"><!---->Dubbo SPI和Java SPI<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Hibernate和JPA" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#hibernate和jpa"><!---->Hibernate和JPA<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Eureka和Zookeeper" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#eureka和zookeeper"><!---->Eureka和Zookeeper<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Feign和Ribbon" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#feign和ribbon"><!---->Feign和Ribbon<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="熔断和降级" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#熔断和降级"><!---->熔断和降级<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="运维" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#运维"><!---->运维<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="分布式、集群和微服务" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94.html#分布式、集群和微服务"><!---->分布式、集群和微服务<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li><li><!--[--><a aria-label="接口和抽象类" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB.html"><!---->接口和抽象类<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="消息队列对比" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AF%B9%E6%AF%94.html"><!---->消息队列对比<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="注册中心–Eureka、Zookeeper、Nacos、Consul的区别" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E2%80%93Eureka%E3%80%81Zookeeper%E3%80%81Nacos%E3%80%81Consul%E7%9A%84%E5%8C%BA%E5%88%AB.html"><!---->注册中心–Eureka、Zookeeper、Nacos、Consul的区别<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul></section></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><span class="vp-sidebar-title">解决方案</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><span class="vp-sidebar-title">配置中心</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><span class="vp-sidebar-title">软件质量</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><span class="vp-sidebar-title">设计模式</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><span class="vp-sidebar-title">数据结构与算法</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><span class="vp-sidebar-title">数据库</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><span class="vp-sidebar-title">搜索引擎</span><span class="vp-arrow end"></span></button><!----></section></li><li><!--[--><a aria-label="系统架构设计" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/home/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html"><!---->系统架构设计<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><span class="vp-sidebar-title">系统设计</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><span class="vp-sidebar-title">项目</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><span class="vp-sidebar-title">源码分析</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><span class="vp-sidebar-title">Java</span><span class="vp-arrow end"></span></button><!----></section></li><li><!--[--><a aria-label="Java技术可行性分析指南" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/home/Java%E6%8A%80%E6%9C%AF%E5%8F%AF%E8%A1%8C%E6%80%A7%E5%88%86%E6%9E%90%E6%8C%87%E5%8D%97.html"><!---->Java技术可行性分析指南<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!--[--><!----><!--]--><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->技术栈对比</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://mister-hope.com" target="_blank" rel="noopener noreferrer">Jef</a></span><span property="author" content="Jef"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2024-01-27T09:32:16.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 155 分钟</span><meta property="timeRequired" content="PT155M"></span><!----><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#java基础">Java基础</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#集合">集合</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#io">IO</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#异常">异常</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#string、stringbuffer和stringbuilder★★★">String、StringBuffer和StringBuilder★★★</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#equals-和hashcode-★★★">equals()和hashCode()★★★</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#和equals-★★★">==和equals() ★★★</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#面向对象和面向过程★★★">面向对象和面向过程★★★</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#成员变量与局部变量★★★">成员变量与局部变量★★★</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#深拷贝和浅拷贝★">深拷贝和浅拷贝★</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#重载-overload-和重写-override-★★★">重载（Overload）和重写（Override）★★★</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#string-equals-和object-equals">String##equals()和Object##equals()</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#iterator和listiterator">Iterator和ListIterator</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#statement和preparedstatement">Statement和PreparedStatement</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#before和-beforeclass">@Before和@BeforeClass</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#java-util-date与java-sql-date">java.util.Date与java.sql.Date</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#java和javasciprt">Java和JavaSciprt</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#java和c">Java和C++</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#jdk、jre和jvm">JDK、JRE和JVM</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#java和c-1">Java和C++</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#基本类型和包装类型">基本类型和包装类型</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#i与i">++i与i++</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#int和integer">int和Integer</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#a-a-b与a-b">a=a+b与a+=b</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#字符型常量和字符串常量">字符型常量和字符串常量</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#标识符和关键字是什么">标识符和关键字是什么</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#continue、break和return">continue、break和return</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#public-private-protected-以及不写-默认">public，private，protected，以及不写（默认）</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#和">&amp;和&amp;&amp;</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#final、finally、finalize">final、finally、finalize</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#形参与实参">形参与实参</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#静态变量和实例变量">静态变量和实例变量</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#对象的相等和引用相等">对象的相等和引用相等</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#普通类和抽象类">普通类和抽象类</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#组合、聚合和关联">组合、聚合和关联</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#嵌套公共静态类与顶级类">嵌套公共静态类与顶级类</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#数据库">数据库</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#innodb与myisam★★★">InnoDB与MyISAM★★★</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#b-树索引和哈希索引★★★">B+树索引和哈希索引★★★</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#乐观锁和悲观锁★★★">乐观锁和悲观锁★★★</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#表级锁、行级锁和页面锁★★★">表级锁、行级锁和页面锁★★★</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#共享锁和排他锁">共享锁和排他锁</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#乐观锁和悲观锁">乐观锁和悲观锁</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#公平锁和非公平锁">公平锁和非公平锁</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#myisam-static和myisam-dynamic">MyISAM Static和MyISAM Dynamic</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#binlog录入格式statement-row和mixed">binlog录入格式statement，row和mixed</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#外连接、内连接与自连接">外连接、内连接与自连接</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#内连接、左连接、右连接">内连接、左连接、右连接</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#drop、delete与truncate的区别">drop、delete与truncate的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#char-和-varchar">char 和 varchar</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#float-和-double">float 和 double</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#blob和text">BLOB和TEXT</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#now-和current-date">NOW()和CURRENT_DATE()</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#主键和候选键">主键和候选键</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#主键和外键">主键和外键</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#主键、外键和索引">主键、外键和索引</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#主键与唯一索引">主键与唯一索引</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#索引-主键-唯一索引-联合索引">索引，主键，唯一索引，联合索引</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#mysql-fetch-array和mysql-fetch-object">MySQL_fetch_array和MySQL_fetch_object</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#计算机网络">计算机网络</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#tcp与udp★★★">TCP与UDP★★★</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#http和https★★★">HTTP和HTTPS★★★</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#http1-0、http1-1和http2-0">HTTP1.0、HTTP1.1和HTTP2.0</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#http的长连接与短连接">HTTP的长连接与短连接</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#get和post★★★">GET和POST★★★</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#uri和url的区别">URI和URL的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#time-wait和close-wait的区别在哪">TIME WAIT和CLOSE WAIT的区别在哪?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#http响应吗301和302">http响应吗301和302</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#forward和redirect★★★">Forward和Redirect★★★</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#缓存-1">缓存</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#redis与memcache">Redis与Memcache</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#redis-memcache-mongodb">Redis，Memcache，MongoDB</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#redis锁zookeeper锁">Redis锁Zookeeper锁</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#rdb和aof">RDB和AOF</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#框架">框架</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#springboot和springcloud">SpringBoot和SpringCloud</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#spring-boot、spring-mvc和spring">Spring Boot、Spring MVC和Spring</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#spring-boo-1-x和t2-x">Spring Boo 1.X和t2.X</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#spring-boot打成的jar和普通的jar">Spring Boot打成的jar和普通的jar</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#在spring-aop中-关注点和横切关注点">在Spring AOP中，关注点和横切关注点</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#spring-aop和aspectj-aop">Spring AOP和AspectJ AOP</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#applicationcontext和beanfactory">ApplicationContext和BeanFactory</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#beanfactory和factorybean">BeanFactory和FactoryBean</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#component和-bean">@Component和@Bean</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#autowired和-resource★★★">@Autowired和@Resource★★★</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#component-controller-repository-service">@Component，@Controller，@Repository，@Service</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#dubbo和springcloud">Dubbo和SpringCloud</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#rest和rpc">REST和RPC</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#rpc和http">RPC和HTTP</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#rpc和消息队列">RPC和消息队列</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#dubbo和dubbox">Dubbo和Dubbox</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#dubbo-spi和java-spi">Dubbo SPI和Java SPI</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#hibernate和jpa">Hibernate和JPA</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#eureka和zookeeper">Eureka和Zookeeper</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#feign和ribbon">Feign和Ribbon</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#熔断和降级">熔断和降级</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#运维">运维</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#分布式、集群和微服务">分布式、集群和微服务</a></li><!----><!--]--></ul></li><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!--[--><!----><!--]--><div class="theme-hope-content"><h2 id="java基础" tabindex="-1"><a class="header-anchor" href="#java基础" aria-hidden="true">#</a> Java基础</h2><h3 id="集合" tabindex="-1"><a class="header-anchor" href="#集合" aria-hidden="true">#</a> 集合</h3><h4 id="list" tabindex="-1"><a class="header-anchor" href="#list" aria-hidden="true">#</a> List</h4><h5 id="arraylist-与-linkedlist-★★★" tabindex="-1"><a class="header-anchor" href="#arraylist-与-linkedlist-★★★" aria-hidden="true">#</a> Arraylist 与 LinkedList ★★★</h5><p>ArrayList 是一种顺序存储的线性表，底层使用数组实现</p><p>LinkedList是一种链式存储的线性表，本质是一个双向链表，实现了List、Deque接口，可以当成双向链表、队列、栈使用。</p><ul><li><strong>是否保证线程安全</strong>： ArrayList和LinkedList都是不同步的，也就是不保证线程安全；</li><li><strong>底层数据结构</strong>： Arraylist 底层使用的是 Object 数组；LinkedList底层使用的是 双向链表 数据结构（JDK1.6 之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表）</li><li><strong>插入和删除是否受元素位置的影响</strong>：ArrayList采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。比如：执行add(E e)方法的时候， ArrayList会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i和第 i个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。LinkedList采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（add(E e)、addFirst(E e)、addLast(E e)、removeFirst() 、removeLast()），时间复杂度为 O(1)，如果是要在指定位置 i插入和删除元素的话（add(int index, E element)，remove(Object o)），时间复杂度为 O(n) ，因为需要先移动到指定位置再插入。</li><li><strong>是否支持快速随机访问</strong>： LinkedList因为使用链表储存，无法通过元素索引快速访问，不支持高效的随机元素访问，而ArrayList因为底层采用Object数组储存，可以通过索引快速随机访问。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而LinkedList 是 O(n)。</li><li><strong>内存空间占用</strong>： ArrayList 的空间浪费主要体现在在 List列表的结尾会预留一定的容量空间，而 LinkedList的空间花费则体现在它的每一个元素都需要消耗比 ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ul><p>我们在项目中一般是不会使用到 LinkedList 的，需要用到 LinkedList的场景几乎都可以使用 ArrayList 来代替，并且，性能通常会更好！就连LinkedList 的作者约书亚 · 布洛克（Josh Bloch）自己都说从来不会使用LinkedList 。</p><p>另外，不要下意识地认为 LinkedList作为链表就最适合元素增删的场景。我在上面也说了，LinkedList仅仅在头尾插入或者删除元素的时候时间复杂度近似O(1)，其他情况增删元素的时间复杂度都是 O(n) 。</p><p>补充内容：双向链表和双向循环链表</p><p><strong>双向链表</strong>： 包含两个指针，一个 prev 指向前一个节点，一个 next指向后一个节点。</p><p>另外推荐一篇把双向链表讲清楚的文章：<a href="https://juejin.cn/post/6844903648154271757" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6844903648154271757<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><figure><img src="/assets/双向链表-kWFPBCi2.png" alt="双向链表" tabindex="0" loading="lazy"><figcaption>双向链表</figcaption></figure><p><strong>双向循环链表</strong>： 最后一个节点的 next 指向 head，而 head 的 prev指向最后一个节点，构成一个环。</p><figure><img src="/assets/双向循环链表-2OzMGgE5.png" alt="双向循环链表" tabindex="0" loading="lazy"><figcaption>双向循环链表</figcaption></figure><p>补充内容:RandomAccess 接口</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RandomAccess</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看源码我们发现实际上 RandomAccess 接口中什么都没有定义。所以，在我看来 RandomAccess 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。</p><p>在 binarySearch() 方法中，它要判断传入的 list 是否 RandomAccess 的实例，如果是，调用indexedBinarySearch()方法，如果不是， 那么调用iteratorBinarySearch()方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">,</span> <span class="token class-name">T</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token keyword">instanceof</span> <span class="token class-name">RandomAccess</span> <span class="token operator">||</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token constant">BINARYSEARCH_THRESHOLD</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">indexedBinarySearch</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
    <span class="token keyword">return</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">iteratorBinarySearch</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ArrayList 实现了 RandomAccess 接口， 而 LinkedList 没有实现。为什么呢？我觉得还是和底层数据结构有关！ArrayList 底层是数组，而 LinkedList 底层是链表。数组天然支持随机访问，时间复杂度为 O(1)，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为O(n)，所以不支持快速随机访问。ArrayList 实现了 RandomAccess接口，就表明了他具有快速随机访问功能。 RandomAccess接口只是标识，并不是说 ArrayList 实现 RandomAccess接口才具有快速随机访问功能的！</p><p>最明显是ArrrayList底层的数据结构是数组，支持随机访问，而LinkedList的底层数据结构是链表，不支持随机访问。使用下标访问一个元素，ArrayList的时间复杂度是O(1)，而LinkedList是O(n)。</p><p><strong>ArrayList</strong></p><p>优点：ArrayList是实现了基于动态数组的数据结构，因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。</p><p>缺点：因为地址连续，ArrayList要移动数据，所以插入和删除操作效率比较低。</p><p><strong>LinkedList</strong></p><p>优点：LinkedList基于链表的数据结构，地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址。对于新增和删除操作，LinkedList比较占优势。LinkedList适用于要头尾操作或插入指定位置的场景。</p><p>缺点：因为LinkedList要移动指针，所以查询操作性能比较低。</p><p><strong>适用场景分析</strong></p><p>当需要对数据进行随机访问的时候，选用ArrayList。</p><p>当需要对数据进行多次增加删除修改时，采用LinkedList。</p><p>如果容量固定，并且只会添加到尾部，不会引起扩容，优先采用ArrayList。</p><p>当然，绝大数业务的场景下，使用ArrayList就够了，但需要注意避免ArrayList的扩容，以及非顺序的插入。</p><p>List---是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式，它继承Collection。</p><p>List有两个重要的实现类：ArrayList和LinkedList</p><p>ArrayList：可以看作是能够自动增长容量的数组。</p><p>ArrayList的toArray方法返回一个数组。</p><p>ArrayList的asList方法返回一个列表。</p><p>ArrayList底层的实现是Array，数组扩容实现。</p><p>LinkedList是一个双链表，在添加和删除元素时具有比ArrayList更好的性能。但在get与set方面弱于ArrayList。当然，这些对比都是指数据量很大或者操作很频繁。</p><h5 id="arraylist和vector" tabindex="-1"><a class="header-anchor" href="#arraylist和vector" aria-hidden="true">#</a> Arraylist和Vector</h5><ul><li>ArrayList 是 List 的主要实现类，底层使用 Object[]]存储，适用于频繁的查找工作，线程不安全 ；</li><li>Vector 是 List 的古老实现类，底层使用Object[] 存储，线程安全的。</li><li>Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。</li><li>ArrayList比Vector快，它因为有同步，不会过载。</li><li>ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。</li></ul><h5 id="arraylist、vector、linkedlist" tabindex="-1"><a class="header-anchor" href="#arraylist、vector、linkedlist" aria-hidden="true">#</a> ArrayList、Vector、LinkedList</h5><p>ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是的遗留容器。LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector属于遗留容器（Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这是对装饰器模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。</p><p><strong>补充</strong>：遗留容器中的Properties类和Stack类在设计上有严重的问题，Properties是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关联一个Hashtable并将其两个泛型参数设置为String类型，但是JavaAPI中的Properties直接继承了Hashtable，这很明显是对继承的滥用。这里复用代码的方式应该是Has-A关系而不是Is-A关系，另一方面容器都属于工具类，继承工具类本身就是一个错误的做法，使用工具类最好的方式是Has-A关系（关联）或Use-A关系（依赖）。同理，Stack类继承Vector也是不正确的。Sun公司的工程师们也会犯这种低级错误，让人唏嘘不已。</p><h5 id="arraylist和vector和linkedlist" tabindex="-1"><a class="header-anchor" href="#arraylist和vector和linkedlist" aria-hidden="true">#</a> ArrayList和Vector和LinkedList</h5><ul><li>ArrayList: 底层数据结构是数组，查询快，增删慢。线程不安全，效率高</li><li>Vector: 底层数据结构是数组，查询快，增删慢。线程安全，效率低</li><li>LinkedList: 底层数据结构是链表，查询慢，增删快。线程不安全，效率高</li></ul><h5 id="array和arraylist" tabindex="-1"><a class="header-anchor" href="#array和arraylist" aria-hidden="true">#</a> Array和ArrayList</h5><ul><li>Array可以包含基本类型和对象类型；ArrayList只能包含对象类型</li><li>Array大小是固定的；ArrayList大小是动态变化的</li><li>ArrayList提供了诸如addAll()、removeAll()、iterator()方法等</li><li>对于基本数据类型，集合使用自动装箱来减少代码量；但当处理固定大小的基本类型数据时，这种方式相对较慢。</li></ul><h4 id="set" tabindex="-1"><a class="header-anchor" href="#set" aria-hidden="true">#</a> Set</h4><h5 id="hashset、linkedhashset和treeset" tabindex="-1"><a class="header-anchor" href="#hashset、linkedhashset和treeset" aria-hidden="true">#</a> HashSet、LinkedHashSet和TreeSet</h5><ul><li>HashSet、LinkedHashSet和TreeSet 都是 Set 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li><li>HashSet、LinkedHashSet和TreeSet 的主要区别在于底层数据结构不同。HashSet 的底层数据结构是哈希表（基于 HashMap 实现）。LinkedHashSet 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。TreeSet 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li><li>底层数据结构不同又导致这三者的应用场景不同。HashSet 用于不需要保证元素插入和取出顺序的场景，LinkedHashSet 用于保证元素的插入和取出顺序满足 FIFO 的场景，TreeSet 用于支持对元素自定义排序规则的场景。</li></ul><h4 id="map" tabindex="-1"><a class="header-anchor" href="#map" aria-hidden="true">#</a> Map</h4><h5 id="hashmap和hashtable★★★" tabindex="-1"><a class="header-anchor" href="#hashmap和hashtable★★★" aria-hidden="true">#</a> HashMap和Hashtable★★★</h5><ol><li><strong>线程是否安全</strong>： HashMap 是非线程安全的，Hashtable是线程安全的,因为 Hashtable 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li><li><strong>效率</strong>： 因为线程安全的问题，HashMap 要比 Hashtable 效率高一点。另外，Hashtable 基本被淘汰，不要在代码中使用它；</li><li><strong>对 Null key和Null value 的支持</strong>： HashMap 可以存储 null 的 key和value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 NullPointerException。</li><li><strong>初始容量大小和每次扩充容量大小的不同</strong> ： ① 创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小（HashMap 中的tableSizeFor()方法保证，下面给出了源代码）。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li><li><strong>底层数据结构</strong>： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li></ol><p><strong>HashMap 中带有初始容量的构造函数：</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;Illegal initial capacity: &quot;</span> <span class="token operator">+</span> initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&gt;</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span>
        initialCapacity <span class="token operator">=</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token class-name">Float</span><span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;Illegal load factor: &quot;</span> <span class="token operator">+</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面这个方法保证了 HashMap 总是使用 2 的幂作为哈希表的大小。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
* Returns a power of two size for the given target capacity.
*/</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> cap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
    n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">;</span>
    n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">;</span>
    n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">8</span><span class="token punctuation">;</span>
    n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">:</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>本来不想这么写标题的，但是无奈，面试官都喜欢这么问HashMap。</p><ol><li>出生的版本不一样，Hashtable出生于Java发布的第一版本JDK1.0，HashMap出生于JDK1.2。</li><li>都实现了Map、Cloneable、Serializable（当前JDK版本1.8）。</li><li>HashMap继承的是AbstractMap，并且AbstractMap也实现了Map接口。Hashtable继承Dictionary。</li><li>Hashtable中大部分public修饰普通方法都是synchronized字段修饰的，是线程安全的，HashMap是非线程安全的。</li><li>Hashtable的key不能为null，value也不能为null，这个可以从Hashtable源码中的put方法看到，判断如果value为null就直接抛出空指针异常，在put方法中计算key的hash值之前并没有判断key为null的情况，那说明，这时候如果key为空，照样会抛出空指针异常。</li><li>HashMap的key和value都可以为null。在计算hash值的时候，有判断，如果key==null，则其hash=0；至于value是否为null，根本没有判断过。</li><li>Hashtable直接使用对象的hash值。hash值是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值。然后再使用除留余数法来获得最终的位置。然而除法运算是非常耗费时间的，效率很低。HashMap为了提高计算效率，将哈希表的大小固定为了2的幂，这样在取模预算时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多。</li><li>Hashtable、HashMap都使用了Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式。</li><li>默认情况下，初始容量不同，Hashtable的初始长度是11，之后每次扩充容量变为之前的2n+1（n为上一次的长度）。而HashMap的初始长度为16，之后每次扩充变为原来的两倍。</li></ol><p>另外在Hashtable源码注释中有这么一句话：</p><p>Hashtable is synchronized. If a thread-safe implementation is not needed, it is recommended to use HashMap in place of Hashtable . If a thread-safe highlyconcurrent implementation is desired, then it is recommended to use ConcurrentHashMap in place of Hashtable.</p><p>大致意思：Hashtable是线程安全，推荐使用HashMap代替Hashtable；如果需要线程安全高并发的话，推荐使用ConcurrentHashMap代替Hashtable。</p><p>这个回答完了，面试官可能会继续问：HashMap是线程不安全的，那么在需要线程安全的情况下还要考虑性能，有什么解决方式？</p><p>这里最好的选择就是ConcurrentHashMap了，但面试官肯定会叫你继续说一下 ConcurrentHashMap数据结构以及底层原理等。</p><p>1、两者父类不同</p><p>HashMap是继承自AbstractMap类，而Hashtable是继承自Dictionary类。不过它们都实现了同时实现了Map、Cloneable（可复制）、Serializable（可序列化）这三个接口。</p><p>2、对外提供的接口不同</p><p>Hashtable比HashMap多提供了elments()和contains()两个方法。elments()方法继承自Hashtable的父类Dictionnary。elements()方法用于返回此Hashtable中的value的枚举。</p><p>contains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致。事实上，contansValue()就只是调用了一下contains()方法。</p><p>3、对null的支持不同</p><p>Hashtable：key和value都不能为null。</p><p>HashMap：key可以为null，但是这样的key只能有一个，因为必须保证key的唯一性；可以有多个key值对应的value为null。</p><p>4、安全性不同</p><p>HashMap是线程不安全的，在多线程并发的环境下，可能会产生死锁等问题，因此需要开发人员自己处理多线程的安全问题。</p><p>Hashtable是线程安全的，它的每个方法上都有synchronized关键字，因此可直接用于多线程中。</p><p>虽然HashMap是线程不安全的，但是它的效率远远高于Hashtable，这样设计是合理的，因为大部分的使用场景都是单线程。当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap。</p><p>ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。</p><p>5、初始容量大小和每次扩充容量大小不同</p><p>6、计算hash值的方法不同</p><p>这两个类有许多不同的地方，下面列出了一部分：</p><ul><li>Hashtable是JDK1遗留下来的类，而HashMap是后来增加的。</li><li>Hashtable是同步的，比较慢，但HashMap没有同步策略，所以会更快。</li><li>Hashtable不允许有个空的key，但是HashMap允许出现一个null key。</li><li>hashMap去掉了HashTable的contains方法，但是加上了containsValue（）和containsKey（）方法；</li><li>HashMap和HashTable都实现了Map接口，主要区别在线程安全性、同步、速度；</li><li>线程是否安全： HashMap非同步线程不安全，HashTable同步线程安全。HashTable内部的方法都经过synchronized修饰；</li><li>效率: HashMap线程不安全，效率高；HashTable线程安全，效率低；</li><li>对null key和null value的支持： HashMap中，null可以作为key，这样的key只有一个，但可以有多个key对应的值为null；在HashTable中的key不能为null；</li><li>底层数据结构： JDK1.8后的HashMap在解决哈希冲突时有了较大的变化，当链表长度大于阀值时（默认是8），将链表转换为红黑树，以减少搜索时间。HashTable没有这样的机制；</li></ul><h5 id="hashmap和treemap" tabindex="-1"><a class="header-anchor" href="#hashmap和treemap" aria-hidden="true">#</a> HashMap和TreeMap</h5><p>TreeMap 和HashMap 都继承自AbstractMap ，但是需要注意的是TreeMap它还实现了NavigableMap接口和SortedMap 接口。</p><figure><img src="/assets/TreeMap-NeP55ulx.png" alt="TreeMap" tabindex="0" loading="lazy"><figcaption>TreeMap</figcaption></figure><p>实现 NavigableMap 接口让 TreeMap 有了对集合内元素的搜索的能力。</p><p>实现SortedMap接口让 TreeMap 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。示例代码如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
* <span class="token keyword">@author</span> shuang.kou
* <span class="token keyword">@createTime</span> 2020年06月15日 17:02:00
*/</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
	<span class="token keyword">private</span> <span class="token class-name">Integer</span> age<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">return</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> treeMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Person</span> person1<span class="token punctuation">,</span> <span class="token class-name">Person</span> person2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> num <span class="token operator">=</span> person1<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> person2<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        treeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;person1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        treeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;person2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        treeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">35</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;person3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        treeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;person4&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        treeMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>personStringEntry <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>personStringEntry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>person1
person4
person2
person3
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看出，TreeMap 中的元素已经是按照 Person 的 age 字段的升序来排列了。</p><p>上面，我们是通过传入匿名内部类的方式实现的，你可以将代码替换成 Lambda 表达式实现的方式：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> treeMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span>person1<span class="token punctuation">,</span> person2<span class="token punctuation">)</span>
<span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> num <span class="token operator">=</span> person1<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> person2<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>综上，相比于HashMap来说 TreeMap主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</strong></p><h5 id="concurrenthashmap和hashmap" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap和hashmap" aria-hidden="true">#</a> ConcurrentHashMap和HashMap</h5><p>1.都是key-value形式的存储数据；</p><p>2.HashMap是线程不安全的，ConcurrentHashMap是JUC下的线程安全的；</p><p>3.HashMap底层数据结构是数组+链表（JDK1.8之前）。JDK1.8之后是数组+链表+红黑树。当链表中元素个数达到8的时候，链表的查询速度不如红黑树快，链表会转为红黑树，红黑树查询速度快；</p><p>4.HashMap初始数组大小为16（默认），当出现扩容的时候，以0.75*数组大小的方式进行扩容；</p><p>5.ConcurrentHashMap在JDK1.8之前是采用分段锁来现实的Segment+HashEntry，Segment数组大小默认是16，2的n次方；JDK1.8之后，采用Node+CAS+synchronized来保证并发安全进行实现。</p><h5 id="concurrenthashmap和hashtable" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap和hashtable" aria-hidden="true">#</a> ConcurrentHashMap和Hashtable</h5><p>提到分段锁机制和后来的synchronized+CAS最好。</p><p>ConcurrentHashMap和Hashtable 主要体现在实现线程安全的方式上不同。</p><ul><li><strong>底层数据结构</strong>： JDK1.7 的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 HashMap1.8 的结构一样，数组+链表/红黑二叉树。Hashtable和JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li><li><strong>实现线程安全的方式（重要）</strong>： ① <strong>在 JDK1.7 的时候，ConcurrentHashMap（分段锁）</strong> 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized和CAS 来操作。（JDK1.6 以后 对 synchronized 锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② Hashtable(同一把锁) ：使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul><p>两者的对比图：</p><p>Hashtable:</p><figure><img src="/assets/Hashtable全表锁-uJ4-TmS4.png" alt="Hashtable全表锁" tabindex="0" loading="lazy"><figcaption>Hashtable全表锁</figcaption></figure><p>JDK1.7 的 ConcurrentHashMap：</p><figure><img src="/assets/JDK1.7的ConcurrentHashMap分段锁-pmrnCEkx.png" alt="JDK1.7的ConcurrentHashMap分段锁" tabindex="0" loading="lazy"><figcaption>JDK1.7的ConcurrentHashMap分段锁</figcaption></figure><p>JDK1.8 的 ConcurrentHashMap：</p><p>![Java8 ConcurrentHashMap 存储结构](./media/Java8 ConcurrentHashMap 存储结构.png)</p><p>JDK1.8 的 ConcurrentHashMap 不再是 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 / 红黑树</strong>。不过，Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode。当冲突链表达到一定长度时，链表会转换成红黑树。</p><h5 id="hashmap-1-7和1-8" tabindex="-1"><a class="header-anchor" href="#hashmap-1-7和1-8" aria-hidden="true">#</a> HashMap 1.7和1.8</h5><ul><li><p>1.7，在发生hash冲突的时候，数据结构只有链表；</p></li><li><p>1.8，数据结构有链表和红黑树，使用红黑树是为了能够提高查询效率。</p><blockquote><p>在链表长度达到7时(bingCount = TREEIFY_THRESHOLD - 1)，并且hashtable[]数组长度大于等于64时，将链表转换成红黑树，如果数组长度小于64，只是对数组进行扩容</p></blockquote></li></ul><h4 id="list-set-map★★" tabindex="-1"><a class="header-anchor" href="#list-set-map★★" aria-hidden="true">#</a> List，Set，Map★★</h4><p>List（对付顺序的好帮手）：List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象。</p><p>Set（注重独一无二的性质）：不允许重复的集合。不会有多个元素引用相同的对象。</p><p>Map（用Key来搜索的专家）：使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。</p><table><thead><tr><th>比较</th><th>List</th><th>Set</th><th>Map</th></tr></thead><tbody><tr><td>继承接口</td><td>Collection</td><td>Collection</td><td></td></tr><tr><td>常见实现类</td><td>AbstractList(其常用子类有ArrayList、LinkedList、Vector)</td><td>AbstractSet(其常用子类有HashSet、LinkedHashSet、TreeSet)</td><td>HashMap、HashTable、TreeMap</td></tr><tr><td>常见方法</td><td>add()、remove()、clear()、get()、contains()、size()</td><td>add()、remove()、clear()、contains()、size()</td><td>put()、get()、remove()、clear()、containsKey()、containsValue()、keySet()、values()、size()</td></tr><tr><td>元素是否可重复</td><td>可重复</td><td>不可重复(用equals判断)</td><td>不可重复</td></tr><tr><td>是否有序</td><td>有序</td><td>无序(实际上由HashCode决定)</td><td></td></tr><tr><td>线程是否安全</td><td>Vector线程安全</td><td></td><td>HashTable线程安全</td></tr></tbody></table><ul><li>List：List 接口储存一组不唯一(可以有多个元素引用引用相同的对象)，有序的对象，可插入多条null元素；</li><li>Set:不允许重复的集合，不允许有多个元素引用相同的对象，只允许有一个null元素；</li><li>Map:使用键值对存储，Map会维护与Key有关联的值，两个Key可以引用相同的对象，但Key不能重复；</li></ul><h4 id="list-set-map和queue" tabindex="-1"><a class="header-anchor" href="#list-set-map和queue" aria-hidden="true">#</a> List, Set, Map和Queue</h4><ul><li>List(对付顺序的好帮手)：存储的元素是有序的、可重复的。</li><li>Set(注重独一无二的性质)：存储的元素是无序的、不可重复的。</li><li>Map(用 key 来搜索的专家)：使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，&quot;x&quot; 代表 key，&quot;y&quot; 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li><li>Queue(实现排队功能的叫号机)：按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li></ul><h4 id="comparable和comparator" tabindex="-1"><a class="header-anchor" href="#comparable和comparator" aria-hidden="true">#</a> Comparable和Comparator</h4><p>Comparable 接口实际上是出自java.lang包 它有一个 compareTo(Object obj)方法用来排序。</p><p>Comparator接口实际上是出自 java.util 包它有一个compare(Object obj1, Object obj2)方法用来排序。</p><p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo()方法或compare()方法，当我们需要对某一个集合实现两种排序方式，比如一个 Song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo()方法和使用自制的Comparator方法或者以两个Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 Collections.sort()。</p><p>当需要对一个集合采用一种方式排序，使用Comparable接口；如果需要对一个集合采用两种排序方式就使用Comparator接口。</p><h4 id="hashmap和hashset" tabindex="-1"><a class="header-anchor" href="#hashmap和hashset" aria-hidden="true">#</a> HashMap和HashSet</h4><p>如果你看过 HashSet 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 clone()、writeObject()、readObject()是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。</p><table><thead><tr><th><strong>HashMap</strong></th><th><strong>HashSet</strong></th></tr></thead><tbody><tr><td>实现了 Map 接口</td><td>实现 Set 接口</td></tr><tr><td>存储键值对</td><td>仅存储对象</td></tr><tr><td>调用 put()向 Map 中添加元素</td><td>调用 add()方法向 Set 中添加元素</td></tr><tr><td>HashMap 使用键（Key）计算HashCode</td><td>HashSet 使用成员对象来计算 hashcode 值，对于两个对象来说 hashcode 可能相同，所以equals()方法用来判断对象的相等性</td></tr></tbody></table><h4 id="linkedhashmap和priorityqueue" tabindex="-1"><a class="header-anchor" href="#linkedhashmap和priorityqueue" aria-hidden="true">#</a> LinkedHashMap和PriorityQueue</h4><p>PriorityQueue保证最高或者最低优先级的的元素总是在队列头部，但是LinkedHashMap维持的顺序是元素插入的顺序。当遍历一个PriorityQueue时，没有任何顺序保证，但是LinkedHashMap能保证遍历顺序是元素插入的顺序。</p><h4 id="queue-与-deque" tabindex="-1"><a class="header-anchor" href="#queue-与-deque" aria-hidden="true">#</a> Queue 与 Deque</h4><p>Queue 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p><p>Queue 扩展了 Collection 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p><table><thead><tr><th>Queue 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队尾</td><td>add(E e)</td><td>offer(E e)</td></tr><tr><td>删除队首</td><td>remove()</td><td>poll()</td></tr><tr><td>查询队首元素</td><td>element()</td><td>peek()</td></tr></tbody></table><p>Deque 是双端队列，在队列的两端均可以插入或删除元素。</p><p>Deque 扩展了 Queue 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p><table><thead><tr><th>Deque 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队首</td><td>addFirst(E e)</td><td>offerFirst(E e)</td></tr><tr><td>插入队尾</td><td>addLast(E e)</td><td>offerLast(E e)</td></tr><tr><td>删除队首</td><td>removeFirst()</td><td>pollFirst()</td></tr><tr><td>删除队尾</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td>查询队首元素</td><td>getFirst()</td><td>peekFirst()</td></tr><tr><td>查询队尾元素</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table><p>事实上，Deque 还提供有 push()和pop() 等其他方法，可用于模拟栈。</p><h4 id="arraydeque-与-linkedlist" tabindex="-1"><a class="header-anchor" href="#arraydeque-与-linkedlist" aria-hidden="true">#</a> ArrayDeque 与 LinkedList</h4><p>ArrayDeque和LinkedList 都实现了 Deque 接口，两者都具有队列的功能，但两者呢？</p><ul><li>ArrayDeque 是基于可变长的数组和双指针来实现，而 LinkedList 则通过链表来实现。</li><li>ArrayDeque 不支持存储 NULL 数据，但 LinkedList 支持。</li><li>ArrayDeque 是在 JDK1.6 才被引入的，而LinkedList 早在 JDK1.2 时就已经存在。</li><li>ArrayDeque 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 LinkedList 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li></ul><p>从性能的角度上，选用 ArrayDeque 来实现队列要比 LinkedList 更好。此外，ArrayDeque 也可以用于实现栈。</p><h4 id="collection和collections" tabindex="-1"><a class="header-anchor" href="#collection和collections" aria-hidden="true">#</a> Collection和Collections</h4><ul><li>Collection是集合类的父级接口，子接口有Set、List、LinkedList、ArrayList、Vector、Stack；java.util.Collection是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li><li>Collections是集合类的一个工具类/帮助类，它包含有各种有关集合操作的静态多态方法，用于实现对各种集合的<mark>搜索</mark>binarySearch、<mark>排序</mark>sort、<mark>线程安全</mark>化synchronized等操作。此类不能实例化，就像一个工具类，服务于Java的Collection框架。</li></ul><h4 id="poll-方法和remove-方法" tabindex="-1"><a class="header-anchor" href="#poll-方法和remove-方法" aria-hidden="true">#</a> poll()方法和remove()方法</h4><p>poll()和remove()都是从队列中取出一个元素，但是poll()在获取元素失败的时候会返回空，但是remove()失败的时候会抛出异常。</p><h3 id="io" tabindex="-1"><a class="header-anchor" href="#io" aria-hidden="true">#</a> IO</h3><h4 id="bio、nio、aio" tabindex="-1"><a class="header-anchor" href="#bio、nio、aio" aria-hidden="true">#</a> BIO、NIO、AIO</h4><p>BIO(Block IO)：jkd1.4以前的IO模型，它是一种阻塞IO；</p><p>NIO（NoN-Block IO）：JDK1.4以后才有的IO模型，同步非阻塞 IO ，提高了程序的性能，借鉴比较先进的设计思想，linux多路复用技术，轮询机制；</p><p>AIO（Asynchronous IO）：JDK1.7以后才有的IO模型，相当于NIO2，相当于NIO2，异步非堵塞</p><p>BIO：Block IO同步阻塞式IO，jkd1.4以前的IO模型，就是我们平常使用的传统IO，它的特点是模式简单使用方便，并发处理能力低。</p><p>NIO：（Non-Block IO）：JDK1.4以后才有的IO模型，提高了程序的性能，借鉴比较先进的设计思想，linux多路复用技术，轮询机制，Non IO同步非阻塞IO，是传统IO的升级，客户端和服务器端通过Channel（通道）通讯，实现了多路复用。</p><p>AIO：Asynchronous IO是NIO的升级，JDK1.7以后才有的IO模型，也叫NIO2，实现了异步非堵塞IO，异步IO的操作基于事件和回调机制。</p><h4 id="io与nio" tabindex="-1"><a class="header-anchor" href="#io与nio" aria-hidden="true">#</a> IO与NIO</h4><p>NIO即New IO，这个库是在JDK1.4中才引入的。NIO和IO有相同的作用和目的，但实现方式不同，NIO<strong>主要用到的是块</strong>，所以NIO的效率要比IO高很多。在Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO。</p><p>包括类File，OutputStream，InputStream，Writer，Reader，Seralizable（5类1接口）</p><p>NIO三大核心内容selector（选择器，用于监听channel），channel（通道），buffer（缓冲区）</p><p>NIO与IO区别，IO面向流，NIO面向缓冲区；IO阻塞，NIO非阻塞。</p><h4 id="字节流与字符流" tabindex="-1"><a class="header-anchor" href="#字节流与字符流" aria-hidden="true">#</a> 字节流与字符流</h4><p>字节流（Byte）按照8位传输，以字节为单位输入输出数据。</p><p>字符流（Char）按照16位传输，以字符为单位输入输出数据。</p><h4 id="直接缓冲区与非直接缓冲器" tabindex="-1"><a class="header-anchor" href="#直接缓冲区与非直接缓冲器" aria-hidden="true">#</a> 直接缓冲区与非直接缓冲器</h4><p>非直接缓冲区：</p><p>当我们的程序想要从硬盘中读取数据需要</p><p>1.先从物理硬盘把数据读取到物理内存中</p><p>2.再将内容复制到JVM的内存中</p><p>3.然后读取应用程序才可以读取到内容</p><p>读写都是这样需要复制这一个动作当遇到大文本的文件时效率及其低下</p><p>直接缓冲区：直接在应用程序和物理磁盘中直接在内存中建立一个缓冲区在物理内存中，这样省略了复制的步骤，效率由此提高。</p><h4 id="字符流和字节流" tabindex="-1"><a class="header-anchor" href="#字符流和字节流" aria-hidden="true">#</a> 字符流和字节流</h4><p>数据的输入和输出在计算机中最终都是通过字节的形式传递的，对应通过InputStream和OutputStream实现，他们都是针对字节操作的。</p><p>而有时候通常需要读取一些完全是字符的文本数据，通常使用基于字节流的包装类字符流完成操作，他们通过InputStreamReader和OutputStreamWriter实现。</p><p>字符流是字节流的包装，即使有时候读取的是字符流，但也可能需要转换为字节写入。</p><p>字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p><h4 id="serializable与externalizable" tabindex="-1"><a class="header-anchor" href="#serializable与externalizable" aria-hidden="true">#</a> Serializable与Externalizable</h4><p>Serializable接口是一个序列化Java类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是JVM内嵌的默认序列化方式，成本高、脆弱而且不安全。Externalizable允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制。</p><h4 id="序列化和反序列化★★" tabindex="-1"><a class="header-anchor" href="#序列化和反序列化★★" aria-hidden="true">#</a> 序列化和反序列化★★</h4><p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p><p>简单来说：</p><ul><li><strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程。</li><li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程。</li></ul><p>对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。</p><p>维基百科是如是介绍序列化的：</p><p>序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。</p><p>综上：<strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p><figure><img src="/assets/序列化的主要目的-8GbhOrP4.png" alt="序列化的主要目的" tabindex="0" loading="lazy"><figcaption>序列化的主要目的</figcaption></figure><h4 id="epoll和select的区别" tabindex="-1"><a class="header-anchor" href="#epoll和select的区别" aria-hidden="true">#</a> epoll和select的区别</h4><ul><li>epoll和select都是I/O多路复用的技术，都是实现同时监听多个I/O事件的状态。</li><li>epoll相比select效率更高，主要是基于其操作系统支持的I/O事件通知机制，而select是基于轮询机制。</li><li>epoll支持水平触发和边沿触发两种模式。</li></ul><h3 id="异常" tabindex="-1"><a class="header-anchor" href="#异常" aria-hidden="true">#</a> 异常</h3><h4 id="error和exception" tabindex="-1"><a class="header-anchor" href="#error和exception" aria-hidden="true">#</a> Error和Exception</h4><p>Exception，Error有共同的父类Throwable</p><p>Error: 表示程序发生错误，是程序无法处理的，不可恢复的，如OutOfMemoryError</p><p>Exception: 表示程序可处理的异常</p><p>Error和Exception都是Java错误处理机制的一部分，都继承了Throwable类。Exception表示的异常，异常可以通过程序来捕捉，或者优化程序来避免。Error表示的是系统错误，不能通过程序来进行错误处理。</p><p>Error表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。Exception表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。</p><p>Error表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；</p><p>Exception表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。</p><p>面试题：2005年摩托罗拉的面试中曾经问过这么一个问题&quot;If a process reportsa stack overflow run-time error, what&#39;s the most possible cause？&quot;，给了四个选项 a. lack of memory; b. write on an invalid memory space; c.recursive function calling; d. array index out of boundary. Java 程序在运行时也可能会遭遇 StackOverflowError，这是一个无法恢复的错误，只能重新修改代码了，这个面试题的答案是 c。如果写了不能迅速收敛的递归，则很有可能引发栈溢出的错误，如下所示：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">StackOverflowErrorTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示</strong>：用递归编写程序时一定要牢记两点：1.递归公式；2.收敛条件（什么时候就不再继续递归）。</p><p>在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable 类有两个重要的子类:</p><ul><li><strong>Exception</strong> :程序本身可以处理的异常，可以通过 catch 来进行捕获。Exception 又可以分为 Checked Exception(受检查异常，必须处理)和Unchecked Exception(不受检查异常，可以不处理)。</li><li><strong>Error</strong> ：Error 属于程序无法处理的错误 ，我们没办法通过 catch 来进行捕获不建议通过catch捕获 。例如 Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><h4 id="受检查异常-checked-exception-和不受检查异常-unchecked-exception" tabindex="-1"><a class="header-anchor" href="#受检查异常-checked-exception-和不受检查异常-unchecked-exception" aria-hidden="true">#</a> 受检查异常(Checked Exception)和不受检查异常(Unchecked Exception)</h4><p>Checked Exception 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 catch或者throws 关键字处理的话，就没办法通过编译。</p><p>比如下面这段 IO 操作的代码：</p><figure><img src="/assets/受检查异常-YImV7IU0.png" alt="受检查异常" tabindex="0" loading="lazy"><figcaption>受检查异常</figcaption></figure><p>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于受检查异常。常见的受检查异常有：IO 相关的异常、ClassNotFoundException、SQLException...。</p><p>Unchecked Exception 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中，我们即使不处理不受检查异常也可以正常通过编译。</p><p>受检查异常编译器在编译期间检查。对于这种异常，方法强制处理或者通过throws子句声明。其中一种情况是Exception的子类但不是RuntimeException的子类。非受检查是RuntimeException的子类，在编译阶段不受编译器的检查。</p><p>Exception，又分为CheckedException（受检异常）、UncheckedException(非受检异常)，受检异常发生在编译期，必须要使用try...catch 或者 throws捕获或者抛出异常，否则编译不通过；非受检异常发生在运行期，具有不确定性，主要由程序的逻辑问题引起的，在程序设计的时候要认真考虑，尽量处理异常</p><h4 id="运行时异常和受检异常" tabindex="-1"><a class="header-anchor" href="#运行时异常和受检异常" aria-hidden="true">#</a> 运行时异常和受检异常</h4><p>异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，在Effective对异常的使用给出了以下指导原则：</p><ul><li>不要将异常处理用于正常的控制流（设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常）</li><li>对可以恢复的情况使用受检异常，对编程错误使用运行时异常</li><li>避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）</li><li>优先使用标准的异常</li><li>每个方法抛出的异常都要有文档</li><li>保持异常的原子性</li><li>不要在catch中忽略掉捕获到的异常</li></ul><h4 id="运行时异常和一般异常" tabindex="-1"><a class="header-anchor" href="#运行时异常和一般异常" aria-hidden="true">#</a> 运行时异常和一般异常</h4><p>异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。Java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。</p><h4 id="throw与thorws" tabindex="-1"><a class="header-anchor" href="#throw与thorws" aria-hidden="true">#</a> throw与thorws</h4><p>位置不同：</p><p>throws用在函数上，后面跟的是异常类，可以跟多个；而throw用在函数内，后面跟的是异常对象。</p><p>功能不同：</p><ol><li>throws用来声明异常，让调用者只知道该功能可能出现的问题，可以给出预先的处理方式；throw抛出具体的问题对象，执行到throw，功能就已经结束了，跳转到调用者，并将具体的问题对象抛给调用者。也就是说throw语句独立存在时，下面不要定义其他语句，因为执行不到。</li><li>throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常对象。</li><li>两者都是消极处理异常的方式，只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。</li></ol><p>throw用于抛出java.lang.Throwable类的一个实例化对象，意思是说你可以通过关键字throw抛出一个Error或者一个Exception，如：throw new IllegalArgumentException(&quot;size must be multiple of 2″ )。而throws的作用是作为方法声明和签名的一部分，方法被抛出相应的异常以便调用者能处理。任何未处理的受检查异常强制在throws子句中声明。</p><p>throws是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处理；</p><ul><li>throw则是指抛出的一个具体的异常类型。</li></ul><h3 id="string、stringbuffer和stringbuilder★★★" tabindex="-1"><a class="header-anchor" href="#string、stringbuffer和stringbuilder★★★" aria-hidden="true">#</a> String、StringBuffer和StringBuilder★★★</h3><ol><li>String 是<mark>不可变字符串</mark>，StringBuffer和StringBuilder 是<mark>可变字符串</mark>。如果经常改变字符串的原始数据，最好使用 StringBuilder 代替。</li><li>String 默认重写了 equals 方法和 hashCode() 方法；而 StringBuffer 没有重写 equals 方法，使用 new StringBuffer(&quot;&quot;) 会直接在堆内存中开辟空间储存对象。因此将 StringBuffer 对象储存进 Java 集合中可能会出现问题（通过 Hash 计算索引时会根据 equals 判断是否相等，这里所有的 StringBuffer 对象都是新对象，equals 判定为 false）。</li><li><mark>StringBuffer是线程安全的，效率低</mark>；<mark>StringBuilder是线程不安全的，效率高</mark>。</li></ol><p><strong>可变性</strong></p><p>String 是不可变的（后面会详细分析原因）。</p><p>StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串，不过没有使用 final和private 关键字修饰，最关键的是这个 AbstractStringBuilder 类还提供了很多修改字符串的方法比如 append 方法。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractStringBuilder</span> <span class="token keyword">implements</span> <span class="token class-name">Appendable</span><span class="token punctuation">,</span> <span class="token class-name">CharSequence</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span>  value<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">AbstractStringBuilder</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>str <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">appendNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>count <span class="token operator">+</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
        str<span class="token punctuation">.</span><span class="token function">getChars</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">,</span> value<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
        count <span class="token operator">+=</span> len<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>线程安全性</strong></p><p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p><p><strong>性能</strong></p><p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><p><strong>对于三者使用的总结：</strong></p><ol><li>操作少量的数据: 适用 String</li><li>单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder</li><li>多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer</li></ol><p>这里建议要往里面细说为什么需要保证String的不变性。</p><p>Java平台提供了两种类型的字符串：String和StringBuffer/StringBuilder，它们可以储存和操作字符串。其中：</p><p>String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。StringBuffer/StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是Java 5中引入的，它和StringBuffer的<strong>方法完全相同</strong>，区别在于它是在单线程环境下使用的，因为它的所有方面都<strong>没有被synchronized修饰</strong>，因此它的<strong>效率</strong>也比StringBuffer要<strong>高</strong>。</p><p><strong>面试题1</strong>-什么情况下用+运算符进行字符串连接比调用</p><p>StringBuffer/StringBuilder对象的append方法连接字符串性能更好？</p><p><strong>面试题2</strong>-请说出下面程序的输出。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StringEqualTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token string">&quot;Programming&quot;</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;Programming&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> s3 <span class="token operator">=</span> <span class="token string">&quot;Program&quot;</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> s4 <span class="token operator">=</span> <span class="token string">&quot;ming&quot;</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> s5 <span class="token operator">=</span> <span class="token string">&quot;Program&quot;</span> <span class="token operator">+</span> <span class="token string">&quot;ming&quot;</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> s6 <span class="token operator">=</span> s3 <span class="token operator">+</span> s4<span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s5<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s6<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s6<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s2 <span class="token operator">==</span> s2<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出：</p><p>false</p><p>true</p><p>false</p><p>true</p><p>false</p><p>补充：解答上面的面试题需要清除两点：1.String对象的intern方法会得到字符串对象在常量池中对应的版本的引用（如果常量池中有一个字符串与String对象的equals结果是true），如果常量池中没有对应的字符串，则该字符串将被添加到常量池中，然后返回常量池中字符串的引用；2.字符串的+操作其本质是创建了StringBuilder对象进行append操作，然后将拼接后的StringBuilder对象用toString方法处理成String对象，这一点可以用javap -c StringEqualTest.class命令获得class文件对应的JVM字节码指令就可以看出来。</p><p>String是只读字符串，它并不是基本数据类型，而是一个对象。从底层源码来看是一个final类型的字符数组，所引用的字符串不能被改变，一经定义，无法再增删改。每次对String的操作都会生成新的String对象。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>private final char value[];

每次+操作：隐式在堆上new了一个跟原字符串相同的StringBuilder对象，再调用append方法拼接+后面的字符。
StringBuffer和StringBuilder他们两都继承了AbstractStringBuilder抽象类，从AbstractStringBuilder抽象类中我们可以看到

/**
*The value is used for character storage.
*/
char[] value;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>他们的底层都是可变的字符数组，所以在进行频繁的字符串操作时，建议使用StringBuffer和StringBuilder来进行操作。另外<strong>StringBuffer</strong>对方法加了同步锁或者对调用的方法加了同步锁，所以是<strong>线程安全</strong>的。<strong>StringBuilder</strong>并没有对方法进行加同步锁，所以是<strong>非线程安全</strong>的。</p><h3 id="equals-和hashcode-★★★" tabindex="-1"><a class="header-anchor" href="#equals-和hashcode-★★★" aria-hidden="true">#</a> equals()和hashCode()★★★</h3><p>对于覆盖了equals方法的类中，同样也要覆盖hashCode方法。这是JDK规定的结果。</p><p>比较两个对象是否相同，hashCode比equals效率更高，所以优先会根据hashCode来比较，但如果不重写hashCode，原本两个对象可以认为是相等，但由于hashCode默认返回表示对象地址的整数，必然不相等，所以需要重写hashCode。</p><p>由于hashCode有个问题，可能两个不同的对象会有相同的hashCode，这样还需要通过equals来比较</p><p>比如HashMap中，计算key的索引位置，会用到key.hashCode，在确定是否为同一个元素时通过equals比较。</p><h4 id="hashcode" tabindex="-1"><a class="header-anchor" href="#hashcode" aria-hidden="true">#</a> hashCode()</h4><ul><li>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。</li><li>哈希码的作用是确定该对象在哈希表中的索引位置。</li><li>hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。</li></ul><h4 id="equals" tabindex="-1"><a class="header-anchor" href="#equals" aria-hidden="true">#</a> equals()</h4><p>equals() 它的作用是判断两个对象是否相等，如果对象重写了 equals() 方法，比较两个对象的内容是否相等；如果没有重写，比较两个对象的地址是否相同，价于&quot;==&quot;。同样的，equals() 定义在 JDK 的Object.java 中，这就意味着 的任何类都包含有 equals() 函数。</p><ol><li>如果我们没有在 HashMap、HashSet、HashTable 等本质是散列表的数据结构中使用到一个类，那么这个类的 hashCode()和equals() 就没有关系！这时，equals() 使用来比较该类的两个对象是否相等，而 hashCode() 根本没有任何作用。</li><li>反之，我们在散列表的数据结构中使用该类，如创建该类的 HashSet 集合。在这种情况下，该类的&quot;hashCode()和equals() &quot;是有关系的：</li></ol><ul><li>如果两个对象相等，那么它们的 hashCode() 值一定相同。这里的相等是指，通过 equals() 比较两个对象时返回 true。</li><li>如果两个对象 hashCode() 相等，它们并不一定相等。因为在散列表中，hashCode() 相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等，此时就出现所谓的哈希冲突场景。</li></ul><h3 id="和equals-★★★" tabindex="-1"><a class="header-anchor" href="#和equals-★★★" aria-hidden="true">#</a> ==和equals() ★★★</h3><p>区别是：一个是运算符，一个是方法。</p><ul><li>== 是一个比较运算符 <ul><li>对于<strong>基本类型</strong>，比较的是<strong>具体的数值</strong>（int、double...）；</li><li>对于<strong>引用类型</strong>，比较的是引用，也就是对应的<strong>内存地址</strong>；</li></ul></li><li>equals 是超类 Object 就具有的方法，因此所有的<strong>引用类型</strong>都具有这个方法，只用来比较引用数据类型。 <ul><li><strong>未重写equals</strong>方法时，equals 方法里面是用==运算符，所以<strong>默认比较对象内存地址</strong></li><li><strong>重写equals</strong>方法（例如 String，Integer 等）时，比较的也是对应的<strong>数值</strong>；</li></ul></li></ul><p>Object 类中 equals 方法源码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由此可见，equals 方法判断的本质也是 ==。当两个对象进行判断时，归根结底是判断这二者的内存地址是否相同（重写 equals方法的类对象(String, Integer...)除外）。</p><p>new 对象是在堆内存中开辟一份空间，所以其引用变量就是指向了堆内存的地址;</p><p>图示：</p><figure><img src="/assets/和equals-jxiwy-2Z.png" alt="==和equals" tabindex="0" loading="lazy"><figcaption>==和equals</figcaption></figure><p>示例：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> a <span class="token operator">=</span> <span class="token string">&quot;abcde&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> b <span class="token operator">=</span> <span class="token string">&quot;abcde&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;abcde&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token operator">==</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token operator">==</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上述所说，String 类重写了父类 Object 的 equals 方法，所以最后一个 equals 方法判断的也是属性值；</p><p>String 类中 equals 方法源码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> anObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> anObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>anObject <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> anotherString <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span>anObject<span class="token punctuation">;</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> value<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">char</span> v1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
        <span class="token keyword">char</span> v2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>v1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> v2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个建议与hashcode结合起来说，顺便还可以扩展一下Object类中有哪些函数，会显得你比较了解。</p><p>对于基本类型来说，== 比较的是值是否相等；</p><p>对于引用类型来说，== 比较的是两个引用是否指向同一个对象地址（两者在内存中存放的地址（堆内存地址）是否指向同一个地方）；</p><p>对于引用类型（包括包装类型）来说，equals 如果没有被重写，对比它们的地址是否相等；如果 equals()方法被重写（例如 String），则比较的是地址里的内容。</p><p>== 对于基本类型和引用类型的作用效果是不同的：对于基本数据类型来说，== 比较的是值。对于引用数据类型来说，== 比较的是对象的内存地址。</p><p>因为 Java 只有值传递，所以，对于 ==来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p><p>equals() 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。equals()方法存在于Object类中，而Object类是所有类的直接或间接父类，因此所有的类都有equals()方法。</p><p>Object 类 equals() 方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>equals() 方法存在两种使用情况：</p><ul><li><strong>类没有重写 equals()方法</strong>：通过equals()比较该类的两个对象时，等价于通过&quot;==&quot;比较这两个对象，使用的默认是 Object类equals()方法。</li><li><strong>类重写了 equals()方法</strong> ：一般我们都重写 equals()方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li></ul><p>举个例子（这里只是为了举例。实际上，你按照下面这种写法的话，像 IDEA 这种比较智能的 IDE 都会提示你将 == 换成 equals() ）：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;ab&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// a 为一个引用</span>
<span class="token class-name">String</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;ab&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// b为另一个引用,对象的内容一样</span>
<span class="token class-name">String</span> aa <span class="token operator">=</span> <span class="token string">&quot;ab&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 放在常量池中</span>
<span class="token class-name">String</span> bb <span class="token operator">=</span> <span class="token string">&quot;ab&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 从常量池中查找</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aa <span class="token operator">==</span> bb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// true</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// false</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// true</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">42</span> <span class="token operator">==</span> <span class="token number">42.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>String 中的 equals 方法是被重写过的，因为 Object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</p><p>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</p><p>String类equals()方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> anObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> anObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>anObject <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> anotherString <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span>anObject<span class="token punctuation">;</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> value<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">char</span> v1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
            <span class="token keyword">char</span> v2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>v1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> v2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                i<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>==：</strong></p><p>==比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。</p><p>1、比较的是操作符两端的操作数是否是同一个对象。2、两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。3、比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为true，如：int a=10与long b=10L与double c=10.0都是相同的（为true），因为他们都指向地址为10的堆。</p><p><strong>equals</strong>：</p><p>equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。</p><p><strong>总结：</strong></p><p>所有比较是否相等时，都是用equals并且在对常量相比较时，把常量写在前面，因为使用object的equals object可能为null则空指针，在阿里的代码规范中只使用equals，阿里插件默认会识别，并可以快速修改，推荐安装阿里插件来排查老代码使用&quot;==&quot;，替换成equals</p><ol><li>equals 比较两个实体值是否相同，可以被覆盖，但需要遵循几个约定： 自反性：对于任何非null的引用值x, x.equals(x)必须返回true 对称性：对于任何非null的引用值x和y，当y.equals(x)返回true时，x.equlas(y)必须返回true 传递性：对于任何非null的引用值x、y、z，如果x.equals(y)返回true，并且y.equals(x)也返回true，那么x.equals(z)也必须返回true 一致性：对于任何非null的引用值x和y，只要比较对象中的所有信息没有被修改，多次调用equals一致返回true，或者false</li><li>== 比较两个实体的引用地址是否相等，不能覆盖，如果引用地址相等，那认为两个实体为同一个实体</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token class-name">Integer</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Integer</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Integer</span> d <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Long</span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Long</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Long</span> f <span class="token operator">=</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">assert</span> a <span class="token operator">==</span> b<span class="token punctuation">;</span>
<span class="token keyword">assert</span> b <span class="token operator">!=</span> c<span class="token punctuation">;</span>
<span class="token keyword">assert</span> b <span class="token operator">!=</span> d<span class="token punctuation">;</span>
<span class="token keyword">assert</span> a <span class="token operator">==</span> d<span class="token punctuation">;</span>
<span class="token keyword">assert</span> a <span class="token operator">==</span> e<span class="token punctuation">;</span>
<span class="token keyword">assert</span> a <span class="token operator">==</span> f<span class="token punctuation">;</span>
<span class="token keyword">assert</span> b<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">assert</span> <span class="token operator">!</span>b<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>a==b和a.equals(b)</strong></p><p>如果a和b都是对象，则a==b是比较两个对象的引用，只有当a和b指向的是堆中的同一个对象才会返回true，而a.equals(b)是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String类重写equals()方法，所以可以用于两个不同对象，但是包含的字母相同的比较。</p><h3 id="面向对象和面向过程★★★" tabindex="-1"><a class="header-anchor" href="#面向对象和面向过程★★★" aria-hidden="true">#</a> 面向对象和面向过程★★★</h3><p>两者的主要区别在于解决问题的方式不同：</p><ul><li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li></ul><p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p><p><strong>面向过程</strong>：一种较早的编程思想，顾名思义就是该思想是站在过程的角度思考问题，强调的就是功能行为，功能的执行过程，即先后顺序，而每一个功能我们都使用函数（类似于方法）把这些步骤一步一步实现。使用的时候依次调用函数就可以了。</p><p>是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候一一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发。</p><p><strong>面向对象</strong>：一种基于面向过程的新编程思想，顾名思义就是该思想是站在对象的角度思考问题，我们把多个功能合理放到不同对象里，强调的是具备某些功能的对象。</p><p>具备某种功能的实体，称为对象。面向对象最小的程序单元是：类。面向对象更加符合常规的思维方式，稳定性好，可重用性强，易于开发大型软件产品，有良好的可维护性。</p><p>在软件工程上，面向对象可以使工程更加模块化，实现更低的耦合和更高的内聚。</p><p>是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为。面向对象有封装、继承、多态的特性，所以易维护、易复用、易扩展。可以设计出低耦合的系统。但是性能上来说，比面向过程要低。</p><h3 id="成员变量与局部变量★★★" tabindex="-1"><a class="header-anchor" href="#成员变量与局部变量★★★" aria-hidden="true">#</a> 成员变量与局部变量★★★</h3><ul><li><strong>语法形式</strong> ：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li><li><strong>存储方式</strong> ：从变量在内存中的存储方式来看,如果成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li><li><strong>生存时间</strong> ：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</li><li><strong>默认值</strong> ：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li></ul><h3 id="深拷贝和浅拷贝★" tabindex="-1"><a class="header-anchor" href="#深拷贝和浅拷贝★" aria-hidden="true">#</a> 深拷贝和浅拷贝★</h3><p>浅拷贝（shallowCopy）：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说<mark>拷贝对象和原对象共用同一个内部对象</mark>。只是增加了一个指针指向已存在的内存地址。被复制对象的所有变量都含有与原来的对象相同的值。而所有的对其他对象的引用仍然指向原来的对象。换言之，浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象。</p><p>深拷贝（deepCopy） ：<mark>深拷贝会完全复制整个对象，包括这个对象所包含的内部对象</mark>。被复制对象的所有变量都含有与原来的对象相同的值。而那些引用其他对象的变量将指向被复制过的新对象。而不再是原有的那些被引用的对象。换言之：深拷贝把要复制的对象所引用的对象都复制了一遍。是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。最好是结合克隆已经原型模式联系在一起哈，记得复习的时候，把这几个联系起来的。</p><p>关于深拷贝和浅拷贝区别，我这里先给结论：</p><ul><li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li><li><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li></ul><p>上面的结论没有完全理解的话也没关系，我们来看一个具体的案例！</p><p><strong>浅拷贝</strong></p><p>浅拷贝的示例代码如下，我们这里实现了 Cloneable 接口，并重写了 clone() 方法。</p><p>clone() 方法的实现很简单，直接调用的是父类 Object 的 clone() 方法。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Address</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token comment">// 省略构造函数、Getter&amp;Setter方法</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Address</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
        	<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Address</span><span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AssertionError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Address</span> address<span class="token punctuation">;</span>
    <span class="token comment">// 省略构造函数、Getter&amp;Setter方法</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Person</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> person<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AssertionError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试 ：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Person</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Address</span><span class="token punctuation">(</span><span class="token string">&quot;武汉&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span> person1Copy <span class="token operator">=</span> person1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// true</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> person1Copy<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从输出结构就可以看出， person1 的克隆对象和 person1 使用的仍然是同一个 Address 对象。</p><p><strong>深拷贝</strong></p><p>这里我们简单对 Person 类的 clone() 方法进行修改，连带着要把 Person 对象内部的 Address 对象一起复制。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token class-name">Person</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        person<span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> person<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AssertionError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试 ：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Person</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Address</span><span class="token punctuation">(</span><span class="token string">&quot;武汉&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span> person1Copy <span class="token operator">=</span> person1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// false</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> person1Copy<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从输出结构就可以看出，虽然 person1 的克隆对象和 person1 包含的 Address 对象已经是不同的了。</p><h3 id="重载-overload-和重写-override-★★★" tabindex="-1"><a class="header-anchor" href="#重载-overload-和重写-override-★★★" aria-hidden="true">#</a> 重载（Overload）和重写（Override）★★★</h3><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。</p><p><strong>面试题</strong>：华为的面试题中曾经问过这样一个问题-&quot;为什么不能根据返回类型来区分重载&quot;，快说出你的答案吧！</p><p>重载和重写都允许你用相同的名称来实现不同的功能，但是重载是编译时活动，而重写是运行时活动。你可以在同一个类中重载方法，但是只能在子类中重写方法。重写必须要有继承。</p><p><strong>重写(Override)</strong></p><p>从字面上看，重写就是重新写一遍的意思。其实就是在子类中把父类本身有的方法重新写一遍。子类继承了父类原有的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以在方法名，参数列表，返回类型(除过子类中方法的返回值是父类中方法返回值的子类时)都相同的情况下，对方法体进行修改或重写，这就是重写。但要注意子类函数的访问修饰权限不能少于父类的。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token class-name">Son</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
s<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello by father&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello by son&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>重写总结：</strong></p><ol><li>发生在父类与子类之间</li><li>方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同</li><li>访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private)</li><li>重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常</li></ol><p><strong>重载（Overload）</strong></p><p>在一个类中，同名的方法如果有不同的参数列表（<strong>参数类型不同、参数个数不同甚至是参数顺序不同</strong>）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但<strong>不能通过返回类型是否相同来判断重载</strong>。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Father</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        s<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        s<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token string">&quot;wintershii&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span> <span class="token operator">+</span> <span class="token string">&quot; &quot;</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>重载总结：</strong></p><ol><li>重载Overload是一个类中多态性的一种表现</li><li>重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序)</li><li>重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准</li></ol><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p><p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p><p><strong>重载</strong></p><p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p><p>《Java 核心技术》这本书是这样介绍重载的：</p><p>如果多个方法(比如 StringBuilder 的构造方法)有相同的名字、不同的参数，便产生了重载。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">StringBuilder</span> sb2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token string">&quot;HelloWorld&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。 如果编译器找不到匹配的参数， 就会产生编译时错误， 因为根本不存在匹配， 或者没有一个比其他的更好(这个过程被称为重载解析(overloading resolution))。</p><p>Java 允许重载任何方法， 而不只是构造器方法。</p><p>综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p><p><strong>重写</strong></p><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><ol><li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li><li>如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li><li>构造方法无法被重写</li></ol><p>综上：<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p><table><thead><tr><th><strong>区别点</strong></th><th><strong>重载方法</strong></th><th><strong>重写方法</strong></th></tr></thead><tbody><tr><td>发生范围</td><td>同一个类</td><td>子类</td></tr><tr><td>参数列表</td><td>必须修改</td><td>一定不能修改</td></tr><tr><td>返回类型</td><td>可修改</td><td>子类方法返回值类型应比父类方法返回值类型更小或相等</td></tr><tr><td>异常</td><td>可修改</td><td>子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td></tr><tr><td>访问修饰符</td><td>可修改</td><td>一定不能做更严格的限制（可以降低限制）</td></tr><tr><td>发生阶段</td><td>编译期</td><td>运行期</td></tr></tbody></table><p>**方法的重写要遵循&quot;两同两小一大&quot;（**以下内容摘录自《疯狂 Java 讲义》）：</p><ul><li>&quot;两同&quot;即方法名相同、形参列表相同；</li><li>&quot;两小&quot;指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li><li>&quot;一大&quot;指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li></ul><p>关于 <strong>重写的返回值类型</strong> 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Hero</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">return</span> <span class="token string">&quot;超级英雄&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SuperMan</span> <span class="token keyword">extends</span> <span class="token class-name">Hero</span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">return</span> <span class="token string">&quot;超人&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">Hero</span> <span class="token function">hero</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Hero</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SuperSuperMan</span> <span class="token keyword">extends</span> <span class="token class-name">SuperMan</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">return</span> <span class="token string">&quot;超级超级英雄&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">SuperMan</span> <span class="token function">hero</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SuperMan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="string-equals-和object-equals" tabindex="-1"><a class="header-anchor" href="#string-equals-和object-equals" aria-hidden="true">#</a> String##equals()和Object##equals()</h3><p>String 中的 equals 方法是被重写过的，比较的是 String <mark>字符串的值</mark>是否相等。 Object 的 equals 方法是比较的<mark>对象的内存地址</mark>。</p><h3 id="iterator和listiterator" tabindex="-1"><a class="header-anchor" href="#iterator和listiterator" aria-hidden="true">#</a> Iterator和ListIterator</h3><ul><li>Iterator可以用来遍历Set和List集合，但是ListIterator只能遍历List</li><li>Iterator对集合只能向前遍历（next()）；而ListIterator可以向前遍历（next()），也可以向后遍历（previous()）</li><li>ListIterator实现了Iterator接口</li></ul><h3 id="statement和preparedstatement" tabindex="-1"><a class="header-anchor" href="#statement和preparedstatement" aria-hidden="true">#</a> Statement和PreparedStatement</h3><p>与Statement相比</p><p>①PreparedStatement接口代表预编译的语句，它主要的优势在于可以减少SQL的编译错误并增加SQL的安全性（减少SQL注射攻击的可能性）；</p><p>②PreparedStatement中的SQL语句是可以带参数的，避免了用字符串连接拼接SQL语句的麻烦和不安全；</p><p>③当批量处理SQL或频繁执行相同的查询时，PreparedStatement有明显的性能上的优势，由于数据库可以将编译优化后的SQL语句缓存起来，下次执行相同结构的语句时就会很快（不用再次编译和生成执行计划）。</p><p><strong>补充</strong>：为了提供对存储过程的调用，JDBC API中还提供了CallableStatement接口。存储过程（Stored Procedure）是数据库中一组为了完成特定功能的SQL语句的集合，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。虽然调用存储过程会在网络开销、安全性、性能上获得很多好处，但是存在如果底层数据库发生迁移时就会有很多麻烦，因为每种数据库的存储过程在书写上存在不少的差别。</p><h3 id="before和-beforeclass" tabindex="-1"><a class="header-anchor" href="#before和-beforeclass" aria-hidden="true">#</a> @Before和@BeforeClass</h3><p>@Before</p><p>在每个测试方法之前都执行一次，方法需要声明为public</p><p>@BeforeClass</p><p>只在类中执行一次，必须声明为public static</p><h3 id="java-util-date与java-sql-date" tabindex="-1"><a class="header-anchor" href="#java-util-date与java-sql-date" aria-hidden="true">#</a> java.util.Date与java.sql.Date</h3><p>Java中Date的两个类:</p><p>java.util.Date : 通常情况下用它获取当前时间或构造时间</p><p>java.sql.Date : 是针对SQL语句使用的，它只包含日期而没有时间部分</p><p>区别：</p><p>共同点：</p><p>都有<mark>getTime</mark>方法返回毫秒数，可以直接构建</p><p>不同的点：</p><p>1、java.sql.Date是针对SQL语句使用的，它<mark>只包含日期而没有时间部</mark>分，一般在读写数据库的时候用，PreparedStament的setDate()的参数和ResultSet的getDate()方法的都是java.sql.Date</p><p>2、java.util.Date是在除了SQL语句的情况下面使用，一般是日常<mark>日期字段</mark></p><p>3、java.util.Date 是 java.sql.Date 的父类，即：继承关系：java.lang.Object -&gt; java.util.Date --&gt; java.sql.Date</p><h3 id="java和javasciprt" tabindex="-1"><a class="header-anchor" href="#java和javasciprt" aria-hidden="true">#</a> Java和JavaSciprt</h3><p>JavaScript与Java是两个公司开发的不同的两个产品。Java是原SunMicrosystems公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言。JavaScript的前身是LiveScript；而Java的前身是Oak语言。</p><p>下面对两种语言间作如下比较：</p><ul><li>基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身提供了非常丰富的内部对象供设计人员使用。</li><li>解释和编译：Java的源代码在执行之前，必须经过编译。JavaScript是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。（目前的浏览器几乎都使用了JIT（即时编译）技术来提升JavaScript的运行效率）</li><li>强类型变量和类型弱变量：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript的解释器在运行时检查推断其数据类型。</li><li>代码格式不一样。</li></ul><p><strong>补充</strong>：上面列出的四点是网上流传的所谓的标准答案。其实Java和JavaScript最重要是一个是静态语言，一个是动态语言。目前的编程语言的发展趋势是函数式语言和动态语言。在类（class）是一等公民，而JavaScript中函数（function）是一等公民，因此JavaScript支持函数式编程，可以使用Lambda函数和闭包（closure），当然Java 8也开始支持函数式编程，提供了对Lambda表达式以及函数式接口的支持。对于这类问题，在面试的时候最好还是用自己的语言回答会更加靠谱，不要背网上所谓的标准答案。</p><h3 id="java和c" tabindex="-1"><a class="header-anchor" href="#java和c" aria-hidden="true">#</a> Java和C++</h3><p>我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java和C++ 比呀！没办法！！！就算没学过 C++，也要记下来。</p><p>虽然，Java和C++ 都是面向对象的语言，都支持封装、继承和多态，但是，它们还是有挺多不相同的地方：</p><ul><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li><li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li><li>......</li></ul><h3 id="jdk、jre和jvm" tabindex="-1"><a class="header-anchor" href="#jdk、jre和jvm" aria-hidden="true">#</a> JDK、JRE和JVM</h3><ul><li>JDK：Java Development Kit 的缩写，Java 开发工具包，包含 JRE、编译器及工具。</li><li>JRE：Java Runtime Environment 的缩写，Java 运行环境，包含 JVM 及 Java 核心类库。</li><li>JVM：Java Virtual Machine 的缩写，Java 虚拟机，运行 Java 字节码的虚拟机。</li></ul><h3 id="java和c-1" tabindex="-1"><a class="header-anchor" href="#java和c-1" aria-hidden="true">#</a> Java和C++</h3><ol><li>都是面向对象语言，支持封装、继承、多态；</li><li>Java 不提供指针来直接访问内存，程序内存更安全；</li><li>Java 中的类是单继承，C++ 支持多重继承；虽然 Java 的类不支持多继承，但是接口支持多继承；</li><li>Java 有自动内存管理机制，不需要手动释放无用内存；</li><li>在 C 语⾔中，字符串或字符数组最后都会有⼀个额外的字符&#39;0&#39;来表示结束。但是，Java 语⾔中没有结束符这⼀概念。https://blog.csdn.net/sszgg2006/article/details/49148189</li></ol><h3 id="基本类型和包装类型" tabindex="-1"><a class="header-anchor" href="#基本类型和包装类型" aria-hidden="true">#</a> 基本类型和包装类型</h3><ul><li>成员变量包装类型不赋值就是 null ，而基本类型有默认值且不是 null。</li><li>包装类型可用于泛型，而基本类型不可以。</li><li>基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 static 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</li><li>相比于对象类型， 基本数据类型占用的空间非常小。</li></ul><p>为什么说是几乎所有对象实例呢？ 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</p><p>注意 ： <strong>基本数据类型存放在栈中是一个常见的误区</strong>！ 基本数据类型的成员变量如果没有被 static 修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">BasicTypeVar</span><span class="token punctuation">{</span>
	<span class="token keyword">private</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="i与i" tabindex="-1"><a class="header-anchor" href="#i与i" aria-hidden="true">#</a> ++i与i++</h3><p>i++：先赋值，后计算</p><p>++i：先计算，后赋值</p><h3 id="int和integer" tabindex="-1"><a class="header-anchor" href="#int和integer" aria-hidden="true">#</a> int和Integer</h3><p>Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。</p><p>Java为每个原始类型提供了包装类型：</p><p><strong>原始类型</strong>：boolean，char，byte，short，int，long，float，double</p><p><strong>包装类型</strong>：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Integer</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Integer</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// 将 3 自动装箱成 Integer 类型</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false 两个引用没有引用同一对象</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true a 自动拆箱成 int 类型再和 c比较</span>
<span class="token punctuation">}</span>

<span class="token comment">// 最近还遇到一个面试题，也是和自动装箱和拆箱有点关系的，代码如下所示：</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Integer</span> f1 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span> f2 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span> f3 <span class="token operator">=</span> <span class="token number">150</span><span class="token punctuation">,</span> f4 <span class="token operator">=</span> <span class="token number">150</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>f1 <span class="token operator">==</span> f2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>f3 <span class="token operator">==</span> f4<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果不明就里很容易认为两个输出要么都是true要么都是false。首先需要注意的是f1、f2、f3、f4四个变量都是Integer对象引用，所以下面的==运算比较的不是值而是引用。装箱的本质是什么呢？当我们给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf，如果看看valueOf的源代码就知道发生了什么。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Integer</span> <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>low <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>high<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>low<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">IntegerCache</span>是<span class="token class-name">Integer</span>的内部类，其代码如下所示：

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">IntegerCache</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">128</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> high<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Integer</span> cache<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span> <span class="token punctuation">{</span>
    	<span class="token comment">// high value may be configured by property</span>
    	<span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>
    	<span class="token class-name">String</span> integerCacheHighPropValue <span class="token operator">=</span> sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span><span class="token constant">VM</span><span class="token punctuation">.</span><span class="token function">getSavedProperty</span><span class="token punctuation">(</span><span class="token string">&quot;java.lang.Integer.IntegerCache.high&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token keyword">if</span> <span class="token punctuation">(</span>integerCacheHighPropValue <span class="token operator">!=</span> <span class="token operator">*</span><span class="token keyword">null</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>integerCacheHighPropValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
                i <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// Maximum array size is Integer.MAX_VALUE</span>
                h <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token operator">-</span>low<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span> <span class="token class-name">NumberFormatException</span> nfe<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// If the property cannot be parsed into an int, ignore it.</span>
            <span class="token punctuation">}</span>
    	<span class="token punctuation">}</span>
        high <span class="token operator">=</span> h<span class="token punctuation">;</span>

        cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> j <span class="token operator">=</span> low<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> cache<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
        cache<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span>
        <span class="token keyword">assert</span><span class="token operator">*</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>high <span class="token operator">&gt;=</span> <span class="token number">127</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span><span class="token operator">*</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单的说，如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以上面的面试题中f1f4的结果是false。</p><p><strong>提醒</strong>：越是貌似简单的面试题其中的玄机就越多，需要面试者有相当深厚的功力。</p><h3 id="a-a-b与a-b" tabindex="-1"><a class="header-anchor" href="#a-a-b与a-b" aria-hidden="true">#</a> a=a+b与a+=b</h3><p>+=隐式的将加操作的结果类型强制转换为持有结果的类型。如果两这个整型相加，如byte、short或者int，首先会将它们提升到int类型，然后在执行加法操作。如果加法操作的结果比a的最大值要大，则a+b会出现编译错误，但是a+=b没问题，如下：</p><p>byte a=127;</p><p>byte b=127;b=a+b;//error：cannot convert from int to byte</p><p>b+=a;//ok</p><p>（译者注：这个地方应该表述的有误，其实无论a+b的值为多少，编译器都会报错，因为a+b操作会将a、b提升为int类型，所以将int类型赋值给byte就会编译出错）</p><p>+=操作符会进行隐式自动类型转换，此处a+=b隐式的将加操作的结果类型强制转换为持有结果的类型，而a=a+b则不会自动进行类型转换。如：</p><p>byte a=127;</p><p>byte b=127;</p><p>b=a+b;//报编译错误：cannot convert from int to byte</p><p>b+=a;</p><p>以下代码是否有错，有的话怎么改？</p><p>short s1=1;</p><p>s1=s1+1;</p><p>有错误。short类型在进行运算时会自动提升为int类型。也就是说s1+1的运算结果是int类型，而s1是short类型，此时编译器会报错。</p><p>正确写法：</p><p>short s1=1;</p><p>s1+=1;</p><p>+=操作符会对右边的表达式结果强转匹配左边的数据类型，所以没错。</p><h3 id="字符型常量和字符串常量" tabindex="-1"><a class="header-anchor" href="#字符型常量和字符串常量" aria-hidden="true">#</a> 字符型常量和字符串常量</h3><ol><li><strong>形式</strong> : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。</li><li><strong>含义</strong> : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。</li><li><strong>占内存大小</strong> ： 字符常量只占 2 个字节; 字符串常量占若干个字节。</li></ol><p>(<strong>注意： char 在 Java 中占两个字节</strong>)</p><h3 id="标识符和关键字是什么" tabindex="-1"><a class="header-anchor" href="#标识符和关键字是什么" aria-hidden="true">#</a> 标识符和关键字是什么</h3><p>在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了 <strong>标识符</strong> 。简单来说， <strong>标识符就是一个名字</strong> 。</p><p>有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这些特殊的标识符就是 <strong>关键字</strong> 。简单来说，<strong>关键字是被赋予特殊含义的标识符</strong> 。比如，在我们的日常生活中，如果我们想要开一家店，则要给这个店起一个名字，起的这个&quot;名字&quot;就叫标识符。但是我们店的名字不能叫&quot;警察局&quot;，因为&quot;警察局&quot;这个名字已经被赋予了特殊的含义，而&quot;警察局&quot;就是我们日常生活中的关键字。</p><h3 id="continue、break和return" tabindex="-1"><a class="header-anchor" href="#continue、break和return" aria-hidden="true">#</a> continue、break和return</h3><p>在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：</p><p>continue ：指跳出当前的这一次循环，继续下一次循环。</p><p>break ：指跳出整个循环体，继续执行循环下面的语句。</p><p>return 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：</p><ol><li>return; ：直接使用 return 结束方法执行，用于没有返回值函数的方法</li><li>return value; ：return 一个特定值，用于有返回值函数的方法</li></ol><p>思考一下：下列语句的运行结果</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;0&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        	<span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        	flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        	<span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;4&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;xixi&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;haha&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;heihei&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>0
xixi
1
2
xixi
3
haha
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="public-private-protected-以及不写-默认" tabindex="-1"><a class="header-anchor" href="#public-private-protected-以及不写-默认" aria-hidden="true">#</a> public，private，protected，以及不写（默认）</h3><table><thead><tr><th>修饰符</th><th>当前类</th><th>同包</th><th>子类</th><th>其他包</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>default</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。外部类的修饰符只能是public或默认，类的成员（包括内部类）的修饰符可以是以上四种。</p><h3 id="和" tabindex="-1"><a class="header-anchor" href="#和" aria-hidden="true">#</a> &amp;和&amp;&amp;</h3><p>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username!=null&amp;&amp;!username.equals(&quot;&quot;)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p><p><strong>补充</strong>：如果你熟悉JavaScript，那你可能更能感受到短路运算的强大，想成为JavaScript的高手就先从玩转短路运算开始吧。</p><p>&amp;是位运算符。&amp;&amp;是布尔逻辑运算符，在进行逻辑判断时用&amp;处理的前面为false后面的内容仍需处理，用&amp;&amp;处理的前面为false不再处理后面的内容。</p><h3 id="final、finally、finalize" tabindex="-1"><a class="header-anchor" href="#final、finally、finalize" aria-hidden="true">#</a> final、finally、finalize</h3><p>final：修饰符（关键字）有三种用法：如果一个类被声明为final，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。将变量声明为final，可以保证它们在使用中不被改变，被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为final的方法也同样只能使用，不能在子类中被重写。</p><p>finally：通常放在try...catch...的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。</p><p>finalize：Object类中定义的方法，允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize()方法可以整理系统资源或者执行其他清理工作。</p><p>final是一个修饰符，可以修饰变量、方法和类。如果final修饰变量，意味着该变量的值在初始化后不能被改变。finalize方法是在对象被回收之前调用的方法，给对象自己最后一个复活的机会，但是什么时候调用finalize没有保证。finally是一个关键字，与try和catch一起用于异常的处理。finally块一定会被执行，无论在try块中是否有发生异常。</p><ul><li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。</li><li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li><li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System的gc()方法的时候，由垃圾回收器调用finalize(),回收垃圾。</li></ul><h3 id="形参与实参" tabindex="-1"><a class="header-anchor" href="#形参与实参" aria-hidden="true">#</a> 形参与实参</h3><p>实参(argument)： 全称为&quot;实际参数&quot;是在调用时传递给函数的参数.实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值，以便把这些值传送给形参。因此应预先用赋值，输入等办法使实参获得确定值。</p><p>形参(parameter)： 全称为&quot;形式参数&quot;由于它不是实际存在变量，所以又称虚拟变量。是在定义函数名和函数体的时候使用的参数，目的是用来接收调用该函数时传入的参数。在调用函数时，实参将赋值给形参。因而，必须注意实参的个数，类型应与形参一一对应，并且实参必须要有确定的值。</p><p>形参出现在函数定义中，在整个函数体内都可以使用，离开该函数则不能使用。实参出现在主调函数中，进入被调函数后，实参变量也不能使用。</p><p>形参和实参的功能是作数据传送。发生函数调用时，主调函数把实参的值传送给被调函数的形参从而实现主调函数向被调函数的数据传送。</p><p>形参变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只有在函数内部有效。函数调用结束返回主调函数后则不能再使用该形参变量。</p><p>实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值，以便把这些值传送给形参。因此应预先用赋值，输入等办法使实参获得确定值。</p><p>实参和形参在数量上，类型上，顺序上应严格一致，否则会发生&quot;类型不匹配&quot;的错误。</p><p>函数调用中发生的数据传送是单向的。即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。</p><p>当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变。</p><p>而如果函数的参数是指针类型变量，在调用该函数的过程中，传给函数的是实参的地址，在函数体内部使用的也是实参的地址，即使用的就是实参本身。所以在函数体内部可以改变实参的值。</p><h3 id="静态变量和实例变量" tabindex="-1"><a class="header-anchor" href="#静态变量和实例变量" aria-hidden="true">#</a> 静态变量和实例变量</h3><p>静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。补充：在Java开发中，上下文类和工具类中通常会有大量的静态成员。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">A</span><span class="token punctuation">.</span>i <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>
        <span class="token class-name">A</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        a<span class="token punctuation">.</span>j <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="对象的相等和引用相等" tabindex="-1"><a class="header-anchor" href="#对象的相等和引用相等" aria-hidden="true">#</a> 对象的相等和引用相等</h3><ul><li>对象的相等一般比较的是内存中存放的内容是否相等。</li><li>引用相等一般比较的是他们指向的内存地址是否相等。</li></ul><h3 id="普通类和抽象类" tabindex="-1"><a class="header-anchor" href="#普通类和抽象类" aria-hidden="true">#</a> 普通类和抽象类</h3><ul><li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li><li>抽象类不能直接实例化，普通类可以直接实例化</li></ul><h3 id="组合、聚合和关联" tabindex="-1"><a class="header-anchor" href="#组合、聚合和关联" aria-hidden="true">#</a> 组合、聚合和关联</h3><p>如果两个对象彼此有关系，就说他们是彼此相关联的。组合和聚合是面向对象中的两种形式的关联。组合是一种比聚合更强力的关联。组合中，一个对象是另一个的拥有者，而聚合则是指一个对象使用另一个对象。如果对象A是由对象B组合的，则A不存在的话，B一定不存在，但是如果A对象聚合了一个对象B，则即使A不存在了，B也可以单独存在。</p><h3 id="嵌套公共静态类与顶级类" tabindex="-1"><a class="header-anchor" href="#嵌套公共静态类与顶级类" aria-hidden="true">#</a> 嵌套公共静态类与顶级类</h3><p>类的内部可以有多个嵌套公共静态类，但是一个Java源文件只能有一个顶级公共类，并且顶级公共类的名称与源文件名称必须一致。</p><p>一个公共的顶级类的源文件名称与类名相同，而嵌套静态类没有这个要求。一个嵌套类位于顶级类内部，需要使用顶级类的名称来引用嵌套静态类，如HashMap.Entry是一个嵌套静态类，HashMap是一个顶级类，Entry是一个嵌套静态类。</p><h2 id="数据库" tabindex="-1"><a class="header-anchor" href="#数据库" aria-hidden="true">#</a> 数据库</h2><h3 id="innodb与myisam★★★" tabindex="-1"><a class="header-anchor" href="#innodb与myisam★★★" aria-hidden="true">#</a> InnoDB与MyISAM★★★</h3><table><thead><tr><th>存储引擎</th><th><strong>InnoDB</strong></th><th><strong>MyISAM</strong></th></tr></thead><tbody><tr><td><strong>存储文件</strong></td><td>.frm表定义文件 .ibd数据文件</td><td>.frm表定义文件 .myd数据文件 .myi 索引文件</td></tr><tr><td><strong>锁</strong></td><td>表锁，行锁</td><td>表锁</td></tr><tr><td><strong>事务</strong></td><td>ACID</td><td>不支持</td></tr><tr><td><strong>CRUD</strong></td><td>读写</td><td>读多</td></tr><tr><td><strong>count</strong></td><td>扫表</td><td>专门存储的地方</td></tr><tr><td><strong>索引结构</strong></td><td>B+Tree</td><td>B+Tree</td></tr></tbody></table><p><strong>MyISAM</strong>：</p><ul><li><mark>不支持事务</mark>，但是每次查询都是原子的；</li><li><mark>支持表级锁</mark>，即每次操作是对整个表加锁；</li><li>存储表的总行数；</li><li>一个MYISAM表有三个文件：索引文件、表结构文件、数据文件；采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。</li></ul><p><strong>InnoDb</strong>：</p><ul><li><mark>支持ACID的事务</mark>，支持事务的四种隔离级别；</li><li><mark>支持行级锁及外键约束</mark>：因此可以支持写并发；</li><li><strong>不存储总行数：</strong></li></ul><p>一个InnoDb引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G），受操作系统文件大小的限制；</p><ul><li>主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；<mark>最好使用自增主键</mark>，防止插入数据时，为维持B+树结构，文件的大调整。</li></ul><p>1.InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</p><p>2.InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</p><p>3.InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</p><p>4.InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</p><p>5.Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；</p><ul><li>在MySQL 5.1及之前的版本中，MyISAM是默认的存储引擎，而在MySQL 5.5版本以后，默认使用InnoDB存储引擎。</li><li>MyISAM不支持行级锁，换句话说，MyISAM会对整张表加锁，而不是针对行。同时，MyISAM不支持事务和外键。MyISAM可被压缩，存储空间较小，而且MyISAM在筛选大量数据时非常快。</li><li>InnoDB是事务型引擎，当事务异常提交时，会被回滚。同时，InnoDB支持行锁。此外，InnoDB需要更多存储空间，会在内存中建立其专用的缓冲池用于高速缓冲数据和索引。InnoDB支持自动奔溃恢复特性。</li></ul><p>建议：一般情况下，<strong>个人建议优先选择InnoDB存储引擎，并且尽量不要将InnoDB与MyISAM混合使用。</strong></p><p>MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎，可谓是风光一时。</p><p>虽然，MyISAM 的性能还行，各种特性也还不错（比如全文索引、压缩、空间函数等）。但是，MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。</p><p>MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p><p>言归正传！咱们下面还是来简单对比一下两者：</p><p><strong>1.是否支持行级锁</strong></p><p>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</p><p>也就说，MyISAM 一锁就是锁住了整张表，这在并发写的情况下是多么滴憨憨啊！这也是为什么 InnoDB 在并发写的时候，性能更牛皮了！</p><p><strong>2.是否支持事务</strong></p><p>MyISAM 不提供事务支持。</p><p>InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(commit)和回滚(rollback)事务的能力。并且，InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。</p><p>关于 MySQL 事务的详细介绍，可以看看我写的这篇文章：MySQL 事务隔离级别详解。</p><p><strong>3.是否支持外键</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗。因此，通常情况下，我们是不建议在实际生产项目中使用外键的，在业务代码中进行约束即可！</p><p>阿里的《Java 开发手册》也是明确规定禁止使用外键的。</p><figure><img src="/assets/禁止使用外键-WpENhRR2.png" alt="禁止使用外键" tabindex="0" loading="lazy"><figcaption>禁止使用外键</figcaption></figure><p>不过，在代码中进行约束的话，对程序员的能力要求更高，具体是否要采用外键还是要根据你的项目实际情况而定。</p><p>总结：一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据你的项目来决定。</p><p><strong>4.是否支持数据库异常崩溃后的安全恢复</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 redo log 。</p><p><strong>5.是否支持 MVCC</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>讲真，这个对比有点废话，毕竟 MyISAM 连行级锁都不支持。MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。</p><p><strong>6.索引实现不一样。</strong></p><p>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</p><p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。</p><p>详细区别，推荐你看看我写的这篇文章：MySQL 索引详解。</p><h3 id="b-树索引和哈希索引★★★" tabindex="-1"><a class="header-anchor" href="#b-树索引和哈希索引★★★" aria-hidden="true">#</a> B+树索引和哈希索引★★★</h3><p>因为两者数据结构上的差异导致它们的使用场景也不同，<strong>哈希索引</strong>一般多用于<strong>精确的<mark>等值查找</mark></strong>，<strong>B+索引</strong>则多用于<mark>除了精确的等值查找</mark>外的其他查找（排序、范围查找）。在大多数情况下，会选择使用B+树索引。</p><ol><li>是否支持<mark>范围查找</mark>：哈希索引不支持范围查找。</li><li><mark>模糊查询和最左前缀匹配</mark>：哈希索引不支持模糊查询及多列索引的最左前缀匹配。</li><li>是否<mark>有序</mark>：哈希索引不支持排序，因为哈希表是无序的。</li><li>是否<mark>稳定</mark>：因为哈希表中会存在<mark>哈希冲突</mark>，所以哈希索引的性能是<mark>不稳定</mark>的，而 B+ 树索引的性能是相对<mark>稳定的</mark>，每次查询都是从根节点到<mark>叶子节点</mark>。</li></ol><h3 id="乐观锁和悲观锁★★★" tabindex="-1"><a class="header-anchor" href="#乐观锁和悲观锁★★★" aria-hidden="true">#</a> 乐观锁和悲观锁★★★</h3><p><strong>乐观锁</strong>：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</p><p>乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据；悲观锁就刚好相反，觉得自己读数据库的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度；时间戳就是不加锁，通过时间戳来控制并发出现的问题。</p><p>相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。</p><p>而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（Version）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个&quot;version&quot;字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p><p>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p><p>乐观锁： 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。</p><p>乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition 机制的其实都是提供的乐观锁。</p><p>Java-&gt;CAS，MySQL-&gt;version</p><p>update t set version = version + 1 where condition and version = ##{version};</p><p><strong>悲观锁</strong>：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。</p><p>悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加锁，只有自己把数据读完了，才允许别人修改那部分数据，或者反过来说，就是自己修改某条数据的时候，不允许别人读取该数据，只有等自己的整个事务提交了，才释放自己加上的锁，才允许其他用户访问那部分数据。</p><p>说的是数据库被外界（包括本系统当前的其他事物以及来自外部系统的事务处理）修改保持着保守态度，因此在整个数据修改过程中，将数据处于锁状态。悲观的实现往往是依靠数据库提供的锁机制，也只有数据库层面提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统汇总实现了加锁机制，也是没有办法保证系统不会修改数据。</p><p>在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据。</p><p>悲观锁：顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。</p><p>传统的关系型数据库里边就用到了很多这种锁机制，比如<mark>行锁，表锁</mark>等，<mark>读锁，写锁</mark>等，都是在做操作之前先上锁。</p><p>Java-&gt;synchronized，MySQL-&gt;for update</p><p>select * from t <mark>for update</mark>;</p><p><strong>两种锁各有优缺点</strong>，不可认为一种好于另一种，像<mark>乐观锁</mark>适用于<mark>写比较少</mark>的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行 retry，这样反倒是降低了性能，所以这种情况下用悲观锁（适用于<mark>写比较多</mark>）就比较合适。</p><h3 id="表级锁、行级锁和页面锁★★★" tabindex="-1"><a class="header-anchor" href="#表级锁、行级锁和页面锁★★★" aria-hidden="true">#</a> 表级锁、行级锁和页面锁★★★</h3><hr><p>MySQL锁类别 <strong>表级锁</strong> <strong>行级锁</strong> <strong>页面锁</strong></p><table><thead><tr><th>MySQL锁类别</th><th><strong>表级锁</strong></th><th><strong>行级锁</strong></th><th><strong>页面锁</strong></th></tr></thead><tbody><tr><td><strong>锁的粒度</strong></td><td>大</td><td>小</td><td>一般</td></tr><tr><td><strong>并发度</strong></td><td>低</td><td>高</td><td>一般</td></tr><tr><td><strong>资源开销</strong></td><td>小</td><td>大</td><td>一般</td></tr><tr><td><strong>加锁速度</strong></td><td>快</td><td>慢</td><td>一般</td></tr><tr><td><strong>是否会出现死锁</strong></td><td>不会</td><td>会</td><td>会</td></tr></tbody></table><ol><li>表级锁：锁定粒度大，发生锁冲突的概率最高，并发度最低；开销小，加锁快；不会出现死锁（因为会一次性获得SQL所需的全部锁）。</li><li>行级锁：锁定粒度最小，发生锁冲突的概率最低，并发度也最高；开销大，加锁慢；会出现死锁。</li><li>页面锁：锁定粒度界于表锁和行锁之间，并发度一般；开销和加锁时间界于表锁和行锁之间；会出现死锁。</li></ol><p>MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。</p><p>InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，<mark>默认为行级锁</mark>。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说，InnoDB 的性能更高。</p><p><strong>表级锁和行级锁对比</strong> ：</p><ul><li><p><strong>表级锁：</strong> MySQL 中锁定粒度最大的一种锁，是针对非索引字段加的锁，对当前操作的整张表加锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低。但是实现简单，资源消耗也比较少，加锁快，不会出现死锁。MyISAM 和 InnoDB 引擎都支持表级锁。</p></li><li><p><strong>行级锁：</strong> MySQL 中锁定粒度最小的一种锁，是针对索引字段加的锁，只针对当前操作的记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</p><p><strong>表锁和行锁应用场景：</strong></p></li><li><p>表级锁使用于并发性不高，以查询为主，少量更新的应用，比如小型的web 应用；</p></li><li><p>而行级锁适用于高并发环境下，对事务完整性要求较高的系统，如在线事务处理系统。</p></li></ul><h3 id="共享锁和排他锁" tabindex="-1"><a class="header-anchor" href="#共享锁和排他锁" aria-hidden="true">#</a> 共享锁和排他锁</h3><p>不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：</p><ul><li><strong>共享锁（S 锁）</strong>：又称<mark>读锁</mark>，事务在读取记录的时候<mark>获取共享锁</mark>，允许多个事务同时获取（锁兼容）。共享锁指的就是对于多个不同的事务，对同一个资源共享同一个锁。相当于对于同一扇门，它拥有多个钥匙一样。就像这样，你家有一个大门，大门的钥匙有好几把，你有一把，你女朋友有一把，你们都可能通过这把钥匙进入你们家，这个就是所谓的共享锁。</li><li><strong>排他锁（X 锁）</strong>：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。</li></ul><p>排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。</p><table><thead><tr><th></th><th><strong>S 锁</strong></th><th><strong>X 锁</strong></th></tr></thead><tbody><tr><td>S 锁</td><td>不冲突</td><td>冲突</td></tr><tr><td>X 锁</td><td>冲突</td><td>冲突</td></tr></tbody></table><p>由于 MVCC 的存在，对于一般的 SELECT 语句，InnoDB 不会加任何锁。不过， 你可以通过以下语句显式加共享锁或排他锁。</p><p><strong>共享锁</strong></p><p>SELECT ... <mark>LOCK IN SHARE MODE</mark>;</p><p><strong>排他锁</strong></p><p>SELECT ... <mark>FOR UPDATE</mark>;</p><h3 id="乐观锁和悲观锁" tabindex="-1"><a class="header-anchor" href="#乐观锁和悲观锁" aria-hidden="true">#</a> 乐观锁和悲观锁</h3><p>1、<strong>乐观锁</strong>：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，<mark>乐观锁认为竞争不总是会发生</mark>，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</p><p>2、<strong>悲观锁</strong>：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，<mark>悲观锁认为竞争总是会发生</mark>，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。</p><p>两者原本是数据库中的概念，但Java锁中也有类似的思想。</p><p>乐观锁：认为数据在一般情况下不会造成冲突，在访问记录前不会加排他锁，而是在进行数据提交更新时，才会对数据冲突与否进行检测。</p><p>悲观锁：认为数据很容易被其他线程修改，在处理数据前就加锁，并在整个数据处理过程中数据都处于锁定状态。</p><h3 id="公平锁和非公平锁" tabindex="-1"><a class="header-anchor" href="#公平锁和非公平锁" aria-hidden="true">#</a> 公平锁和非公平锁</h3><p><strong>公平锁</strong>：根据线程<mark>请求锁的顺序</mark>来<mark>获取锁。就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照 FIFO 的规则从队列中取到自己。</mark></p><p><mark>公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU 唤醒阻塞线程的开销比非公平锁大。</mark></p><p><mark>**非公平锁：**抢占式获取锁。上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式。</mark></p><p><mark>非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU 不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</mark></p><h3 id="myisam-static和myisam-dynamic" tabindex="-1"><a class="header-anchor" href="#myisam-static和myisam-dynamic" aria-hidden="true">#</a> MyISAM Static和MyISAM Dynamic</h3><p>在MyISAM Static上的所有字段有固定宽度。动态MyISAM表将具有像TEXT，BLOB等字段，以适应不同长度的数据类型。</p><p>MyISAM Static在受损情况下更容易恢复。</p><p>MySQL 核心在于存储引擎，想要深入学习 MySQL，必定要深入研究 MySQL 存储引擎。</p><h3 id="binlog录入格式statement-row和mixed" tabindex="-1"><a class="header-anchor" href="#binlog录入格式statement-row和mixed" aria-hidden="true">#</a> binlog录入格式statement，row和mixed</h3><p>有三种格式：statement，row和mixed。</p><ul><li>statement模式下：记录单元为语句，即每一个sql造成的影响会记录。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</li><li>row级别下：记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作,会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多,日志量太大。</li><li>mixed：一种折中的方案,普通操作使用statement记录，当无法使用statement的时候使用row。</li><li>此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。</li></ul><h3 id="外连接、内连接与自连接" tabindex="-1"><a class="header-anchor" href="#外连接、内连接与自连接" aria-hidden="true">#</a> 外连接、内连接与自连接</h3><p>先说什么是交叉连接：交叉连接又叫笛卡尔积，它是指不使用任何条件，直接将一个表的所有记录和另一个表中的所有记录一一匹配。</p><p>内连接则是只有条件的交叉连接，根据某个条件筛选出符合条件的记录，不符合条件的记录不会出现在结果集中，即内连接只连接匹配的行。</p><p>外连接其结果集中不仅包含符合连接条件的行，而且还会包括左表、右表或两个表中的所有数据行，这三种情况依次称之为左外连接，右外连接，和全外连接。</p><p>左外连接，也称左连接，左表为主表，左表中的所有记录都会出现在结果集中，对于那些在右表中并没有匹配的记录，仍然要显示，右边对应的那些字段值以NULL来填充。右外连接，也称右连接，右表为主表，右表中的所有记录都会出现在结果集中。左连接和右连接可以互换，MySQL目前还不支持全外连接。</p><h3 id="内连接、左连接、右连接" tabindex="-1"><a class="header-anchor" href="#内连接、左连接、右连接" aria-hidden="true">#</a> 内连接、左连接、右连接</h3><p>内连接（inner join）：把匹配的关联数据显示。匹配2张表中相关联的记录。</p><p>左连接（left join）：把左边的表全显示，右边的表显示出符合条件的数据。除了匹配2张表中相关联的记录外，还会匹配左表中剩余的记录，右表中未匹配到的字段用NULL表示。</p><p>右连接（right join）：与左连接相反。除了匹配2张表中相关联的记录外，还会匹配右表中剩余的记录，左表中未匹配到的字段用NULL表示。在判定左表和右表时，要根据表名出现在outer join的左右位置关系。</p><p>内连接关键字：inner join；左连接：left join；右连接：right join。</p><p>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p><h3 id="drop、delete与truncate的区别" tabindex="-1"><a class="header-anchor" href="#drop、delete与truncate的区别" aria-hidden="true">#</a> drop、delete与truncate的区别</h3><p>SQL中的drop、delete、truncate都表示删除，但是三者有一些差别，delete和truncate只删除表的数据不删除表的结构速度，一般来说：drop&gt;truncate&gt;delete，delete语句是dml，这个操作会放到rollback segement中，事务提交之后才生效;</p><p>如果有相应的trigger，执行的时候将被触发。truncate，drop是ddl，操作立即生效，原数据不放到rollbacksegment中，不能回滚。操作不触发trigger。</p><p><strong>用法不同</strong></p><ol start="3"><li>drop(丢弃数据): drop table 表名 ，直接将表都删除掉，在删除表的时候使用。</li><li>truncate (清空数据) : truncate table 表名 ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。</li><li>delete（删除数据） : delete from 表名 where 列名=值，删除某一行的数据，如果不加 where 子句和truncate table 表名作用类似。</li></ol><p>truncate 和不带 where 子句的 delete、以及 drop 都会删除表内的数据，但是 <strong>truncate 和 delete 只删除数据不删除表的结构(定义)，执行 drop 语句，此表的结构也会删除，也就是执行 drop 之后对应的表不复存在。</strong></p><p><strong>属于不同的数据库语言</strong></p><p>truncate 和 drop 属于 DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。而 delete 语句是 DML (数据库操作语言)语句，这个操作会放到 rollback segement 中，事务提交之后才生效。</p><p><strong>执行速度不同</strong></p><p>一般来说：drop &gt; truncate &gt; delete。</p><ul><li>delete命令执行的时候会产生数据库的binlog日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。</li><li>truncate命令执行的时候不会产生数据库日志，因此比delete要快。除此之外，还会把表的自增值重置和索引恢复到初始大小等。</li><li>drop命令会把表占用的空间全部释放掉。</li><li>Tips：你应该更多地关注在使用场景上，而不是执行效率。</li></ul><p><strong>DML和DDL</strong></p><ul><li>DDL （Data Definition Language）是<mark>数据定义语言</mark>的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。</li><li>DML 是<mark>数据操作语言</mark>（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入（insert）、更新（update）、删除（delete）和查询（select），是开发人员日常使用最频繁的操作。由于select不会对表进行破坏，所以有的地方也会把select单独区分开叫做数据库查询语言DQL（Data Query Language）</li></ul><h3 id="char-和-varchar" tabindex="-1"><a class="header-anchor" href="#char-和-varchar" aria-hidden="true">#</a> char 和 varchar</h3><p>char(n) ：固定长度类型，比如订阅 char(10)，当你输入&quot;abc&quot;三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。</p><p>chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。</p><p>varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。</p><p>所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</p><h3 id="float-和-double" tabindex="-1"><a class="header-anchor" href="#float-和-double" aria-hidden="true">#</a> float 和 double</h3><p>float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。</p><p>double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。</p><h3 id="blob和text" tabindex="-1"><a class="header-anchor" href="#blob和text" aria-hidden="true">#</a> BLOB和TEXT</h3><p>BLOB是一个二进制对象，可以容纳可变数量的数据。TEXT是一个不区分大小写的BLOB。</p><p>BLOB和TEXT类型之间的唯一区别在于对BLOB值进行排序和比较时区分大小写，对TEXT值不区分大小写。</p><h3 id="now-和current-date" tabindex="-1"><a class="header-anchor" href="#now-和current-date" aria-hidden="true">#</a> NOW()和CURRENT_DATE()</h3><p>NOW()命令用于显示当前年份，月份，日期，小时，分钟和秒。CURRENT_DATE()仅显示当前年份，月份和日期。</p><h3 id="主键和候选键" tabindex="-1"><a class="header-anchor" href="#主键和候选键" aria-hidden="true">#</a> 主键和候选键</h3><p>表格的每一行都由主键唯一标识，一个表只有一个主键。主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。</p><h3 id="主键和外键" tabindex="-1"><a class="header-anchor" href="#主键和外键" aria-hidden="true">#</a> 主键和外键</h3><ul><li><strong>主键(主码)</strong> ：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。</li><li><strong>外键(外码)</strong> ：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</li></ul><h3 id="主键、外键和索引" tabindex="-1"><a class="header-anchor" href="#主键、外键和索引" aria-hidden="true">#</a> 主键、外键和索引</h3><p>定义：</p><p>主键：唯一标识一条记录，不能有重复的，不允许为空</p><p>外键：表的外键是另一表的主键，外键可以有重复的，可以是空值索引------该字段没有重复值，但可以有一个空值</p><p><strong>作用：</strong></p><p>主键：用来保证数据完整性</p><p>外键：用来和其他表建立联系用的索引，可以提高查询排序的速度</p><p><strong>个数：</strong></p><p>主键：主键只能有一个</p><p>外键：一个表可以有多个外键</p><p>索引：一个表可以有多个唯一索引</p><h3 id="主键与唯一索引" tabindex="-1"><a class="header-anchor" href="#主键与唯一索引" aria-hidden="true">#</a> 主键与唯一索引</h3><ul><li>主键一定会创建一个唯一索引，但是有唯一索引的列不一定是主键；</li><li>主键不允许为空值，唯一索引列允许空值；</li><li>一个表只能有一个主键，但是可以有多个唯一索引；</li><li>主键可以被其他表引用为外键，唯一索引列不可以；</li><li>主键是一种约束，而唯一索引是一种索引，是表的冗余数据结构，两者有本质的区别。</li></ul><h3 id="索引-主键-唯一索引-联合索引" tabindex="-1"><a class="header-anchor" href="#索引-主键-唯一索引-联合索引" aria-hidden="true">#</a> 索引，主键，唯一索引，联合索引</h3><p>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</p><p>普通索引(由关键字KEY或INDEX定义的索引)的唯一任务是加快对数据的访问速度。</p><p>普通索引允许被索引的数据列包含重复的值。如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。也就是说，唯一索引可以保证数据记录的唯一性。</p><p>主键，是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字PRIMARY KEY来创建。</p><p>索引可以覆盖多个数据列，如像INDEX(columnA,columnB)索引，这就是联合索引。</p><p>索引可以极大的提高数据的查询速度，但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件。</p><h3 id="mysql-fetch-array和mysql-fetch-object" tabindex="-1"><a class="header-anchor" href="#mysql-fetch-array和mysql-fetch-object" aria-hidden="true">#</a> MySQL_fetch_array和MySQL_fetch_object</h3><p>以下是MySQL_fetch_array和MySQL_fetch_object的区别：</p><p>MySQL_fetch_array()：将结果行作为关联数组或来自数据库的常规数组返回。</p><p>MySQL_fetch_object：从数据库返回结果行作为对象。</p><h2 id="计算机网络" tabindex="-1"><a class="header-anchor" href="#计算机网络" aria-hidden="true">#</a> 计算机网络</h2><h3 id="tcp与udp★★★" tabindex="-1"><a class="header-anchor" href="#tcp与udp★★★" aria-hidden="true">#</a> TCP与UDP★★★</h3><table><thead><tr><th></th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td><strong>是否面向连接</strong></td><td>面向连接</td><td>无连接</td></tr><tr><td><strong>可靠性</strong></td><td>可靠</td><td>不可靠</td></tr><tr><td><strong>传输形式</strong></td><td>字节流</td><td>数据报文段</td></tr><tr><td><strong>传输效率</strong></td><td>慢</td><td>快</td></tr><tr><td><strong>消耗资源</strong></td><td>多</td><td>少</td></tr><tr><td><strong>应用场景</strong></td><td>文件/邮件传输</td><td>视频/语音传输</td></tr><tr><td><strong>首部字节</strong></td><td>20~60</td><td>8</td></tr></tbody></table><p>1、**TCP面向连接，UDP无连接。**TCP是面向连接的运输层协议（如打电话要先拨号建立连接）；UDP是无连接的，即发送数据之前不需要建立连接。</p><p>2、**TCP可靠，UDP不保证可靠。**TCP提供可靠的交付服务，提供全双工通信。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达，TCP通过校验和、重传控制、序号标识、滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制；UDP尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制，UDP是面向报文的，适合多媒体通信要求。</p><p>3、<strong>UDP具有较好的实时性，工作效率比TCP高</strong>，适用于对高速传输和实时性有较高的通信或广播通信。</p><p>4、**TCP点对点，UDP连接方式多。**每一条TCP连接只能是点到点的，只能一对一连接；UDP支持一对一，一对多，多对一和多对多的交互通信。</p><p>5、**TCP需要资源多，UDP需要资源少。**TCP 面向字节流，头部最低20个字节，对系统资源要求较多；UDP首部开销小，只有8个字节，对系统资源要求较少。</p><h3 id="http和https★★★" tabindex="-1"><a class="header-anchor" href="#http和https★★★" aria-hidden="true">#</a> HTTP和HTTPS★★★</h3><table><thead><tr><th></th><th>HTTP</th><th>HTTPS</th></tr></thead><tbody><tr><td><strong>端口</strong></td><td>HTTP和HTTPS的连接方式不同，使用的端口也不一样，HTTP是80</td><td>HTTPS用的是443</td></tr><tr><td><strong>安全性</strong></td><td>无加密，安全性较差</td><td>有加密机制，安全性较高</td></tr><tr><td><strong>资源消耗</strong></td><td>较少</td><td>由于加密处理，资源消耗更多。和HTTP相比，HTTPS通信会因为加解密的处理消耗更多的CPU和内存资源。</td></tr><tr><td><strong>是否需要证书，即开销</strong></td><td>不需要</td><td>需要，HTTPS通信需要证书，这类证书通常需要向认证机构申请或者付费购买。</td></tr><tr><td><strong>协议</strong></td><td>运行在TCP协议之上</td><td>运行在SSL协议之上，SSL运行在TCP协议之上</td></tr></tbody></table><h3 id="http1-0、http1-1和http2-0" tabindex="-1"><a class="header-anchor" href="#http1-0、http1-1和http2-0" aria-hidden="true">#</a> HTTP1.0、HTTP1.1和HTTP2.0</h3><ol><li>对比</li></ol><table><thead><tr><th>HTTP1.0</th><th>无状态、无连接</th></tr></thead><tbody><tr><td>HTTP1.1</td><td>持久连接请求管道化增加缓存处理(新的字段如Cache-control)增加Host字段、支持断点传输等(把文件分成几部分)</td></tr><tr><td>HTTP2.0</td><td>二进制分帧多路复用(或连接共享)头部压编服务器推送</td></tr></tbody></table><p><strong>二、HTTP1.0：</strong></p><p>浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。</p><p><strong>三、HTTP1.1：</strong></p><p>HTTP/1.0中默认使用Connection：close。在HTTP/1.1中已经默认使用Connection：keep-alive，避免了连接建立和释放的开销，但服务器必须按照客户端请求的先后顺序依次回送相应的结果，以保证客户端能够区分出每次请求的响应内容。通过Content-Length字段来判断当前请求的数据是否已经全部接收。不允许同时存在两个并行的响应。</p><p><strong>四、HTTP2.0：</strong></p><p>HTTP/2引入二进制数据帧和流的概念，其中帧对数据进行顺序标识，如下图所示，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以并行的传输数据，这就是流所做的事情。流（stream）已建立连接上的双向字节流消息与逻辑消息对应的完整的一系列数据帧，帧是HTTP2.0通信的最小单位，每个帧包含帧头部，至少也会标识出当前帧所属的流（stream id）。</p><p><strong>多路复用：</strong></p><p>1、所有的HTTP2.0通信都在一个TCP连接上完成，这个连接可以承载任意数量的双向数据流。</p><p>2、每个数据流以消息的形式发送，而消息由一或多个帧组成。这些帧可以乱序发送，然后再根据每个帧头部的流标识符（stream id）重新组装。</p><p>举个例子，每个请求是一个数据流，数据流以消息的方式发送，而消息又分为多个帧，帧头部记录着stream id用来标识所属的数据流，不同属的帧可以在连接中随机混杂在一起。接收方可以根据stream id将帧再归属到各自不同的请求当中去。</p><p>3、另外，多路复用（连接共享）可能会导致关键请求被阻塞。HTTP2.0里每个数据流都可以设置优先级和依赖，优先级高的数据流会被服务器优先处理和返回给客户端，数据流还可以依赖其他的子数据流。</p><p>4、可见，HTTP2.0实现了真正的并行传输，它能够在一个TCP上进行任意数量HTTP请求。而这个强大的功能则是基于&quot;二进制分帧&quot;的特性。</p><p><strong>头部压缩</strong></p><p>在HTTP1.x中，头部元数据都是以纯文本的形式发送的，通常会给每个请求增加500~800字节的负荷。</p><p>HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。高效的压缩算法可以很大的压缩header，减少发送包的数量从而降低延迟。</p><p>服务器推送：</p><p>服务器除了对最初请求的响应外，服务器还可以额外的向客户端推送资源，而无需客户端明确的请求。</p><h3 id="http的长连接与短连接" tabindex="-1"><a class="header-anchor" href="#http的长连接与短连接" aria-hidden="true">#</a> HTTP的长连接与短连接</h3><p>HTTP协议有HTTP/1.0版本和HTTP/1.1版本。</p><p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p><p><strong>短连接</strong></p><p>在HTTP/1.0中默认使用短链接，也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端访问的某个HTML或其他类型的Web资源，如JavaScript文件、图像文件、CSS文件等。当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。</p><p><strong>长连接</strong></p><p>从HTTP/1.1起，默认使用长连接（HTTP persistent connection，也翻译为持久连接），用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p><p>Connection:keep-alive</p><p>在使用长连接的情况下，数据传输完成了保持TCP连接不断开（不发RST包、不四次握手），等待在同域名下继续用这个通道传输数据，例如：当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭。如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p><h3 id="get和post★★★" tabindex="-1"><a class="header-anchor" href="#get和post★★★" aria-hidden="true">#</a> GET和POST★★★</h3><h4 id="用途" tabindex="-1"><a class="header-anchor" href="#用途" aria-hidden="true">#</a> 用途</h4><ul><li>GET请求用来从服务器<strong>获取资源</strong>，因此，GET在浏览器回退是无害的。</li><li>POST请求用来向服务器<strong>提交数据</strong>，因此，POST在浏览器回退会再次提交请求。</li></ul><h4 id="表单的提交方式、安全性、参数位置" tabindex="-1"><a class="header-anchor" href="#表单的提交方式、安全性、参数位置" aria-hidden="true">#</a> 表单的提交方式、安全性、参数位置</h4><ul><li>GET请求直接将表单数据以name1=value1&amp;name2=value2的形式拼接到URL上（http://www.baidu.com/action?name1=value1&amp;name2=value2），多个参数参数值需要用&amp;连接起来并且用?拼接到action后面；因此，GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li><li>POST将数据放在request body中。POST请求将表单数据放到请求头或者请求的消息体中。</li></ul><h4 id="传输数据的大小限制" tabindex="-1"><a class="header-anchor" href="#传输数据的大小限制" aria-hidden="true">#</a> 传输数据的大小限制</h4><ul><li>GET请求传输的数据受到URL长度的限制，即传送参数是有大小限制的，不能大于2KB，而URL长度是由浏览器决定的；</li><li>POST请求传输数据的大小理论上来说是没有限制的。</li></ul><h4 id="参数的编码" tabindex="-1"><a class="header-anchor" href="#参数的编码" aria-hidden="true">#</a> 参数的编码</h4><ul><li>GET请求的参数会在地址栏明文显示，只能进行URL编码，使用URL编码的文本格式传递参数；</li><li>POST请求支持多种编码，POST请求使用二进制数据多重编码传递参数。</li></ul><h4 id="参数的数据类型" tabindex="-1"><a class="header-anchor" href="#参数的数据类型" aria-hidden="true">#</a> 参数的数据类型</h4><ul><li>GET只接受ASCII字符；</li><li>POST没有限制。</li></ul><h4 id="缓存" tabindex="-1"><a class="header-anchor" href="#缓存" aria-hidden="true">#</a> 缓存</h4><ul><li>GET请求会被浏览器主动缓存，GET请求可以被收藏为标签；</li><li>而POST不会被浏览器主动缓存，除非手动设置。POST请求也不能被收藏为标签。</li></ul><h4 id="历史记录" tabindex="-1"><a class="header-anchor" href="#历史记录" aria-hidden="true">#</a> 历史记录</h4><ul><li>GET请求参数会被完整保留在浏览器历史记录中；</li><li>POST中的参数不会被保留在浏览器历史记录中。</li></ul><h4 id="幂等性" tabindex="-1"><a class="header-anchor" href="#幂等性" aria-hidden="true">#</a> 幂等性</h4><ul><li>GET方法是具有幂等性的，而POST方法不具有幂等性。这里幂等性指客户端连续发出多次请求收到的结果都是一样的。</li></ul><h3 id="uri和url的区别" tabindex="-1"><a class="header-anchor" href="#uri和url的区别" aria-hidden="true">#</a> URI和URL的区别</h3><p>URI(Uniform Resource ldentifier)：中文全称为统一资源标志符，主要作用是唯一标识一个资源。</p><p>URL(Uniform Resource Location): 中文全称为统一资源定位符，主要作用是提供资源的路径。</p><p>有个经典的比喻是URI像是身份证，可以唯一标识一个人，而URL更像一个住址，可以通过URL找到这个人。</p><h3 id="time-wait和close-wait的区别在哪" tabindex="-1"><a class="header-anchor" href="#time-wait和close-wait的区别在哪" aria-hidden="true">#</a> TIME WAIT和CLOSE WAIT的区别在哪?</h3><p>默认客户端首先发起断开连接请求</p><ul><li>从上图可以看出，CLOSE_WAIT是被动关闭形成的，当客户端发送FIN报文，服务端返回ACK报文后进入CLOSE_WAIT。</li><li>TIME WAIT是主动关闭形成的，当第四次挥手完成后，客户端进入TIME_WAIT状态。</li></ul><h3 id="http响应吗301和302" tabindex="-1"><a class="header-anchor" href="#http响应吗301和302" aria-hidden="true">#</a> http响应吗301和302</h3><p>301、302都是HTTP状态的编码，都代表着某个URL发生了转移；</p><p>区别：</p><p>301 redirect：301代表永久性转移（Permanently Moved）；</p><p>302 redirect：302代表暂时性转移（Temporarily Moved）；</p><h3 id="forward和redirect★★★" tabindex="-1"><a class="header-anchor" href="#forward和redirect★★★" aria-hidden="true">#</a> Forward和Redirect★★★</h3><p>本质区别：转发是服务器行为，重定向是客户端行为。</p><p>请求转发特点：一次强求，浏览器地址不变，访问的是自己本身的web资源，传输的数据不会丢失。</p><p>重定向特点：两次请求，浏览器地址发生变化，可以访问自己web之外的资源，传输的数据会丢失。</p><p>Forward和Redirect代表了两种请求转发方式：直接转发和间接转发。</p><p>直接转发方式（Forward），客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。</p><p>间接转发方式（Redirect）实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。</p><p>举个通俗的例子：</p><p>直接转发就相当于：&quot;A找B借钱，B说没有，B去找C借，借到借不到都会把消息传递给A&quot;；</p><p>间接转发就相当于：&quot;A找B借钱，B说没有，让A去找C借&quot;。</p><ul><li><strong>浏览器URL地址</strong>：Forward是服务器内部的重定向，服务器内部请求某个servlet，然后获取响应的内容，浏览器的URL地址是不会变化的；Redirect是客户端请求服务器，然后服务器给客户端返回了一个302状态码和新的location，客户端重新发起HTTP请求，服务器给客户端响应location对应的URL地址，浏览器的URL地址发生了变化。</li><li><strong>数据的共享</strong>：Forward是服务器内部的重定向，request在整个重定向过程中是不变的，request中的信息在servlet间是共享的。Redirect发起了两次HTTP请求分别使用不同的request。</li><li><strong>请求的次数</strong>：Forward只有一次请求；Redirect有两次请求。</li></ul><h2 id="缓存-1" tabindex="-1"><a class="header-anchor" href="#缓存-1" aria-hidden="true">#</a> 缓存</h2><h3 id="redis与memcache" tabindex="-1"><a class="header-anchor" href="#redis与memcache" aria-hidden="true">#</a> Redis与Memcache</h3><ul><li>支持**数据类型：**memcached所有的值均是简单的<mark>字符串</mark>，redis作为其替代者，支持更为<mark>丰富的数据类型</mark>，提供list，set，zset，hash等数据结构的存储。</li><li><strong>value值</strong>大小不同：Redis最大可以达到<mark>512mb</mark>；memcache只有<mark>1mb</mark>。</li><li><strong>存储方式</strong>：Memecache把数据全部存在<strong>内存</strong>之中，断电后会挂掉，数据不能超过内存大小。Redis有部分<mark>存在硬盘</mark>上，redis<mark>可以持久化</mark>其数据。</li><li><strong>备份</strong>：Redis支持数据的备份，即master-slave模式的数据备份。</li><li>使用<strong>底层模型</strong>不同：它们之间底层实现方式以及与客户端之间通信的应用协议不一样。Redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li><li><strong>速度</strong>：redis的速度比memcached快很多。</li></ul><p>这时候肯定想到的就是做一个Memcache与Redis区别。</p><ul><li><p>Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过Memcache还可用于缓存其他东西，例如图片、视频等等。</p></li><li><p>Memcache仅支持key-value结构的数据类型，Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，hash等数据结构的存储。</p></li><li><p>虚拟内存--Redis当物理内存用完时，可以将一些很久没用到的value交换到磁盘</p></li><li><p>分布式--设定Memcache集群，利用magent做一主多从;Redis可以做一主多从。都可以一主一从存储数据安全--Memcache挂掉后，数据没了；Redis可以定期保存到磁盘（持久化）</p></li><li><p>Memcache的单个value最大1m，Redis的单个value最大512m。</p></li><li><p>灾难恢复--Memcache挂掉后，数据不可恢复；Redis数据丢失后可以通过aof恢复</p></li><li><p>Redis原生就支持集群模式，Redis3.0版本中，官方便能支持Cluster模式了，Memcached没有原生的集群模式，需要依赖客户端来实现，然后往集群中分片写入数据。</p><p>Memcached网络IO模型是多线程，非阻塞IO复用的网络模型，原型上接近于nignx。而Redis使用单线程的IO复用模型，自己封装了一个简单的AeEvent事件处理框架，主要实现类epoll，kqueue和select，更接近于Apache早期的模式。</p></li></ul><h3 id="redis-memcache-mongodb" tabindex="-1"><a class="header-anchor" href="#redis-memcache-mongodb" aria-hidden="true">#</a> Redis，Memcache，MongoDB</h3><p>比较的项为：使用场景、存储方式，数据类型，数据一致性，性能。</p><table><thead><tr><th><strong>项</strong></th><th><strong>Redis</strong></th><th><strong>Memcache</strong></th><th><strong>MongoDB</strong></th></tr></thead><tbody><tr><td><strong>使用场景</strong></td><td>数据量较小的数据库缓存</td><td>数据库缓存</td><td>主要解决海量数据的访问效率问题（服务器之间数据共享）</td></tr><tr><td><strong>存储方式</strong></td><td>内存+硬盘（可持久化）</td><td>只在内存中</td><td>内存+硬盘（可持久化）</td></tr><tr><td><strong>数据类型</strong></td><td>key-value, list, set, hash等</td><td>只支持key-value</td><td>类型很丰富，支持索引，最类似关系型数据库</td></tr><tr><td><strong>数据一致性</strong></td><td>有事务功能，可保证命令的原子性，中间不会被任何操作打断</td><td>提供了cas命令，可以保证多个并发访问操作同一份数据的一致性问题</td><td>不支持事务</td></tr><tr><td><strong>性能</strong></td><td>略差于memcache</td><td>略好于Redis</td><td>性能明显低于另外两个</td></tr></tbody></table><h3 id="redis锁zookeeper锁" tabindex="-1"><a class="header-anchor" href="#redis锁zookeeper锁" aria-hidden="true">#</a> Redis锁Zookeeper锁</h3><p>Redis 锁 通过 setnx key value 或者 set key value px millseconds nx 当返回1时代表获取到锁，返回0表示获取锁失败，通过Redis的key超时机制来释放锁</p><p>PS： Redis锁可能会在业务逻辑还没执行完的时候就已经超时释放，因此在释放锁的时候，可能其他线程已经重新持有了该锁，所以要在释放锁的时候验证key对应的value值，在创建缓存的时候，value值是随机生成的。或者使用redisson做为分布式锁</p><p>ZK锁 通过在服务端新建一个临时有序节点，哪个客户端成功创建了第一个临时有序节点，就代表该客户端获得了锁，后面节点的客户端会处于监听状态，当释放锁的时候，服务端就会删除第一个临时节点，此时第二个临时节点能监听到上一个节点的释放事件，这样第二个节点就变成第一个节点，此时客户端2就代表获得了锁。如果客户端的会话关闭，临时节点会被删除，也就释放了锁</p><h3 id="rdb和aof" tabindex="-1"><a class="header-anchor" href="#rdb和aof" aria-hidden="true">#</a> RDB和AOF</h3><p>Redis提供两种持久化机制RDB和AOF机制：</p><h4 id="rdb-redis-database-持久化方式" tabindex="-1"><a class="header-anchor" href="#rdb-redis-database-持久化方式" aria-hidden="true">#</a> RDB（Redis DataBase）持久化方式</h4><p>是指用数据集快照的方式半持久化模式。记录redis数据库的所有键值对，在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复。</p><p><strong>优点</strong>：</p><ul><li>只有一个文件dump.rdb，方便持久化。</li><li>容灾性好，一个文件可以保存到安全的磁盘。</li><li>性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以是IO最大化。使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了Redis的高性能。</li><li>数据集大时，比AOF的启动效率更高。</li></ul><p><strong>缺点</strong>：</p><p>数据安全性低。RDB是间隔一段时间进行持久化，如果持久化之间Redis发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候</p><h4 id="aof-append-only-file持久化方式" tabindex="-1"><a class="header-anchor" href="#aof-append-only-file持久化方式" aria-hidden="true">#</a> **AOF=Append-**only <strong>file持久化方式</strong></h4><p>是指所有的命令行记录以Redis命令请求协议的格式完全持久化存储，保存为AOF文件。通过设置<strong>appendonly yes</strong> 开启</p><p><strong>优点</strong>：</p><p>（1）数据安全，AOF持久化可以配置appendfsync属性，有always，每进行一次命令操作就记录到AOF文件中一次。</p><p>（2）通过append模式写文件，即使中途服务器宕机，可以通过redis-check-aof工具解决数据一致性问题。</p><p>（3）AOF机制的rewrite模式。AOF文件没被rewrite之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的flushall)</p><p><strong>缺点</strong>：</p><p>（1）AOF文件比RDB文件大，且恢复速度慢。</p><p>（2）数据集大的时候，比RDB启动效率低。</p><h2 id="框架" tabindex="-1"><a class="header-anchor" href="#框架" aria-hidden="true">#</a> 框架</h2><h3 id="springboot和springcloud" tabindex="-1"><a class="header-anchor" href="#springboot和springcloud" aria-hidden="true">#</a> SpringBoot和SpringCloud</h3><ol><li>SpringBoot<mark>专注于快速、方便的开发单个个体微服务</mark>（关注微观）。</li><li>SpringCloud是<mark>关注全局的微服务协调整理治理框架以及一整套的落地解决方案</mark>，它将SpringBoot开发的一个个单体微服务整合并管理起来，为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务（关注宏观）。</li><li>SpringBoot可以离开SpringCloud独立使用开发项目，但是SpringCloud离不开SpringBoot，属于依赖的关系。</li></ol><p>总结：</p><ul><li>SpringBoot，专注于快速，方便的开发单个微服务个体。</li><li>SpringCloud，关注全局的服务治理框架。</li></ul><h3 id="spring-boot、spring-mvc和spring" tabindex="-1"><a class="header-anchor" href="#spring-boot、spring-mvc和spring" aria-hidden="true">#</a> Spring Boot、Spring MVC和Spring</h3><p><strong>Spring</strong></p><p>SpringFramework最重要的特征是依赖注入。所有SpringModules不是依赖注入就是IOC控制反转。</p><p>当我们恰当的使用DI或者是IOC的时候，我们可以开发松耦合应用。松耦合应用的单元测试可以很容易的进行。</p><p><strong>SpringMVC</strong></p><p>Spring MVC提供了一种分离式的方法来开发Web应用。通过运用像DispatcherServelet，ModelAndView和ViewResolver等一些简单的概念，开发Web应用将会变的非常简单。</p><p><strong>SpringBoot</strong></p><p>Spring和SpringMVC的问题在于需要配置大量的参数。</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.springframework.web.servlet.view.InternalResourceViewResolver<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>prefix<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>/WEB-INF/views/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>suffix<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>.jsp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>resources</span> <span class="token attr-name">mapping</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/webjars/**<span class="token punctuation">&quot;</span></span><span class="token attr-name">location</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/webjars/<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Spring Boot通过一个自动配置和启动的项来目解决这个问题。为了更快的构建产品就绪应用程序，Spring Boot提供了一些非功能性特征。</p><h3 id="spring-boo-1-x和t2-x" tabindex="-1"><a class="header-anchor" href="#spring-boo-1-x和t2-x" aria-hidden="true">#</a> Spring Boo 1.X和t2.X</h3><ul><li>配置变更</li><li>JDK版本升级第三方类库升级</li><li>响应式Spring编程支持</li><li>HTTP/2支持配置属性绑定</li><li>更多改进与加强...</li></ul><h3 id="spring-boot打成的jar和普通的jar" tabindex="-1"><a class="header-anchor" href="#spring-boot打成的jar和普通的jar" aria-hidden="true">#</a> Spring Boot打成的jar和普通的jar</h3><p>Spring Boot项目最终打包成的jar是可执行jar，这种jar可以直接通过java -jar xxx.jar命令来运行，这种jar不可以作为普通的jar被其他项目依赖，即使依赖了也无法使用其中的类。</p><h3 id="在spring-aop中-关注点和横切关注点" tabindex="-1"><a class="header-anchor" href="#在spring-aop中-关注点和横切关注点" aria-hidden="true">#</a> 在Spring AOP中，关注点和横切关注点</h3><p><strong>关注点</strong>是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。</p><p><strong>横切关注点</strong>是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</p><h3 id="spring-aop和aspectj-aop" tabindex="-1"><a class="header-anchor" href="#spring-aop和aspectj-aop" aria-hidden="true">#</a> Spring AOP和AspectJ AOP</h3><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理（Proxying），而AspectJ基于字节码操作（Bytecode Manipulation）。</p><p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。</p><p>Spring AOP基于动态代理方式实现；AspectJ基于静态代理方式实现。SpringAOP仅支持方法级别的PointCut；AspectJ提供了完全的AOP支持，它还支持属性级别的PointCut。</p><h3 id="applicationcontext和beanfactory" tabindex="-1"><a class="header-anchor" href="#applicationcontext和beanfactory" aria-hidden="true">#</a> ApplicationContext和BeanFactory</h3><table><thead><tr><th><strong>项</strong></th><th><strong>BeanFactory</strong></th><th><strong>ApplicationContext</strong></th></tr></thead><tbody><tr><td><strong>说明</strong></td><td>最顶层接口，只提供实例化对象和取对象功能。 主要是getBean()方法。</td><td>继承BeanFactory接口，它是Spring更高级的容器，有很多有用的功能。 (1) 国际化（MessageSource） (2) 访问资源（ResourceLoader）。如：URL和文件 (3) 载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次。比如应用的web层 (4) 消息发送、响应机制（ApplicationEventPublisher） (5) AOP（拦截器）</td></tr><tr><td><strong>使用者</strong></td><td>使用者是Spring本身。</td><td>适合Spring的用户使用。不推荐直接用BeanFactory。</td></tr><tr><td><strong>装载bean</strong></td><td>是延迟初始化的：启动时不实例化Bean，从容器中取Bean时才实例化。 延迟实例化的优点：（BeanFactory） 应用启动的时候占用资源很少；对资源要求较高的应用，比较有优势；</td><td>非延迟初始化（启动时实例化所有的Bean）。也可为Bean配置lazy-init=true来让Bean延迟初始化(实例化)。 不延迟实例化的优点： （ApplicationContext） 1. 所有的Bean在启动的时候都加载，系统运行的速度快； 2. 在启动的时候所有的Bean都加载了，我们就能在系统启动的时候，尽早的发现系统中的配置问题 3. 建议web应用，在启动的时候就把所有的Bean都加载了。（把费时的操作放到系统启动中完成）</td></tr></tbody></table><p>Application contexts提供一种方法处理文本消息，一个通常的做法是加载文件资源（比如镜像），它们可以向注册为监听器的bean发布事件。另外，在容器或容器内的对象上执行的那些不得不由bean工厂以程序化方式处理的操作，可以在Application contexts中以声明的方式处理。Application contexts实现了MessageSource接口，该接口的实现以可插拔的方式提供获取本地化消息的方法。</p><p><strong>包目录不同</strong></p><p>spring-beans.jar中org.springframework.beans.factory.BeanFactory</p><p>spring-context.jar中org.springframework.context.ApplicationContext</p><p><strong>国际化</strong></p><p>BeanFactory是不支持国际化功能的，因为BeanFactory没有扩展Spring中MessageResource接口。相反，由于ApplicationContext扩展了MessageResource接口，因而具有消息处理的能力（i18N）。</p><p><strong>强大的事件机制（Event）</strong></p><p>基本上牵涉到事件（Event）方面的设计，就离不开观察者模式，ApplicationContext的事件机制主要通过ApplicationEvent和ApplicationListener这两个接口来提供的，和Java swing中的事件机制一样。即当ApplicationContext中发布一个事件时，所有扩展了ApplicationListener的Bean都将接受到这个事件，并进行相应的处理。</p><p><strong>底层资源的访问</strong></p><p>ApplicationContext扩展了ResourceLoader（资源加载器）接口，从而可以用来加载多个Resource，而BeanFactory是没有扩展ResourceLoader。</p><p><strong>对Web应用的支持</strong></p><p>BeanFactory通常以编程的方式被创建，ApplicationContext能以声明的方式创建，如使用ContextLoader。</p><p>当然你也可以使用ApplicationContext的实现方式之一，以编程的方式创建ApplicationContext实例。</p><p><strong>延迟加载</strong></p><p>1.BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的spring的配置问题。而ApplicationContext则相反，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误。</p><p>2.BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用。两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p><p>可以看到，ApplicationContext继承了BeanFactory，BeanFactory是Spring中比较原始的Factory，它不支持AOP、Web等Spring插件。而ApplicationContext不仅包含了BeanFactory的所有功能，还支持Spring的各种插件，还以一种面向框架的方式工作以及对上下文进行分层和实现继承。</p><p>BeanFactory是Spring框架的基础设施，面向Spring本身；而ApplicationContext面向使用Spring的开发者，相比BeanFactory提供了更多面向实际应用的功能，几乎所有场合都可以直接使用ApplicationContext，而不是底层的BeanFactory。</p><p><strong>常用容器</strong></p><p>BeanFactory类型的有XmlBeanFactory，它可以根据XML文件中定义的内容，创建相应的Bean。</p><p>ApplicationContext类型的常用容器有：</p><p>1.ClassPathXmlApplicationContext：从ClassPath的XML配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中取得。</p><p>2.FileSystemXmlApplicationContext：由文件系统中的XML配置文件读取上下文。</p><p>3.XmlWebApplicationContext：由Web应用的XML文件读取上下文。例如我们在Spring MVC使用的情况。</p><p>BeanFactory、ApplicationContext都代表容器，BeanFactory是一个基础接口，实现了容器基础的功能，ApplicationContext是容器的高级形态，增加了许多了特性，顶级父类是BeanFactory。</p><h3 id="beanfactory和factorybean" tabindex="-1"><a class="header-anchor" href="#beanfactory和factorybean" aria-hidden="true">#</a> BeanFactory和FactoryBean</h3><ul><li>Factory<mark>Bean</mark> 是一个<mark>Bean</mark>，用于生产修饰其他的Bean实例，典型应用是AOP代理类，使用&#39;&amp;&#39;获取FactoryBean本身。</li><li>Bean<mark>Factory</mark> 是一个<mark>工厂</mark>，是容器的顶层<mark>接口</mark>。</li></ul><hr><table><thead><tr><th><strong>项</strong></th><th><strong>BeanFactory</strong></th><th><strong>FactoryBean</strong></th></tr></thead><tbody><tr><td><strong>工厂</strong></td><td>负责生产和管理bean的一个通用工厂。 基于工厂模式实现。</td><td>也是一个工厂，但只创建一种对象。</td></tr><tr><td><strong>作用</strong></td><td>实例化、定位、配置对象及建立其依赖。 IOC容器的核心接口。</td><td>可以创建复杂的bean。 是一个接口。 Spring自身就提供了70多个FactoryBean的实现。它们隐藏了实例化一些复杂Bean的细节，给上层应用带来了便利。</td></tr><tr><td><strong>实现</strong></td><td>DefaultListableBeanFactory、ApplicationContext、XmlBeanFactory等。 比如：XmlBeanFactory解析XML生成bean，处理对象间的依赖关系。</td><td></td></tr></tbody></table><hr><h3 id="component和-bean" tabindex="-1"><a class="header-anchor" href="#component和-bean" aria-hidden="true">#</a> @Component和@Bean</h3><ul><li>@<mark>Component 注解作用于类</mark>，而@Bean注解作用于方法。</li><li>@Component通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean，@Bean告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</li><li>@<mark>Bean </mark>注解比 @Component 注解的自<mark>定义性更强</mark>，而且很多地方我们只能通过 @Bean 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现。</li></ul><p>@Bean注解使用示例：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">TransferService</span> <span class="token function">transferService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TransferServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码相当于下面的 xml 配置</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>transferService<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.acme.TransferServiceImpl<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面这个例子是通过 @Component 无法实现的。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> <span class="token class-name">OneService</span> <span class="token function">getService</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">case</span> <span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        when <span class="token number">1</span><span class="token operator">:</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">serviceImpl1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        when <span class="token number">2</span><span class="token operator">:</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">serviceImpl2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        when <span class="token number">3</span><span class="token operator">:</span>
    	<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">serviceImpl3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="autowired和-resource★★★" tabindex="-1"><a class="header-anchor" href="#autowired和-resource★★★" aria-hidden="true">#</a> @Autowired和@Resource★★★</h3><ol><li>@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。</li><li>@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</li></ol><p>Autowired 属于 Spring 内置的注解，默认的注入方式为byType（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （接口的实现类）。</p><p><strong>这会有什么问题呢？</strong> 当一个接口存在多个实现类的话，byType这种方式就无法正确注入对象了，因为这个时候 Spring 会同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个。</p><p>这种情况下，注入方式会变为 byName（根据名称进行匹配），这个名称通常就是类名（首字母小写）。就比如说下面代码中的 smsService 就是我这里所说的名称，这样应该比较好理解了吧。</p><p>// smsService 就是我们上面所说的名称</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Autowired</span>
<span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span>
举个例子，<span class="token class-name">SmsService</span> 接口有两个实现类<span class="token operator">:</span> <span class="token class-name">SmsServiceImpl1</span>和 <span class="token class-name">SmsServiceImpl2</span>，且它们都已经被
<span class="token class-name">Spring</span> 容器所管理。
<span class="token comment">// 报错，byName 和 byType 都无法匹配到 bean</span>
<span class="token annotation punctuation">@Autowired</span>
<span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span>
<span class="token comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span>
<span class="token annotation punctuation">@Autowired</span>
<span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsServiceImpl1<span class="token punctuation">;</span>
<span class="token comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span>
<span class="token comment">// smsServiceImpl1 就是我们上面所说的名称</span>
<span class="token annotation punctuation">@Autowired</span>
<span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;smsServiceImpl1&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们还是建议通过 @Qualifier 注解来显示指定名称而不是依赖变量的名称。</p><p>@Resource属于 JDK 提供的注解，默认注入方式为 byName。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为byType。</p><p>@Resource 有两个比较重要且日常开发常用的属性：name（名称）、type（类型）。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">Resource</span> <span class="token punctuation">{</span>

    <span class="token class-name">String</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>

    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果仅指定 name 属性则注入方式为byName，如果仅指定type属性则注入方式为byType，如果同时指定name 和type属性（不建议这么做）则注入方式为byType+byName。</p><p>// 报错，byName 和 byType 都无法匹配到 bean</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Resource</span>
<span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span>

<span class="token comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span>
<span class="token annotation punctuation">@Resource</span>
<span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsServiceImpl1<span class="token punctuation">;</span>

<span class="token comment">// 正确注入 SmsServiceImpl1 对象对应的 bean（比较推荐这种方式）</span>
<span class="token annotation punctuation">@Resource</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">&quot;smsServiceImpl1&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单总结一下：</p><ul><li>@Autowired 是 Spring 提供的注解，@Resource 是 JDK 提供的注解。</li><li>Autowired 默认的注入方式为byType（根据类型进行匹配），@Resource默认注入方式为 byName（根据名称进行匹配）。</li><li>当一个接口存在多个实现类的情况下，@Autowired 和@Resource都需要通过名称才能正确匹配到对应的 Bean。Autowired 可以通过 @Qualifier 注解来显示指定名称，@Resource可以通过 name 属性来显示指定名称。</li></ul><h4 id="回答2" tabindex="-1"><a class="header-anchor" href="#回答2" aria-hidden="true">#</a> 回答2：</h4><p>@Resource和@Autowired<strong>都是做bean的注入时使用</strong>，其实**@Resource并不是Spring的注解**，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。</p><p>1、共同点</p><p>两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。</p><p>2、不同点</p><p>（1）<strong>@Autowired</strong></p><p>@Autowired为Spring提供的注解，需要导入包</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span>Autowired</span><span class="token punctuation">;</span>

<span class="token comment">// 只按照byType注入。</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestServiceImpl</span> <span class="token punctuation">{</span>
    <span class="token comment">// 下面两种@Autowired只要使用一种即可</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">UserDao</span> userDao<span class="token punctuation">;</span> <span class="token comment">// 用于字段上</span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUserDao</span><span class="token punctuation">(</span><span class="token class-name">UserDao</span> userDao<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 用于属性的方法上</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>userDao <span class="token operator">=</span> userDao<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestServiceImpl</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">&quot;userDao&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span><span class="token operator">*</span> <span class="token class-name">UserDao</span> userDao<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（2）<strong>@Resource</strong></p><p>@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestServiceImpl</span> <span class="token punctuation">{</span>
    <span class="token comment">// 下面两种@Resource只要使用一种即可</span>
    <span class="token annotation punctuation">@Resource</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">&quot;userDao&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span><span class="token operator">*</span> <span class="token class-name">UserDao</span> userDao<span class="token punctuation">;</span> <span class="token comment">// 用于字段上</span>

    <span class="token annotation punctuation">@Resource</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">&quot;userDao&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUserDao</span><span class="token punctuation">(</span><span class="token class-name">UserDao</span> userDao<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 用于属性的setter方法上</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>userDao <span class="token operator">=</span> userDao<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注：最好是将@Resource放在setter方法上，因为这样更符合面向对象的思想，通过set、get去操作属性，而不是直接去操作属性。</p><p>@Resource装配顺序：</p><p>①如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。</p><p>②如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。</p><p>③如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。</p><p>④如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。</p><p>@Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。</p><h3 id="component-controller-repository-service" tabindex="-1"><a class="header-anchor" href="#component-controller-repository-service" aria-hidden="true">#</a> @Component，@Controller，@Repository，@Service</h3><p>@Component：这将java类标记为bean。它是任何Spring管理组件的通用构造型。spring的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。@Controller：这将一个类标记为Spring Web MVC控制器。标有它的Bean会自动导入到IoC容器中。@Service：此注解是组件注解的特化。它不会对@Component注解提供任何其他行为。您可以在服务层类中使用@Service而不是@Component，因为它以更好的方式指定了意图。@Repository：这个注解是具有类似用途和功能的@Component注解的特化。它为DAO提供了额外的好处。它将DAO导入IoC容器，并使未经检查的异常有资格转换为Spring DataAccessException。</p><h3 id="dubbo和springcloud" tabindex="-1"><a class="header-anchor" href="#dubbo和springcloud" aria-hidden="true">#</a> Dubbo和SpringCloud</h3><p><mark>服务调用方式</mark>，dubbo是RPC， springcloud是Rest Api</p><p><mark>注册中心</mark>，dubbo是zookeeper， springcloud是eureka，也可以是zookeeper</p><p><mark>服务网关</mark>，dubbo本身没有实现，只能通过其他第三方技术整合，springcloud有Zuul路由网关，作为路由服务器，进行消费者的请求分发，springcloud支持断路器，与git完美集成配置文件支持版本控制，事物总线实现配置文件的更新与服务自动装配等等一系列的微服务架构要素。</p><p>首先，他们都是分布式管理框架。</p><p>dubbo是二进制传输，占用带宽会少一点。SpringCloud是http传输，带宽会多一点，同时使用http协议一般会使用JSON报文，消耗会更大。</p><p>dubbo开发难度较大，所依赖的jar包有很多问题大型工程无法解决。SpringCloud对第三方的继承可以一键式生成，天然集成。</p><p>SpringCloud接口协议约定比较松散，需要强有力的行政措施来限制接口无序升级。</p><p>最大：Spring Cloud抛弃了Dubbo的RPC通信，采用的是基于HTTP的REST方式。</p><p>严格来说，这两种方式各有优劣。虽然在一定程度上来说，springcloud牺牲了服务调用的性能，但也避免了上面提到的原生RPC带来的问题。而且REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更为合适，所以推荐用springcloud。</p><p>这是很多面试官喜欢问的问题，本人认为其实他们没什么关联之处，但是硬是要问区别，那就说说吧。</p><p>回答的时候主要围绕着四个关键点来说：通信方式、注册中心、监控、断路器，其余像Spring分布式配置、服务网关肯定得知道。</p><p><strong>通信方式</strong></p><p>Dubbo使用的是RPC通信；Spring Cloud使用的是HTTP RestFul方式。</p><p><strong>注册中心</strong></p><p>Dubbo使用ZooKeeper（官方推荐），还有Redis、Multicast、Simple注册中心，但不推荐。Spring Cloud使用的是Spring Cloud Netflix Eureka。</p><p><strong>监控</strong></p><p>Dubbo使用的是Dubbo-monitor；Spring Cloud使用的是Spring Boot admin。</p><p><strong>断路器</strong></p><p>Dubbo在断路器这方面还不完善，Spring Cloud使用的是Spring Cloud Netflix Hystrix。分布式配置、网关服务、服务跟踪、消息总线、批量任务等。Dubbo目前可以说还是空白，而Spring Cloud都有相应的组件来支撑。</p><p>根据微服务架构在各方面的要素，看看Spring Cloud和Dubbo都提供了哪些支持。</p><hr><table><thead><tr><th></th><th><strong>Dubbo</strong></th><th><strong>Spring Cloud</strong></th></tr></thead><tbody><tr><td>服务注册中心</td><td>Zookeeper</td><td>Spring Cloud Netflix Eureka</td></tr><tr><td>服务调用方式</td><td>RPC</td><td>REST API</td></tr><tr><td>服务监控</td><td>Dubbo-monitor</td><td>Spring Boot Admin</td></tr><tr><td>服务网关</td><td>无</td><td>Spring Cloud Netflix Gateway</td></tr><tr><td>断路器</td><td>不完善</td><td>Spring Cloud Netflix Hystrix</td></tr><tr><td>分布式配置</td><td>无</td><td>Spring Cloud Conﬁg</td></tr><tr><td>服务跟踪</td><td>无</td><td>Spring Cloud Sleuth</td></tr><tr><td>消息总线</td><td>无</td><td>Spring Cloud Bus</td></tr><tr><td>数据流</td><td>无</td><td>Spring Cloud Stream</td></tr><tr><td>批量任务</td><td>无</td><td>Spring Cloud Task</td></tr><tr><td>……</td><td>……</td><td>……</td></tr></tbody></table><hr><p>使用Dubbo构建的微服务架构就像组装电脑，各环节我们的选择自由度很高，但是最终结果很有可能因为一条内存质量不行就点不亮了，总是让人不怎么放心，但是如果你是一名高手，那这些都不是问题；而Spring Cloud就像品牌机，在Spring Source的整合下，做了大量的兼容性测试，保证了机器拥有更高的稳定性，但是如果要在使用非原装组件外的东西，就需要对其基础有足够的了解。</p><h3 id="rest和rpc" tabindex="-1"><a class="header-anchor" href="#rest和rpc" aria-hidden="true">#</a> REST和RPC</h3><p>RPC主要的缺陷是服务提供方和调用方式之间的<mark>依赖太强</mark>，需要对每一个微服务进行接口的定义，并通过持续继承发布，严格版本控制才不会出现冲突。</p><p>REST是<mark>轻量级</mark>的接口，服务的提供和调用不存在代码之间的耦合，只需要一个约定进行规范。</p><h3 id="rpc和http" tabindex="-1"><a class="header-anchor" href="#rpc和http" aria-hidden="true">#</a> RPC和HTTP</h3><p><strong>a. 区别：</strong></p><p><strong>传输协议</strong></p><ul><li>RPC，可以基于TCP协议，也可以基于HTTP协议</li><li>HTTP，基于HTTP协议</li></ul><p><strong>传输效率</strong></p><ul><li>RPC，使⽤<mark>⾃定义的TCP协议</mark>，可以让请求报⽂体积更⼩，或者使⽤HTTP2协议，也可以很好的减少报⽂的体积，提⾼传输效率。</li><li>HTTP，如果是基于HTTP1.1的协议，请求中会包含很多⽆⽤的内容，如果是基于HTTP2.0，那么简单的封装以下是可以作为⼀个RPC来使⽤的，这时标准RPC框架更多的是服务治理。</li></ul><p><strong>性能消耗</strong>，主要在于序列化和反序列化的耗时</p><ul><li>RPC，可以基于thrift实现⾼效的⼆进制传输。</li><li>HTTP，⼤部分是通过json来实现的，字节⼤⼩和序列化耗时都⽐thrift要更消耗性能。</li></ul><p><strong>负载均衡</strong></p><ul><li>RPC，基本都⾃带了负载均衡策略。</li><li>HTTP，需要配置Nginx，HAProxy来实现。</li></ul><p><strong>服务治理</strong>（下游服务新增，重启，下线时如何不影响上游调⽤者）</p><ul><li>RPC，能做到⾃动通知，不影响上游</li><li>HTTP，需要事先通知，修改Nginx/HAProxy配置</li></ul><p>b.总结：RPC<mark>主要⽤于公司内部的服务调⽤</mark>，性能消耗低，传输效率⾼，服务治理⽅便。HTTP主要⽤于对外的异构环境，浏览器接⼝调⽤，APP接⼝调⽤，<mark>第三⽅接⼝调⽤</mark>等。</p><h3 id="rpc和消息队列" tabindex="-1"><a class="header-anchor" href="#rpc和消息队列" aria-hidden="true">#</a> RPC和消息队列</h3><p>RPC 和消息队列都是分布式微服务系统中重要的组件之一，下面我们来简单对比一下两者：</p><ul><li><strong>从用途来看</strong>：RPC 主要用来解决两个服务的远程通信问题，不需要了解底层网络的通信机制。通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。消息队列主要用来降低系统耦合性、实现任务异步、有效地进行流量削峰。</li><li><strong>从通信方式来看</strong>：RPC 是双向直接网络通讯，消息队列是单向引入中间载体的网络通讯。</li><li><strong>从架构上来看</strong>：消息队列需要把消息存储起来，RPC 则没有这个要求，因为前面也说了 RPC 是双向直接网络通讯。</li><li><strong>从请求处理的时效性来看</strong>：通过 RPC 发出的调用一般会立即被处理，存放在消息队列中的消息并不一定会立即被处理。</li></ul><p>RPC 和消息队列本质上是网络通讯的两种不同的实现机制，两者的用途不同，万不可将两者混为一谈。</p><h3 id="dubbo和dubbox" tabindex="-1"><a class="header-anchor" href="#dubbo和dubbox" aria-hidden="true">#</a> Dubbo和Dubbox</h3><p>Dubbox是继Dubbo停止维护后，当当网基于Dubbo做的一个扩展项目，如加了服务可Restful调用，更新了开源组件等。</p><h3 id="dubbo-spi和java-spi" tabindex="-1"><a class="header-anchor" href="#dubbo-spi和java-spi" aria-hidden="true">#</a> Dubbo SPI和Java SPI</h3><p>Dubbo SPI 跟Java SPI很相似，Java SPI是Java内置的一种服务提供发现功能，一种动态替换发现机制。</p><p><strong>Java  SPI使用方法：</strong></p><ul><li>在META-INF/services 目录下放置配置文件，文件名是接口全路径名，文件内部是要实现接口的实现类全路径名，编码用UTF-8</li><li>使用ServiceLoad.load(xx.class)调用</li></ul><p>JDK标准的SPI会一次性加载所有的扩展实现，有的扩展说实话很耗时，但是没用上，很浪费资源。</p><p>所以只希望加载某个的实现，就不现实了。</p><p><strong>Dubbo SPI比Java SPI增加了：</strong></p><ul><li>可以方便地获取某一个想要的扩展实现</li><li>对于扩展实现IOC依赖注入功能</li><li>@SPI声明一个扩展接口，@Adaptive用在方法上，表示自动生成和编译一个动态的Adaptive类，如果用在类上表示一个装饰模式的类</li></ul><p>Dubbo 通过ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension()方法进行加载，每个SPI接口(@SPI注解的接口)都会产生一个ExtensionLoader扩展加载器实例，保存在名为EXTENSION_LOADERS的ConcureentMap中，通过扩展加载器调用getAdaptiveExtension()方法来获得自适应对象，并注入对象依赖属性</p><p>Dubbo扩展接口文件放在META-INF/dubbo 目录下，文件名是接口全路径名，文件内部是接口实现类的全路径名。</p><p><strong>优点：</strong></p><p>1，对Dubbo进行扩展，不需要改动Dubbo的源码</p><p>2，延迟加载，可以一次只加载自己想要加载的扩展实现。</p><p>3，增加了对扩展点IOC和AOP的支持，一个扩展点可以直接setter注入其它扩展点。</p><p>4，Dubbo的扩展机制能很好的支持第三方IoC容器，默认支持Spring Bean。</p><h3 id="hibernate和jpa" tabindex="-1"><a class="header-anchor" href="#hibernate和jpa" aria-hidden="true">#</a> Hibernate和JPA</h3><ul><li><p>JPA Java Persistence API，是 Java EE 5 的标准 ORM 接口，也是 ejb3 规范的一部分。</p></li><li><p>Hibernate，当今很流行的 ORM 框架，是 JPA 的一个实现，但是其功能是 JPA 的超集。</p></li><li><p>JPA和Hibernate 之间的关系，可以简单的理解为 JPA 是标准接口，Hibernate 是实现。那么 Hibernate 是如何实现与 JPA 的这种关系的呢。Hibernate 主要是通过三个组件来实现的，及 hibernate-annotation、hibernate-entitymanager和hibernate-core。</p></li><li><p>hibernate-annotation 是 Hibernate 支持 annotation 方式配置的基础，它包括了标准的 JPA annotation 以及 Hibernate 自身特殊功能的 annotation。</p></li><li><p>hibernate-core 是 Hibernate 的核心实现，提供了 Hibernate 所有的核心功能。</p></li><li><p>hibernate-entitymanager 实现了标准的 JPA，可以把它看成 hibernate-core和JPA 之间的适配器，它并不直接提供 ORM 的功能，而是对 hibernate-core 进行封装，使得Hibernate 符合 JPA 的规范。</p><p>简而言之，JPA是一个规范或者接口，Hibernate是JPA的一个实现。当我们使用JPA的时候，我们使用javax.persistence包中的注释和接口时，不需要使用hibernate的导入包。我们建议使用JPA注释，因为我们没有将其绑定到Hibernate作为实现。后来（我知道小于百分之一的几率），我们可以使用另一种JPA实现。</p></li></ul><h3 id="eureka和zookeeper" tabindex="-1"><a class="header-anchor" href="#eureka和zookeeper" aria-hidden="true">#</a> Eureka和Zookeeper</h3><p>Eureka取CAP的AP，注重可用性，Zookeeper取CAP的CP注重一致性。</p><p>Zookeeper在选举期间注册服务瘫痪，虽然服务最终会恢复，但选举期间不可用。</p><p>eureka的自我保护机制，会导致一个结果就是不会再从注册列表移除因长时间没收到心跳而过期的服务。依然能接受新服务的注册和查询请求，但不会被同步到其他节点。不会服务瘫痪。</p><p>Zookeeper有Leader和Follower角色，Eureka各个节点平等。</p><p>Zookeeper采用过半数存活原则，Eureka采用自我保护机制解决分区问题。</p><p>eureka本质是一个工程，Zookeeper只是一个进程。</p><p>Zookeeper保证了CP（C：一致性，P：分区容错性），Eureka保证了AP（A：高可用）</p><p>1.当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的信息，但不能容忍直接down掉不可用。也就是说，服务注册功能对高可用性要求比较高，但zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新选leader。问题在于，选取leader时间过长，30~120s，且选取期间zk集群都不可用，这样就会导致选取期间注册服务瘫痪。在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够恢复，但是漫长的选取时间导致的注册长期不可用是不能容忍的。</p><p>2.Eureka保证了可用性，Eureka各个节点是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点仍然可以提供注册和查询服务。而Eureka的客户端向某个Eureka注册或发现时发生连接失败，则会自动切换到其他节点，只要有一台Eureka还在，就能保证注册服务可用，只是查到的信息可能不是最新的。除此之外，Eureka还有自我保护机制，如果在15分钟内超过85%的节点没有正常的心跳，那么Eureka就认为客户端与注册中心发生了网络故障，此时会出现以下几种情况：</p><p>①、Eureka不再从注册列表中移除因为长时间没有收到心跳而应该过期的服务。</p><p>②、Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点上（即保证当前节点仍然可用）。</p><p>③、当网络稳定时，当前实例新的注册信息会被同步到其他节点。因此，Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像Zookeeper那样使整个微服务瘫痪</p><p>zookeeper是CP原则，强一致性和分区容错性。</p><p>eureka是AP原则，可用性和分区容错性。</p><p>zookeeper当主节点故障时，zk会在剩余节点重新选择主节点，耗时过长，虽然最终能够恢复，但是选取主节点期间会导致服务不可用，这是不能容忍的。</p><p>eureka各个节点是平等的，一个节点挂掉，其他节点仍会正常保证服务。</p><h3 id="feign和ribbon" tabindex="-1"><a class="header-anchor" href="#feign和ribbon" aria-hidden="true">#</a> Feign和Ribbon</h3><p>Ribbon和Feign 都是使用于调用用其余服务的，不过方式不同。</p><ul><li>启动类用的注解不同。 <ul><li>Ribbon 使用的是 @RibbonClient 。</li><li>Feign 使用的是 @EnableFeignClients 。</li></ul></li><li>服务的指定位置不同。 <ul><li>Ribbon 是在 @RibbonClient 注解上设置。</li><li>Feign 则是在定义声明方法的接口中用 @FeignClient 注解上设置。</li></ul></li><li>调使用方式不同。 <ul><li>Ribbon 需要自己构建 Http 请求，模拟 Http 请求而后用 RestTemplate 发送给其余服务，步骤相当繁琐。</li><li>Feign 采使用接口的方式，将需要调使用的其余服务的方法定义成声明方法就可，不需要自己构建 Http 请求。不过要注意的是声明方法的注解、方法签名要和提供服务的方法完全一致。</li></ul></li><li>Ribbon都是调用其他服务的，但方式不同。</li><li>启动类注解不同，Ribbon是@RibbonClient feign的是@EnableFeignClients</li><li>服务指定的位置不同，Ribbon是在@RibbonClient注解上声明，Feign则是在定义抽象方法的接口中使用@FeignClient声明。</li><li>调用方式不同，Ribbon需要自己构建http请求，模拟http请求然后使用RestTemplate发送给其他服务，步骤相当繁琐。Feign需要将调用的方法定义成抽象方法即可。</li></ul><h3 id="熔断和降级" tabindex="-1"><a class="header-anchor" href="#熔断和降级" aria-hidden="true">#</a> 熔断和降级</h3><p>熔断是<mark>下层服务一旦产生故障就断掉</mark>；降级需要<mark>对服务进行分级，把产生故障的服务丢掉，换一个轻量级的方案。</mark></p><h2 id="运维" tabindex="-1"><a class="header-anchor" href="#运维" aria-hidden="true">#</a> 运维</h2><h3 id="分布式、集群和微服务" tabindex="-1"><a class="header-anchor" href="#分布式、集群和微服务" aria-hidden="true">#</a> 分布式、集群和微服务</h3><p><strong>分布式</strong>：通俗意义上来讲，分布式是将一个整体<mark>按照模块拆分分布到不同地方</mark>，<mark>只要一个节点出现问题，则会导致系统出现问题</mark>。</p><p>分布式就是将多台服务器集中在一起，每台服务器都实现总体中的不同业务。每台服务器都缺一不可，如果某台服务器发生宕机了，则部分功能缺失，将导致整体无法运行。</p><p>分布式存在的作用主要是将应用程序的多个功能分配到多个服务器上去处理，细化了应用程序的功能模块，能够减缓服务器的压力，大幅度的提高效率。</p><p>从概念理解，分布式服务架构强调的是<mark>服务化以及服务的分散化</mark>，微服务则更强调<mark>服务的专业化和精细分工</mark>；从实践的角度来看，<mark>微服务架构通常是分布式服务架构</mark>，反之则未必成立。所以，选择微服务通常意味着需要解决分布式架构的各种难题。</p><p><strong>集群</strong>：各个集群上内容都是一致，如果<mark>一个集群出现问题</mark>无法使用，则<mark>其他集群可以顶替</mark>上去。</p><p><strong>集群的特点：</strong></p><p><strong>伸缩性</strong>（Scalability）</p><p>在一些大的系统中，预测最终用户的数量和行为是非常困难的，伸缩性是指系统适应不断增长的用户数的能力。提高这种并发会话能力的一种最直观的方式就增加资源（CPU，内存，硬盘等），集群是解决这个问题的另一种方式，它允许一组服务器组在一起，像单个服务器一样分担处理一个繁重的任务，我们只需要将新的服务器加入集群中即可，对于客户来看，服务无论从连续性还是性能上都几乎没有变化，好像系统在不知不觉中完成了升级</p><p><strong>高可用性</strong>（High availability）</p><p>单一服务器的解决方案并不是一个健壮方式，因为容易出现单点失效。像银行、账单处理这样一些关键的应用程序是不能容忍哪怕是几分钟的死机。它们需要这样一些服务在任何时间都可以访问并在可预期的合理的时间周期内有响应。高可用性集群的出现是为了使集群的整体服务尽可能可用，以便考虑计算硬件和软件的易错性。如果高可用性集群中的主节点发生了故障，那么这段时间内将由次节点代替它。次节点通常是主节点的镜像，所以当它代替主节点时，它可以完全接管其身份，并且因此使系统环境对于用户是一致的。</p><p><strong>负载均衡</strong>（Load balancing）</p><p>负载均衡集群为企业需求提供了更实用的系统。如名称所暗示的，该系统使负载可以在计算机集群中尽可能平均地分摊处理。该负载可能是需要均衡的应用程序处理负载或网络流量负载。这样的系统非常适合于运行同一组应用程序的大量用户。每个节点都可以处理一部分负载，并且可以在节点之间动态分配负载，以实现平衡。</p><p><strong>高性能</strong> (High Performance )</p><p>通常，第一种涉及为集群开发并行编程应用程序，以解决复杂的科学问题。这是并行计算的基础，尽管它不使用专门的并行超级计算机，这种超级计算机内部由十至上万个独立处理器组成。但它却使用商业系统，如通过高速连接来链接的一组单处理器或双处理器 PC，并且在公共消息传递层上进行通信以运行并行应用程序。因此，您会常常听说又有一种便宜的 Linux 超级计算机问世了。但它实际是一个计算机集群，其处理能力与真的超级计算机相等。</p><p><strong>微服务</strong></p><p>微服务是一种架构风格，一个大型复杂软件应用由一个或多个微服务组成。系统中的各个微服务可被独立部署，微服务的应用不一定是分散在多个服务器上，也可以是同一个服务器，各个微服务之间是松耦合的。每个微服务仅关注于完成一件任务并很好地完成该任务。在所有情况下，每个任务代表着一个小的业务能力。</p><p><strong>分布式、集群、微服务的区别</strong></p><p><strong>分布式架构</strong></p><figure><img src="/assets/分布式部署-klcH8b1T.jpg" alt="分布式部署" tabindex="0" loading="lazy"><figcaption>分布式部署</figcaption></figure><p><strong>集群架构</strong></p><figure><img src="/assets/集群部署-SlJNCBSp.jpg" alt="集群部署" tabindex="0" loading="lazy"><figcaption>集群部署</figcaption></figure><ol><li>首先从概念上来看，<strong>集群</strong>就是将<mark>全部的服务器</mark>都集中起来<mark>实现同一种业务</mark>，而分布式是<mark>将一种业务拆分成其他的部分业务并分布在多台服务器上</mark>；</li><li>集群是个物理形态，而分布式只是个工作方式；</li><li>集群一般是物理集中，统一管理的，而分布式则不强调这一点，不管放置在哪个位置，只要通过网络连接起来就行。</li><li><mark>分布式中的每一个节点，都可以做集群</mark>。 而集群并不一定就是分布式的。</li><li><mark>分布式一定是微服务，微服务不一定是分布式</mark>(例如：可以在一个服务器通过不同的端口部署微服务)</li><li>微服务是系统架构的一个设计方式，它是将复杂的业务拆分成多个微小的服，每个服务可单独运行和部署，服务与服务之前一个可以采用RPC来通信。</li><li>分布式是一种系统的部署方式，主要是将同一个服务，拆分成可以去部署到多台机器。</li><li>集群实质是将几台服务器集中在一起，实现同一业务。</li><li>微服务架构是分布式服务架构的子集。</li><li>分布式部署不一定是微服务架构，而微服务的应用也不一定是要采用分布式部署。</li></ol><p>例如，在一个饭店里面，本来饭店里面只有一个厨师，切菜洗菜炒菜这些工作他全干了，后来随着客人的增多，又找了一个厨师，这个厨师也是能炒同样的菜，这两个厨师干的活一样，关系就是集群；</p><p>为了让厨师安心炒菜，把菜做到极致，又给厨师请了个配菜师，主要负责切菜洗菜，那么厨师和配菜师之间的关系就是分布式了。</p></div><!--[--><!----><!--]--><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/tufujie/jef-docx/edit/main/src/home/技术选型/技术栈对比/技术栈对比.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: tufj@hua-cloud.com.cn">tufujie</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><!----><a aria-label="接口和抽象类" class="vp-link nav-link next nav-link next" href="/home/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB.html"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">接口和抽象类<!----></div></a></nav><!----><!--[--><!----><!--]--><!--]--></main><!--]--><footer class="vp-footer-wrapper"><div class="vp-footer"><a href="https://beian.miit.gov.cn/" target="_blank">粤ICP备2023137693号</a></div><div class="vp-copyright">Copyright © 2024 Jef</div></footer></div><!--]--><!----><!----><!--]--></div>
    <script type="module" src="/assets/app-AuAuVshg.js" defer></script>
  </body>
</html>
