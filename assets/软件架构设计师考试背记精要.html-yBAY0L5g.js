import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as e,c as r,d as h}from"./app-AuAuVshg.js";const s="/assets/系统架构设计师69-j3KLYqvs.jpg",n="/assets/系统架构设计师70-hsU9Zuml.jpg",d="/assets/系统架构设计师71-SE2gpUw5.jpg",t="/assets/系统架构设计师72-iEb_Am0i.jpg",i="/assets/系统架构设计师73-GmW5dXo-.jpg",o="/assets/系统架构设计师74-XRgsZ6Ru.jpg",p={},c=h('<h2 id="_4-1-数据流风格" tabindex="-1"><a class="header-anchor" href="#_4-1-数据流风格" aria-hidden="true">#</a> <strong>4.1.数据流风格</strong></h2><p>适合于分阶段做数据处理，交互性差，包括：批处理序列、管理过滤器。</p><h2 id="_4-2-调用-返回风格" tabindex="-1"><a class="header-anchor" href="#_4-2-调用-返回风格" aria-hidden="true">#</a> <strong>4.2.调用/返回风格</strong></h2><p>一般系统都要用到，包括：主程序/子程序，面向对象，层次结构（分层越多，性能越差）。</p><h2 id="_4-3-独立构件风格" tabindex="-1"><a class="header-anchor" href="#_4-3-独立构件风格" aria-hidden="true">#</a> <strong>4.3.独立构件风格</strong></h2><p>构件是独立的过程，连接件是消息传递。包括：进程通信，事件驱动系统（隐式调用）。应用场景，通过事件触发操作。</p><h2 id="_4-4-虚拟机风格" tabindex="-1"><a class="header-anchor" href="#_4-4-虚拟机风格" aria-hidden="true">#</a> <strong>4.4.虚拟机风格</strong></h2><p>包括解释器与基于规则的系统，有自定义场景时使用该风格。</p><h2 id="_4-5-仓库风格-以数据为中心的风格" tabindex="-1"><a class="header-anchor" href="#_4-5-仓库风格-以数据为中心的风格" aria-hidden="true">#</a> <strong>4.5.仓库风格（以数据为中心的风格）</strong></h2><p>以共享数据源为中心，其它构件围绕中心进行处理。包括：数据库系统、黑板系统（语言处理，信号处理），超文本系统。</p><h2 id="_4-6-闭环控制架构-过程控制" tabindex="-1"><a class="header-anchor" href="#_4-6-闭环控制架构-过程控制" aria-hidden="true">#</a> <strong>4.6.闭环控制架构（过程控制）</strong></h2><p>定速巡航，空调温控。</p><h2 id="_4-7-mvc" tabindex="-1"><a class="header-anchor" href="#_4-7-mvc" aria-hidden="true">#</a> <strong>4.7.MVC</strong></h2><p>视图（JSP），控制器（Servlet），模型（EJB）。</p><h2 id="_4-8-soa" tabindex="-1"><a class="header-anchor" href="#_4-8-soa" aria-hidden="true">#</a> <strong>4.8.SOA</strong></h2><p>粗粒度，松耦合，标准化。Webservice 与 ESB 是 SOA 的实现技术。</p><h2 id="_4-9-esb" tabindex="-1"><a class="header-anchor" href="#_4-9-esb" aria-hidden="true">#</a> <strong>4.9.ESB</strong></h2><p>位置透明性、消息路由、服务注册命名、消息转换、多传输协议、日志与监控。</p><h2 id="_4-10-rest-的-5-大原则" tabindex="-1"><a class="header-anchor" href="#_4-10-rest-的-5-大原则" aria-hidden="true">#</a> <strong>4.10.REST 的 5 大原则</strong></h2><p>所有事物抽象为资源、资源唯一标识、通过接口操作资源、操作不改变资源标识、操作无状态。</p><h2 id="_4-11-微服务特点" tabindex="-1"><a class="header-anchor" href="#_4-11-微服务特点" aria-hidden="true">#</a> <strong>4.11.微服务特点</strong></h2><p>小, 且专注于做一件事情；轻量级的通信机制；松耦合、独立部署。</p><h2 id="_4-12-微服务优势" tabindex="-1"><a class="header-anchor" href="#_4-12-微服务优势" aria-hidden="true">#</a> <strong>4.12.微服务优势</strong></h2><p>技术异构性、弹性、扩展、简化部署、与结构相匹配、可组合性、对可替代性的优化。</p><h2 id="_4-13-微服务与-soa-对比" tabindex="-1"><a class="header-anchor" href="#_4-13-微服务与-soa-对比" aria-hidden="true">#</a> <strong>4.13.微服务与 SOA 对比</strong></h2><figure><img src="'+s+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="_4-14-adl-的三个基本元素" tabindex="-1"><a class="header-anchor" href="#_4-14-adl-的三个基本元素" aria-hidden="true">#</a> <strong>4.14.ADL 的三个基本元素</strong></h2><p>构件，连接件，架构配置。</p><h2 id="_4-15-dssa-基本活动" tabindex="-1"><a class="header-anchor" href="#_4-15-dssa-基本活动" aria-hidden="true">#</a> <strong>4.15.DSSA 基本活动</strong></h2><p>领域分析（建立领域模型），领域设计（获得 DSSA），领域实现（开发和组织可复用信息）。</p><h2 id="_4-16-dssa-角色" tabindex="-1"><a class="header-anchor" href="#_4-16-dssa-角色" aria-hidden="true">#</a> <strong>4.16.DSSA 角色</strong></h2><p>领域专家（有经验的用户、分析、设计、实现人员，“给建议”），领域分析人员（有经验的分析师，完成领域模型），领域设计人员（有经验的设计师，完成 DSSA），领域实现人员（有经验的程序员完成代码编写）。</p><h2 id="_4-17-dssa-三层次模型" tabindex="-1"><a class="header-anchor" href="#_4-17-dssa-三层次模型" aria-hidden="true">#</a> <strong>4.17.DSSA 三层次模型</strong></h2><p>领域架构师对应领域开发环境，应用工程师对应领域特定的应用开发环境，操作员对应应用执行环境。</p><h2 id="_4-18-absd-方法" tabindex="-1"><a class="header-anchor" href="#_4-18-absd-方法" aria-hidden="true">#</a> <strong>4.18.ABSD 方法</strong></h2><p>架构驱动，即强调由业务、质量和功能需求的组合驱动架构设计。</p><h2 id="_4-19-absd-方法有三个基础" tabindex="-1"><a class="header-anchor" href="#_4-19-absd-方法有三个基础" aria-hidden="true">#</a> <strong>4.19.ABSD 方法有三个基础</strong></h2><p>功能的分解，通过选择架构风格来实现质量和业务需求，软件模板的使用。</p><h2 id="_4-20-absd-开发过程" tabindex="-1"><a class="header-anchor" href="#_4-20-absd-开发过程" aria-hidden="true">#</a> <strong>4.20.ABSD 开发过程</strong></h2><p>(1) 架构需求（需求获取、生成类图、对类进行分组、打包成构件、需求评审）</p><p>(2) 架构设计（提出架构模型、映射构件、分析构件相互作用，产生架构，设计评审）</p><p>(3) 架构文档化：从使用者角度编写，分发给所有相关开发人员，保证开发者手中版本最新。</p><p>(4) 架构复审：标识潜在的风险，及早发现架构设计中的缺陷和错误。</p><p>(5) 架构实现（复审后的文档化架构，分析与设计，构件实现，构件组装，系统测试）</p><p>(6) 架构演化（需求变化归类，架构演化计划，构件变动，更新构件相互作用，构件组装与测试，技术评审，演化后的架构）</p><h2 id="_4-21-架构评审四大质量属性" tabindex="-1"><a class="header-anchor" href="#_4-21-架构评审四大质量属性" aria-hidden="true">#</a> <strong>4.21.架构评审四大质量属性</strong></h2><p>(1) 性能：代表参数（响应时间、吞吐量），设计策略（优先级队列、资源调度）。</p><p>(2) 可用性：尽可能少的出错与尽快的恢复。代表参数（故障间隔时间，故障修复时间），设计策略（冗余、心跳线）。</p><p>(3) 安全性：破坏机密性、完整性、不可否认性及可控性等特性。设计策略（追踪审计）</p><p>(4) 可修改性：新增功能多少人月能完成，设计策略（信息隐藏，低耦合）</p><h2 id="_4-22-风险点" tabindex="-1"><a class="header-anchor" href="#_4-22-风险点" aria-hidden="true">#</a> <strong>4.22.风险点</strong></h2><p>系统架构风险是指架构设计中潜在的、存在问题的架构决策所带来的隐患。</p><p>非风险点：一般以某种做法，“是可以实现的”、“是可以接受的”方式进行描述。</p><p>敏感点：指为了实现某种特定的质量属性，一个或多个构件所具有的特性。</p><p>权衡点：影响多个质量属性的特性，是多个质量属性的敏感点。</p><h2 id="_4-23-基本场景的评估方法" tabindex="-1"><a class="header-anchor" href="#_4-23-基本场景的评估方法" aria-hidden="true">#</a> <strong>4.23.基本场景的评估方法</strong></h2><p>ATAM，SAAM，CBAM。</p><h2 id="_4-24-架构评估方法" tabindex="-1"><a class="header-anchor" href="#_4-24-架构评估方法" aria-hidden="true">#</a> <strong>4.24.架构评估方法</strong></h2><p>不是代码评估方法，不做测试，不是精确的衡量方法。</p><h2 id="_4-25-atam-四大阶段" tabindex="-1"><a class="header-anchor" href="#_4-25-atam-四大阶段" aria-hidden="true">#</a> <strong>4.25.ATAM 四大阶段</strong></h2><p>场景和需求收集、结构视图场景实现、属性模型构造和分析、折中。</p><h2 id="_4-26-saam-五个步骤" tabindex="-1"><a class="header-anchor" href="#_4-26-saam-五个步骤" aria-hidden="true">#</a> <strong>4.26.SAAM 五个步骤</strong></h2><p>即场景开发、体系结构描述、单个场景评估、场景交互和总体评估。</p><h2 id="_4-27-产品线技术应用场景" tabindex="-1"><a class="header-anchor" href="#_4-27-产品线技术应用场景" aria-hidden="true">#</a> <strong>4.27.产品线技术应用场景</strong></h2><p>有多年行业开发经验，做过多个同类产品。</p><h2 id="_4-28-建立产品线的四种方式" tabindex="-1"><a class="header-anchor" href="#_4-28-建立产品线的四种方式" aria-hidden="true">#</a> <strong>4.28.建立产品线的四种方式</strong></h2><p>基于现有产品演化式（风险最低），基于现有产品革命式，全新产品线演化式，全新产品线革命式（风险最高）。</p><h2 id="_4-29-产品线实施成功的决定因素" tabindex="-1"><a class="header-anchor" href="#_4-29-产品线实施成功的决定因素" aria-hidden="true">#</a> <strong>4.29.产品线实施成功的决定因素</strong></h2><p>对该领域具备长期和深厚的经验；一个用于构建产品的好的核心资源库；好的产品线架构；好的管理（软件资源、人员组织、过程）支持。</p><h2 id="_4-30-构件、对象、模块的对比" tabindex="-1"><a class="header-anchor" href="#_4-30-构件、对象、模块的对比" aria-hidden="true">#</a> <strong>4.30.构件、对象、模块的对比</strong></h2><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="_4-31-构件系统架构" tabindex="-1"><a class="header-anchor" href="#_4-31-构件系统架构" aria-hidden="true">#</a> <strong>4.31.构件系统架构</strong></h2><p>构件系统体系结构由一组平台决策、一组构件框架和构件框架之间的互操作设计组成。</p><h2 id="_4-32-构件的复用" tabindex="-1"><a class="header-anchor" href="#_4-32-构件的复用" aria-hidden="true">#</a> <strong>4.32.构件的复用</strong></h2><p>（1）检索与提取构件；（2）理解与评价构件；（3）修改构件；（4）组装构件。</p><h2 id="_4-33-在构件组装阶段失配问题" tabindex="-1"><a class="header-anchor" href="#_4-33-在构件组装阶段失配问题" aria-hidden="true">#</a> <strong>4.33.在构件组装阶段失配问题</strong></h2><p>由构件引起的失配；由连接子引起的失配；由于系统成分对全局体系结构的假设存在冲突引起的失配等。</p><h2 id="_4-34-中间件" tabindex="-1"><a class="header-anchor" href="#_4-34-中间件" aria-hidden="true">#</a> <strong>4.34.中间件</strong></h2><p>中间件是一种独立的系统软件或服务程序，可以帮助分布式应用软件在不同的技术之间共享资源。</p><h2 id="_4-35-中间件功能" tabindex="-1"><a class="header-anchor" href="#_4-35-中间件功能" aria-hidden="true">#</a> <strong>4.35.中间件功能</strong></h2><p>客户机与服务器之间的连接和通信，客户机与应用层之间的高效率通信；应用层不同服务之间的互操作，应用层与数据库之间的连接和控制；多层架构的应用开发和运行的平台，应用开发框架，模块化的应用开发；屏蔽硬件、操作系统、网络和数据库的差异；应用的负载均衡和高可用性、安全机制与管理功能，交易管理机制，保证交易的一致性、一组通用的服务去执行不同的功能，避免重复的工作和使应用之间可以协作。</p><h2 id="_4-36-采用中间件技术的优点" tabindex="-1"><a class="header-anchor" href="#_4-36-采用中间件技术的优点" aria-hidden="true">#</a> <strong>4.36.采用中间件技术的优点</strong></h2><p>面向需求；业务的分隔和包容性；设计与实现隔离；隔离复杂的系统资源；符合标准的交互模型；软件复用；提供对应用构件的管理。</p><h2 id="_4-37-主要的中间件" tabindex="-1"><a class="header-anchor" href="#_4-37-主要的中间件" aria-hidden="true">#</a> <strong>4.37.主要的中间件</strong></h2><p>远程过程调用；对象请求代理；远程方法调用；面向消息的中间件；事务处理监控器。</p><h2 id="_4-38-中间件技术-corba-公共对象请求代理体系结构-代理模式" tabindex="-1"><a class="header-anchor" href="#_4-38-中间件技术-corba-公共对象请求代理体系结构-代理模式" aria-hidden="true">#</a> <strong>4.38.中间件技术-Corba(公共对象请求代理体系结构)（代理模式）</strong></h2><p><img src="'+d+'" alt="" loading="lazy"><img src="'+t+'" alt="" loading="lazy"></p><h2 id="_4-39-典型应用架构-j2ee" tabindex="-1"><a class="header-anchor" href="#_4-39-典型应用架构-j2ee" aria-hidden="true">#</a> <strong>4.39.典型应用架构--J2EE</strong></h2><figure><img src="'+i+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="_4-40-bean-的分类" tabindex="-1"><a class="header-anchor" href="#_4-40-bean-的分类" aria-hidden="true">#</a> <strong>4.40.Bean 的分类</strong></h2><p>会话 Bean：描述了与客户端的一个短暂的会话。</p><p>实体 Bean：持久化数据，O/R 映射。</p><p>消息驱动 Bean：会话 Bean+JMS，客户把消息发送给 JMS 目的地，然后，JMS 提供者和 EJB 容器协作，把消息发送给消息驱动 Bean。支持异步消息。</p><h2 id="_4-41-重量级与轻量级区别" tabindex="-1"><a class="header-anchor" href="#_4-41-重量级与轻量级区别" aria-hidden="true">#</a> <strong>4.41.重量级与轻量级区别</strong></h2><p>重量级：占用资源过多，在开发的过程中效率很低；大部分时间花在配置、运行的过程上，修改复杂；单元测试也比较麻烦。</p><p>轻量级：提高了开发的速度；立即可以看到结果；做单元测试也非常简单；大量现成可供参考的开源代码。</p><h2 id="_4-42-典型应用架构-net" tabindex="-1"><a class="header-anchor" href="#_4-42-典型应用架构-net" aria-hidden="true">#</a> <strong>4.42.典型应用架构--.Net</strong></h2><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="_4-43-web-设计维度" tabindex="-1"><a class="header-anchor" href="#_4-43-web-设计维度" aria-hidden="true">#</a> <strong>4.43.WEB 设计维度</strong></h2><p>从架构来看：MVC，MVP，MVVM，REST，Webservice，微服务。</p><p>从缓存来看：MemCache，Redis，Squid。</p><p>从并发分流来看：集群（负载均衡）、CDN。</p><p>从数据库来看：主从库（主从复制），内存数据库，反规范化技术，NoSQL，分区（分表）技术，视图与物化视图。</p><p>从持久化来看：Hibernate，Mybatis。</p><p>从分布存储来看：Hadoop，FastDFS，区块链。</p><p>从数据编码看： XML，JSON。</p><p>从 Web 应用服务器来看： Apache，WebSphere，WebLogic，Tomcat，JBOSS，IIS。</p><p>其它：静态化，有状态与无状态，响应式 Web 设计。</p><h2 id="_4-44-集群" tabindex="-1"><a class="header-anchor" href="#_4-44-集群" aria-hidden="true">#</a> <strong>4.44.集群</strong></h2><p>（1）应用服务器集群；（2）主从集群。</p><h2 id="_4-45-负载均衡技术" tabindex="-1"><a class="header-anchor" href="#_4-45-负载均衡技术" aria-hidden="true">#</a> <strong>4.45.负载均衡技术</strong></h2><p>（1）应用层负载均衡：http 重定向、反向代理服务器；（2）传输层负载均衡：DNS 域名解析负载均衡、基于 NAT 的负载均衡；（3）硬件负载均衡：F5；（4）软件负载均衡：LVS、Nginx、HAproxy。</p><h2 id="_4-46-有状态和无状态" tabindex="-1"><a class="header-anchor" href="#_4-46-有状态和无状态" aria-hidden="true">#</a> <strong>4.46.有状态和无状态</strong></h2><p>无状态服务（stateless service）对单次请求的处理，不依赖其他请求，也就是说，处理一次请求所需的全部信息，要么都包含在这个请求里，要么可以从外部获取到（比如说数据库），服务器本身不存储任何信息。</p><p>有状态服务（stateful service）则相反，它会在自身保存一些数据，先后的请求是有关联的。</p><h2 id="_4-47-xml-与-json" tabindex="-1"><a class="header-anchor" href="#_4-47-xml-与-json" aria-hidden="true">#</a> <strong>4.47.XML 与 JSON</strong></h2><p>(1) XML 用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。优点：格式统一，符合标准；容易与其他系统进行远程交互，数据共享比较方便。缺点 XML 文件庞大，文件格式复杂，传输占带宽；服务器端和客户端都需要花费大量代码来解析 XML，导致服务器端和客户端代码变得异常复杂且不易维护；客户端不同浏览器之间解析 XML 的方式不一致，需要重复编写很多代码；服务器端和客户端解析 XML花费较多的资源和时间。</p><p>(2) JSON 一种轻量级的数据交换格式，具有良好的可读和便于快速编写的特性。可在不同平台之间进行数据交换。优点：数据格式比较简单，易于读写，格式都是压缩的，占用带宽小；易于解析，客户端 JavaScript 可以简单的通过 eval()进行 JSON数据的读取；支持多种语言，包括 ActionScript, C, C#, ColdFusion, Java, JavaScript, Perl, PHP, Python, Ruby 等服务器端语言，便于服务器端的解析；因为 JSON 格式能直接为服务器端代码使用，大大简化了服务器端和客户端的代码开发量，且完成任务不变，并且易于维护。缺点：没有 XML 格式这么推广的深入人心和喜用广泛，没有 XML 那么通用性。</p><h2 id="_4-48-缓冲-redis-和-memcache-对比" tabindex="-1"><a class="header-anchor" href="#_4-48-缓冲-redis-和-memcache-对比" aria-hidden="true">#</a> <strong>4.48.缓冲 Redis 和 Memcache 对比</strong></h2><p>(1) Redis 和 Memcache 都是将数据存放在内存中，都是内存数据库。他们都支持 key-value 数据类型。同时 Memcache还可用于缓存其他东西，例如图片、视频等等，Redis 还支持 list、set、hash 等数据结构的存储。</p><p>(2) Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。Memcache 挂掉之后，数据就没了。</p><p>(3) 灾难恢复-Memcache 挂掉后，数据不可恢复; Redis 数据丢失后可以恢复。</p><p>(4) 在 Redis 中，并不是所有的数据都一直存储在内存中的。这是和 Memcache 相比一个最大的区别。当物理内存用完时，Redis 可以将一些很久没用到的 value 交换到磁盘。</p><p>(5) Redis 在很多方面支持数据库的特性，可以这样说他就是一个数据库系统，而 Memcache 只是简单地 K/V 缓存。所以在选择方面如果有持久方面的需求或对数据类型和处理有要求的应该选择 Redis。</p><p>(6) 如果简单的 key/value 存储应该选择 Memcache。</p><h2 id="_4-49-rest-概念" tabindex="-1"><a class="header-anchor" href="#_4-49-rest-概念" aria-hidden="true">#</a> <strong>4.49.REST 概念</strong></h2><p>REST（Representational State Transfer，表述性状态转移）是一种只使用 HTTP 和 XML 进行基于 Web技术，可以降低开发的复杂性，提高系统的可伸缩性。</p><h2 id="_4-50-rest-的五个原则" tabindex="-1"><a class="header-anchor" href="#_4-50-rest-的五个原则" aria-hidden="true">#</a> <strong>4.50.REST 的五个原则</strong></h2><p>网络上的所有事物都被抽象为资源；每个资源对应一个唯一的资源标识；通过通用的连接件接口对</p><p>行操作；对资源的各种操作不会改变资源标识；所有的操作都是无状态的。</p><h2 id="_4-51-响应式-web-设计" tabindex="-1"><a class="header-anchor" href="#_4-51-响应式-web-设计" aria-hidden="true">#</a> <strong>4.51.响应式 Web 设计</strong></h2><p>响应式 WEB 设计是一种网络页面设计布局，其理念是：集中创建页面的图片排版大小，可以智能地根据用户行为以及使用的设备环境进行相对应的布局。方法：采用流式布局和弹性化设计、响应式图片。</p><h2 id="_4-52-业务中台和数据中台区分" tabindex="-1"><a class="header-anchor" href="#_4-52-业务中台和数据中台区分" aria-hidden="true">#</a> <strong>4.52.业务中台和数据中台区分</strong></h2><p>(1) 多个电商渠道使用一个下单服务，一个订单接口同时为多个前台系统提供服务，这是业务中台提供的能力。</p><p>(2) 多个前台系统，根据一个用户的手机号，获取对应的画像，用户的标签，这是数据中台提供的服务。</p><p>(3) 将多个支付通道，抽象建立成一个支付 API，暴露给前台业务系统，这是业务中台提供的能力。</p><p>(4) 通过一个订单编号，来获取可能的商品推荐清单，从而做到交叉销售，这是数据中台提供的服务。</p><h2 id="_4-53-mda-model-driven-architecture" tabindex="-1"><a class="header-anchor" href="#_4-53-mda-model-driven-architecture" aria-hidden="true">#</a> <strong>4.53.MDA(Model Driven Architecture)</strong></h2><p>Model-客观事物的抽象表示；Architecture-构成系统的部件、连接件及其约束的规约；Model-Driven-使用模型完成软件的分析、设计、构建、部署、维护等各开发活动。</p>',139),_=[c];function g(l,b){return e(),r("div",null,_)}const x=a(p,[["render",g],["__file","软件架构设计师考试背记精要.html.vue"]]);export{x as default};
