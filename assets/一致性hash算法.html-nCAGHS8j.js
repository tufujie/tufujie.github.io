const e=JSON.parse('{"key":"v-1f50a932","path":"/home/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95.html","title":"一致性hash算法","lang":"zh-CN","frontmatter":{"title":"一致性hash算法","description":"下边我们以分布式缓存中经典场景举例，看看什么是一致性hash算法以及它有那些过人之处。 构建场景 假如我们有三台缓存服务器编号node0、node1、node2，现在有3000万个key，希望可以将这些个key均匀的缓存到三台机器上，你会想到什么方案呢？ 我们可能首先想到的方案，是取模算法hash（key）% N，对key进行hash运算后取模，N是机器的数量。key进行hash后的结果对3取模，得到的结果一定是0、1或者2，正好对应服务器node0、node1、node2，存取数据直接找对应的服务器即可，简单粗暴，完全可以解决上述的问题。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/home/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"Jef Blog"}],["meta",{"property":"og:title","content":"一致性hash算法"}],["meta",{"property":"og:description","content":"下边我们以分布式缓存中经典场景举例，看看什么是一致性hash算法以及它有那些过人之处。 构建场景 假如我们有三台缓存服务器编号node0、node1、node2，现在有3000万个key，希望可以将这些个key均匀的缓存到三台机器上，你会想到什么方案呢？ 我们可能首先想到的方案，是取模算法hash（key）% N，对key进行hash运算后取模，N是机器的数量。key进行hash后的结果对3取模，得到的结果一定是0、1或者2，正好对应服务器node0、node1、node2，存取数据直接找对应的服务器即可，简单粗暴，完全可以解决上述的问题。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://mister-hope.github.io/"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-01-28T12:29:12.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"一致性hash算法"}],["meta",{"property":"article:author","content":"Jef"}],["meta",{"property":"article:modified_time","content":"2024-01-28T12:29:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"一致性hash算法\\",\\"image\\":[\\"https://mister-hope.github.io/\\"],\\"dateModified\\":\\"2024-01-28T12:29:12.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Jef\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"构建场景","slug":"构建场景","link":"#构建场景","children":[]},{"level":2,"title":"hash的问题","slug":"hash的问题","link":"#hash的问题","children":[]},{"level":2,"title":"一致性hash","slug":"一致性hash","link":"#一致性hash","children":[]},{"level":2,"title":"一致性hash的优势","slug":"一致性hash的优势","link":"#一致性hash的优势","children":[]},{"level":2,"title":"数据偏斜问题","slug":"数据偏斜问题","link":"#数据偏斜问题","children":[]},{"level":2,"title":"一致性hash的应用场景","slug":"一致性hash的应用场景","link":"#一致性hash的应用场景","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1706186859000,"updatedTime":1706444952000,"contributors":[{"name":"tufujie","email":"jef.tu@foxmail.com","commits":1},{"name":"tufujie","email":"tufj@hua-cloud.com.cn","commits":1}]},"readingTime":{"minutes":7.95,"words":2385},"filePathRelative":"home/分布式/一致性hash算法.md","localizedDate":"2024年1月25日","excerpt":"<p>下边我们以分布式缓存中经典场景举例，看看什么是一致性hash算法以及它有那些过人之处。</p>\\n<figure><figcaption></figcaption></figure>\\n<h2> <strong>构建场景</strong></h2>\\n<p>假如我们有三台缓存服务器编号node0、node1、node2，现在有3000万个key，希望可以将这些个key均匀的缓存到三台机器上，你会想到什么方案呢？</p>\\n<p>我们可能首先想到的方案，是取模算法hash（key）% N，对key进行hash运算后取模，N是机器的数量。key进行hash后的结果对3取模，得到的结果一定是0、1或者2，正好对应服务器node0、node1、node2，存取数据直接找对应的服务器即可，简单粗暴，完全可以解决上述的问题。</p>","autoDesc":true}');export{e as data};
