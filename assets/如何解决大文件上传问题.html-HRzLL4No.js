import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as r,d as t}from"./app-AuAuVshg.js";const _={},d=t('<p>对于大文件的处理，无论是用户端还是服务端，如果一次性进行读取发送、接收都是不可取，很容易导致内存问题。所以对于大文件上传，采用切块分段上传。从上传的效率来看，利用多线程并发上传能够达到最大效率。</p><h2 id="分片" tabindex="-1"><a class="header-anchor" href="#分片" aria-hidden="true">#</a> 分片</h2><p>如何分片？</p><p>如何分，利用强大的js库，来减轻我们的工作，选择百度的WebUploader来实现前端所需。</p><h2 id="合并成一个文件" tabindex="-1"><a class="header-anchor" href="#合并成一个文件" aria-hidden="true">#</a> 合并成一个文件</h2><p>如何合并成一个文件？</p><p>如何合，在合之前，我们还得先解决一个问题，我们如何区分分块所属那个文件的。采用了Md5来维护分块和文件关系。</p><p>在服务端合并文件，和记录分块的问题，在这方面其实行业已经给了很好的解决方案了。参考迅雷，你会发现，每次下载中的时候，都会有两个文件，一个文件主体，另外一个就是文件临时文件，临时文件存储着每个分块对应字节位的状态。</p><h2 id="中断续传" tabindex="-1"><a class="header-anchor" href="#中断续传" aria-hidden="true">#</a> 中断续传</h2><p>中断了从哪个分片开始？</p><p>这些都是需要前后端密切联系才能做好，前端需要根据固定大小对文件进行分片，并且请求中要带上分片序号和大小。前端发送请求顺利到达后台后，服务器只需要按照请求数据中给的分片序号和每片分块大小（分片大小是固定且一样的）算出开始位置，与读取到的文件片段数据，写入文件即可。</p>',11),c=[d];function h(n,o){return a(),r("div",null,c)}const s=e(_,[["render",h],["__file","如何解决大文件上传问题.html.vue"]]);export{s as default};
