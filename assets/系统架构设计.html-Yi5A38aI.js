import{_ as i}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as l,c as p,d as a}from"./app-AuAuVshg.js";const r={},e=a('<h2 id="架构基础" tabindex="-1"><a class="header-anchor" href="#架构基础" aria-hidden="true">#</a> 架构基础</h2><ul><li><p>系统泛指由一群有关联的个体组成，根据某种规则运作，能完成个别元件不能单独完成的工作的群体，它的意思是&quot;总体&quot;&quot;整体&quot;或&quot;联盟&quot;。</p></li><li><p>子系统也是由一群有关联的个体所组成的系统，多半是更大系统中的一部分。</p></li><li><p>软件模块（Module）是一套一致而互相紧密关联的软件组织。它分别包含了程序和数据结构两部分。</p></li><li><p>软件组件定义为自包含的、可编程的、可重用的、与语言无关的软件单元，软件组件可以很容易被用于组装应用程序中。</p></li><li><p>软件框架（Software Framework），通常指的是为了实现某个业界标准或完成特定基本任务的软件组件规范，也指为了实现某个软件组件规范时，提供规范所要求之基础功能的软件产品。</p></li><li><p>软件架构指软件系统的顶层结构。</p></li><li><p>同一软件系统从不同的角度进行分解，会得到不同的架构。</p></li><li><p>架构设计的主要目的是为了解决软件系统复杂度带来的问题。</p></li><li><p>主要的软件系统复杂度有<strong>高性能、高可用、可扩展、低成本、安全、规模</strong>几种。</p></li></ul><h2 id="架构设计原则" tabindex="-1"><a class="header-anchor" href="#架构设计原则" aria-hidden="true">#</a> 架构设计原则</h2><ul><li><p>架构设计原则1：<mark>合适</mark>原则，合适的架构优于业界领先的架构。</p></li><li><p>真正优秀的架构都是在企业当前人力、条件、业务等各种约束下设计出来的，能够合理地将资源整合在一起并发挥出最大功效，并且能够快速落地。</p></li><li><p>架构设计原则2：<mark>简单</mark>原则，简单的架构优于复杂的架构。</p></li><li><p>软件领域的复杂性体现在两方面：结构的复杂性、逻辑的复杂性。</p></li><li><p>架构设计原则3：<mark>演化</mark>原则，架构需要随着业务的发展而不断演化。</p></li><li><p>对于建筑来说，永恒是主题；而对于软件来说，变化才是主题。</p></li><li><p>软件架构设计类似于生物演化。</p></li></ul><h2 id="架构设计流程" tabindex="-1"><a class="header-anchor" href="#架构设计流程" aria-hidden="true">#</a> 架构设计流程</h2><ul><li><p>设计架构的时候，首先要分析出系统的复杂性。</p></li><li><p>架构师根据自己对业务的理解，挑选合适的架构模式进行组合，再对组合后的方案进行修改和调整。</p></li><li><p>新技术都是在现有技术的基础上发展起来的，现有技术又来源于先前的技术。</p></li><li><p>备选方案的数量以3~5个备选方案为最佳。</p></li><li><p>备选方案的差异要比较明显。</p></li><li><p>备选方案的技术不要只局限于己经熟悉的技术。</p></li><li><p>通过360度环评的方式来评估备选方案。</p></li><li><p>按照质量属性的优先级来判断备选方案的优劣。</p></li><li><p>架构师需要对技术的细节和原理有较深入的理解，避免成为&quot;PPT架构师&quot;。</p></li><li><p>通过分步骤、分阶段、分系统等方式，尽量降低方案复杂度。</p></li><li><p>采取设计团队的方式来进行设计，可以博采众长，汇集团队经验，减少思维和经验盲区。</p></li></ul><h2 id="存储高性能" tabindex="-1"><a class="header-anchor" href="#存储高性能" aria-hidden="true">#</a> 存储高性能</h2><ul><li><p>高性能数据库集群的第一种方式是&quot;<mark>读写分离</mark>&quot;，其本质是主从同步，将访问压力分散到集群中的多个节点，但是没有分散存储压力。</p></li><li><p>数据库读写分离需要考虑&quot;复制延迟&quot;带来的复杂性。</p></li><li><p>数据库读写分离的分配机制有两种实现方式：程序代码封装和中间件封装。</p></li><li><p>高性能数据库集群的第二种方式是&quot;<mark>分库分表</mark>&quot;，既可以分散访问压力，又可以分散存储压力。</p></li><li><p>业务分库指的是按照业务模块将数据分散到不同的数据库服务器。</p></li><li><p>业务分库会引入join操作问题、事务问题、成本问题三个复杂度相关的问题。</p></li><li><p>数据库分表分为垂直分表和水平分表。</p></li><li><p>垂直分表引入的复杂性主要体现在表操作的数量要增加。</p></li><li><p>水平分表引入了路由、join操作、count()操作、order by操作等复杂度问题。</p></li><li><p><mark>引入NoSQL</mark>，K-V存储在数据结构方面相比关系型数据库具备较大的优势。</p></li><li><p>文档数据库最大的特点就是no-schema，可以存储和读取任意的数据。</p></li><li><p>列式存储在某些场景下能够大大节省I/O。</p></li><li><p>列式存储具备很高的压缩比，能够节省存储空间。</p></li><li><p>全文搜索引擎的基本原理是倒排索引。</p></li><li><p>为了让全文搜索引擎支持关系型数据的全文搜索，需要做一些转换操作，即将关系型数据转换为文档数据。</p></li><li><p>缓存穿透是指当业务系统查询的数据在存储系统中没有的时候，每次查询都会访问存储系统。</p></li><li><p>缓存雪崩是指当缓存失效（过期）后引起系统性能急剧下降的情况。</p></li><li><p>缓存热点指大部分甚至所有业务请求都命中同一份缓存数据。</p></li></ul><h2 id="计算高性能" tabindex="-1"><a class="header-anchor" href="#计算高性能" aria-hidden="true">#</a> 计算高性能</h2><ul><li><p>PPC模型：每次有新的连接就新建一个进程去专门处理这个连接的请求。</p></li><li><p>TPC模型：每次有新的连接就新建一个线程去专门处理这个连接的请求。</p></li><li><p>Reactor模型的基础是I/O多路复用。</p></li><li><p>Proactor模型是非阻塞异步网络模式。</p></li><li><p>常见的<mark>负载均衡</mark>系统有3种：<mark>DNS负载均衡、硬件负载均衡和软件负载均衡</mark>。</p></li><li><p>DNS是最简单的也是最常见的负载均衡方式，一般用来实现地理级别的均衡。</p></li><li><p>硬件负载均衡用于实现集群级别的负载均衡。</p></li><li><p>软件负载均衡用于实现机器级别的负载均衡。</p></li><li><p>负载均衡算法分为：任务平分类、负载均衡类、性能最优类和Hash类。</p></li><li><p>CDN。</p></li><li><p>消息队列。</p></li></ul><h2 id="cap" tabindex="-1"><a class="header-anchor" href="#cap" aria-hidden="true">#</a> CAP</h2><ul><li><p>CAP理论三个核心要素：一致性、可用性和分区容忍性。</p></li><li><p>CAP理论指分布式系统中涉及读写操作时，一致性、可用性、分区容忍性三个要素能保证两个，另外一个必须被牺牲。</p></li><li><p>分布式系统理论上不可能选择CA架构，只能选择CP或AP架构。</p></li><li><p>CAP关注的粒度是数据，而不是整个系统。</p></li><li><p>CAP是忽略网络延迟的。</p></li><li><p>正常运行情况下，不存在CP和AP的选择，可以同时满足CA。</p></li><li><p>CAP中放弃某个要素并不等于什么都不做，需要为分区恢复后做准备。</p></li><li><p>ACID的应用场景是数据库事务，CAP关注的是分布式系统数据读写。</p></li><li><p>BASE是CAP理论中AP的延伸。</p></li></ul><h2 id="fmea" tabindex="-1"><a class="header-anchor" href="#fmea" aria-hidden="true">#</a> FMEA</h2><ul><li><p>FMEA是一种在各行各业都有广泛应用的可用性分析方法，通过对系统范围内潜在的故障模式加以分析，并按照严重程度进行分类，以确定失效对于系统的最终影响。</p></li><li><p>FMEA分析方法很简单，就是一个FMEA分析表。</p></li><li><p>FMEA分析中的&quot;功能点&quot;是从用户的角度来看的，而不是从系统各个模块功能点划分来看的。</p></li><li><p>FMEA分析中的&quot;故障模式&quot;的描述要尽量精确，多使用量化描述，避免使用泛化的描述。</p></li><li><p>FMEA分析中的&quot;严重程序&quot;指站在业务的角度，故障的影响程度一般分为&quot;致命／高/中／低／无&quot;五个档次。</p></li><li><p>FMEA分析中不同的&quot;故障原因&quot;发生概率、检测手段和处理措施可能不同。</p></li><li><p>FMEA分析中的&quot;风险程度&quot;就是综合严重程度和故障概率来一起判断某个故障的最终等级。</p></li><li><p>FMEA分析中不一定所有的问题都要解决，采取规避措施也可以。</p></li></ul><h2 id="存储高可用" tabindex="-1"><a class="header-anchor" href="#存储高可用" aria-hidden="true">#</a> 存储高可用</h2><ul><li><p><mark>主备架构</mark>中的&quot;备机&quot;主要还是起一个备份作用，并不承担实际的业务读写操作。</p></li><li><p>主从架构中的主机负责读写操作，从机只负责读操作，不负责写操作。</p></li><li><p>主备倒换和主从倒换架构的复杂点主要体现在：状态判断、倒换决策和数据冲突修复三方面。</p></li><li><p>主主复制架构必须保证数据能够双向复制，而很多数据是不能双向复制的。</p></li><li><p>根据<mark>集群</mark>中机器承担的不同角色来划分，集群可以分为两类：数据集中集群、数据分散集群。</p></li><li><p>数据集中集群可以看作一主多备或一主多从，但复杂度比主备或主从要高出很多。</p></li><li><p>数据分散集群中每台服务器都会负责存储一部分数据，同时也会备份一部分数据。</p></li><li><p>数据分区主要应对地理级别的故障。</p></li><li><p>数据分区的复制规则分为集中式、互备式和独立式。</p></li></ul><h2 id="计算高可用" tabindex="-1"><a class="header-anchor" href="#计算高可用" aria-hidden="true">#</a> 计算高可用</h2><ul><li><p>主备架构是计算高可用最简单的架构，可以细分为冷备架构和温备架构，常用<mark>温备架构</mark>。</p></li><li><p>计算高可用的主备架构也比较适合于内部管理系统、后台管理系统这类使用人数不多、使用频率不高的业务，不太适合在线的业务。</p></li><li><p>主从架构与主备架构相比，发挥了硬件的性能，但设计要复杂一些。</p></li><li><p>高可用计算的集群根据集群中服务器节点角色的不同，可以分为对称集群和非对称集群。</p></li><li><p>对称集群中每个服务器的角色都是一样的，都可以执行所有任务。</p></li><li><p>非对称集群中的服务器分为多个不同的角色，不同角色执行不同的任务。</p></li><li><p>非对称集群相比负载均衡集群，设计复杂度主要体现在任务分配策略和角色分配策略会更加复杂。</p></li></ul><h2 id="业务高可用" tabindex="-1"><a class="header-anchor" href="#业务高可用" aria-hidden="true">#</a> 业务高可用</h2><ul><li><p>异地多活架构的关键点就是异地、多活，其中异地就是指地理位置上不同的地方，多活就是指不同地理位置上的系统都能够提供业务服务。是灾备的重要手段。</p></li><li><p>异地多活虽然功能很强大，但也不是每个业务不管三七十一都要上异地多活。</p></li><li><p>如果业务规模很大，能够做异地多活的情况下尽量实现异地多活。</p></li><li><p><mark>异地多活</mark>架构可以分为<mark>同城异区、跨城异地、跨国异地</mark>。</p></li><li><p>同城异区指的是将业务部署在同一个城市不同区的多个机房。</p></li><li><p>同城异区的两个机房能够实现和同一个机房内几乎一样的网络传输速度，这就意味着虽然是两个不同地理位置上的机房，但逻辑上我们可以将它们看作同一个机房。</p></li><li><p>跨城异地指的是业务部署在不同城市的多个机房，而且距离最好要远一些。</p></li><li><p>跨城异地距离较远带来的网络传输延迟问题，给业务多活架构设计带来了复杂性。</p></li><li><p>跨国异地指的是业务部署在不同国家的多个机房。</p></li><li><p>跨国异地主要适应两种场景：为不同地区的用户提供服务，为全球用户提供只读服务。</p></li><li><p>异地多活设计技巧一：保证核心业务的异地多活。</p></li><li><p>异地多活设计技巧二：保证核心数据最终一致性。</p></li><li><p>异地多活设计技巧三：采用多种手段同步数据。</p></li><li><p>异地多活设计技巧四：只保证绝大部分用户的异地多活。</p></li><li><p>接口级故障的主要应对方案：<mark>降级、熔断、限流、排队</mark>。</p></li><li><p>降级的核心思想就是丢车保帅，优先保证核心业务。</p></li><li><p>限流指只允许系统能够承受的用户量进来访问，超出系统访问能力的用户将被抛弃。</p></li><li><p>排队实际上是限流的一个变种，限流是直接拒绝用户，排队是让用户等待很长时间。</p></li><li><p>超时和重试机制设置。</p></li><li><p>异步调用。</p></li><li><p>使用缓存。</p></li><li><p><mark>回滚机制</mark>。</p></li><li><p>注重代码质量，测试严格把关。</p></li></ul><h2 id="可扩展模式" tabindex="-1"><a class="header-anchor" href="#可扩展模式" aria-hidden="true">#</a> 可扩展模式</h2><ul><li><p>软件系统与硬件和建筑系统最大的差异在于软件是可扩展的。</p></li><li><p>真正有生命力的软件系统都是在不断迭代和发展的。</p></li><li><p>所有的可扩展性架构设计，背后的基本思想都可以总结为一个字：拆。</p></li><li><p>拆分软件系统的方式有三种：面向流程拆分、面向服务拆分和面向功能拆分。</p></li><li><p>不同的拆分方式将得到不同的系统架构。</p></li></ul><h2 id="分层架构" tabindex="-1"><a class="header-anchor" href="#分层架构" aria-hidden="true">#</a> 分层架构</h2><ul><li><p>分层架构是很常见的架构模式，也叫N层架构，通常情况下，N至少是2层，一般不超过5层。</p></li><li><p>C/S架构、B/S架构划分的对象是整个业务系统，划分的维度是用户交互。</p></li><li><p>MVC架构、MVP架构划分的对象是单个业务子系统，划分的维度是职责，将不同的职责划分到独立层。</p></li><li><p>逻辑分层架构划分的对象可以是单个业务子系统，也可以是整个业务系统，划分的维度也是职责。</p></li><li><p>无论采取何种分层维度，分层架构设计最核心的一点就是需要保证各层之间的差异足够清晰，边界足够明显。</p></li><li><p>分层架构之所以能够较好地支撑系统扩展，本质在于：隔离关注点。</p></li><li><p>分层结构的一个特点就是层层传递。</p></li><li><p>分层架构一个典型的缺点就是性能。</p></li></ul><h2 id="soa架构" tabindex="-1"><a class="header-anchor" href="#soa架构" aria-hidden="true">#</a> SOA架构</h2><ul><li><p>SOA提出的背景是企业内部的IT系统重复建设且效率低下。</p></li><li><p>SOA更多是在传统企业（例如，制造业、金融业等〉落地和推广，在互联网行业并没有大规模的实践和推广。</p></li><li><p>SOA三个关键概念：服务、ESB和松藕合。</p></li><li><p>SOA架构中，每项业务功能都是一项服务，服务就意味着要对外提供开放的能力。</p></li><li><p>SOA使用ESB来屏蔽异构系统对外提供各种不同的接口方式，以此来达到服务间高效的互联互通。</p></li><li><p>SOA解决了传统IT系统重复建设和扩展效率低的问题，但其本身也引入了更多的复杂性，SOA最广为人诣病的就是ESB。</p></li><li><p>SOA的ESB设计也是无奈之举，企业在应用SOA时，各种异构的IT系统都己经存在。很多年了，完全重写或按照统一标准进行改造的成本是非常大的，只能通过ESB方式去适配已经存在的各种异构系统。</p></li></ul><h2 id="微服务" tabindex="-1"><a class="header-anchor" href="#微服务" aria-hidden="true">#</a> 微服务</h2><ul><li><p>微服务概念的历史要早得多，也不是Martin Flower创造出来的，Martin只是将微服务进行了系统的阐述。</p></li><li><p>微服务是一种和SOA相似但本质上不同的架构理念。</p></li><li><p>微服务的三个关键词small（小）、lightweight（轻量级）、automated（自动化）。</p></li><li><p>微服务和SOA不存在孰优孰劣，只是应用场景不同。</p></li><li><p>微服务并不是没有代价，而是会带来系统复杂度、运维复杂度、性能下降等问题。</p></li><li><p>微服务拆分的粒度遵循&quot;三个火枪手&quot;原则。</p></li><li><p>真正决定微服务成败的，恰恰是那个被大部分人都忽略的&quot;automated&quot;，而不是&quot;small和&quot;lightweight&quot;。</p></li><li><p>微服务并不是很多人认为的那样又简单又轻量级，要做好微服务，基础设施是必不可少的。</p></li></ul><h2 id="微内核架构" tabindex="-1"><a class="header-anchor" href="#微内核架构" aria-hidden="true">#</a> 微内核架构</h2><ul><li><p>微内核架构也被称为插件化架构（Plug-in Architecture），是一种面向功能进行拆分的可扩展性架构。</p></li><li><p>微内核架构通常用于实现基于产品的应用。</p></li><li><p>微内核架构包含两类组件：核心系统（core system）和插件模块（plug-in modules）。</p></li><li><p>微内核的核心系统设计的关键技术有几部分：插件管理、插件连接和插件通信。</p></li><li><p>Eclipse采用OSGi标准后，OSGi更是成为首选的插件化标准。</p></li></ul><h2 id="消息队列设计实战" tabindex="-1"><a class="header-anchor" href="#消息队列设计实战" aria-hidden="true">#</a> 消息队列设计实战</h2><ul><li><p>识别复杂度对架构师来说是一项挑战，因为原始的需求中并没有哪个地方会明确地说复杂度在哪里，需要架构师在理解需求的基础上进行分析。</p></li><li><p>有经验的架构师可能一看需求就知道复杂度大概在哪里，如果经验不足，则只能采取&quot;排查法&quot;，从不同的角度逐一进行分析。</p></li><li><p>架构师关注的不是一天的数据，而是1秒的数据，即TPS和QPS。</p></li><li><p>备选方案的选择和很多因素相关，并不单单考虑性能高低、技术是否优越这些纯技术因素，业务的需求特点、运维团队的经验、己有的技术体系、团队人员的技术水平都会影响备选方案的选择。</p></li><li><p>架构设计目的不是证明自己（参考架构设计原则1：合适原则），而是更快更好地满足业务需求。</p></li></ul><h2 id="互联网架构演进" tabindex="-1"><a class="header-anchor" href="#互联网架构演进" aria-hidden="true">#</a> 互联网架构演进</h2><ul><li><p>产品类：技术创新推动业务发展。</p></li><li><p>&quot;服务&quot;类的业务：业务发展推动技术的发展。</p></li><li><p>架构师需要基于业务发展阶段判断出系统当前面临的主要复杂度。</p></li><li><p>互联网业务千差万别，但都具有&quot;规模决定一切&quot;的特点。</p></li><li><p>互联网业务发展一般分为几个时期：初创期、快速发展期、竞争期、成熟期。</p></li><li><p>互联网业务发展第一个主要方向就是&quot;业务越来越复杂&quot;。</p></li><li><p>互联网业务发展第二主要方向就是&quot;用户量越来越大&quot;。</p></li><li><p>互联网业务发展带来复杂度的本质原因其实都是&quot;量变带来质变&quot;。</p></li></ul><h2 id="互联网架构模板" tabindex="-1"><a class="header-anchor" href="#互联网架构模板" aria-hidden="true">#</a> 互联网架构模板</h2><ul><li><p>NoSQL不是NoSQL，而是Not Only SQL，即NoSQL SQL的补充。</p></li><li><p>NoSQL发展到一定规模后，一般都是走集群路线。</p></li><li><p>在开源方案的基础上封装一个小文件存储平台并不是太难的事情。</p></li><li><p>大数据存储和处理反而是最简单的，因为你别无选择，只能用这几个流行的开源方案。</p></li><li><p>框架的选择，有一个总的原则：<strong>优选成熟的框架，避免盲目追逐新技术！</strong></p></li><li><p>互联网行业基本上都是&quot;拿来主义&quot;，挑选一个流行的开源服务器即可。</p></li><li><p>配置中心主要为了解决系统数量增多后配置管理复杂和效率低下的问题。</p></li><li><p>服务中心目的是解决跨系统依赖的&quot;配置&quot;和&quot;调度&quot;问题。</p></li><li><p>消息队列目的是为了实现跨系统异步通知。</p></li><li><p>DNS是最简单也是最常见的负载均衡方式，一般用来实现地理级别的均衡。</p></li><li><p>Nginx&amp;LVS&amp;FS用于同一地点内机器级别的负载均衡。</p></li><li><p>CDN是为了解决用户网络访问时的&quot;最后一公里&quot;效应，本质上是一种&quot;以空间换时间&quot;的加速策略。</p></li><li><p>多机房设计最核心的设计因素就是如何处理时延带来的影响。</p></li><li><p>多中心必须以多机房为前提，但从设计的角度来看，多中心相比多机房是本质上的飞越，难度也高出一个等级。</p></li><li><p>用户管理系统两个核心职责：单点登录和第三方授权登录。</p></li><li><p>消息推送主要包含3个功能：设备管理（唯一标识、注册和注销）、连接管理和消息管理。</p></li><li><p>除非BAT级别，一般不建议自己再重复造轮子了，直接买图片云和存储云服务可能是最快又最经济的方式。</p></li><li><p>业务层降低复杂性最好的方式就是&quot;拆&quot;，化整为零，分而治之，将整体复杂性分散到多个子业务或子系统里面去。</p></li><li><p>运维平台核心的职责分为四大块：配置、部署、监控和应急。</p></li><li><p>测试平台的核心目的是提升测试效率，从而提升产品质量，其设计关键就是自动化。</p></li><li><p>数据平台的核心职责主要包括三部分：数据管理、数据分析和数据应用。</p></li><li><p>管理平台的核心职责就是权限管理。</p></li></ul><h2 id="架构重构" tabindex="-1"><a class="header-anchor" href="#架构重构" aria-hidden="true">#</a> 架构重构</h2><ul><li><p>期望通过架构重构来解决所有问题当然是不现实的。</p></li><li><p>架构师的首要任务是从一大堆纷繁复杂的问题中识别出真正要通过架构来解决的问题，集中力量快速解决，而不是想着通过架构重构来解决所有的问题。</p></li><li><p>真正推动一个架构重构项目启动，需要花费大量的精力进行游说和沟通。</p></li><li><p>架构重构沟通协调时，将技术语言转换为通俗语言，以事实说话，以数据说话，是沟通的关键。</p></li><li><p>架构重构涉及关联方配合时，有效的沟通策略是&quot;换位思考、合作双赢、关注长期&quot;。</p></li><li><p>架构重构需要采取&quot;分段实施&quot;策略，将要解决的问题根据优先级、重要性、实施难度等划分为不同的阶段，每个阶段聚焦于一个整体的目标。</p></li><li><p>正的架构师，必须具备一定的项目经理技能，但更重要的还是技术能力。</p></li></ul><h2 id="开源系统" tabindex="-1"><a class="header-anchor" href="#开源系统" aria-hidden="true">#</a> 开源系统</h2><ul><li><p>选开源方案时，<mark>聚焦于是否满足业务</mark>，而不需要过于关注开源方案是否优秀。</p></li><li><p>选择开源项目时，<strong>尽量选择成熟的开源项目</strong>。</p></li><li><p>选择开掘项目时，除了关注技术指标，还要关注运维能力。</p></li><li><p>开源项目不能简单&quot;拿来主义&quot;，而要深入研究和仔细测试。</p></li><li><p>使用开源项目时对线上环境和风险要有敬畏之心，小心应用，灰度发布。</p></li><li><p>无论什么开源方案，都需要考虑应急的备份方案。</p></li><li><p>如果需要修改开源系统，不要改动原系统，而是要开发辅助系统。</p></li><li><p>选与不选开源项目，核心还是一个成本和收益的问题，并不是说选择开源项目就一定是最忧的方案。</p></li></ul><h2 id="高并发" tabindex="-1"><a class="header-anchor" href="#高并发" aria-hidden="true">#</a> 高并发</h2><ul><li><p>无状态（分而治之，横向拓展）</p></li><li><p>微服务拆分（系统拆分）</p></li><li><p>分库分表</p></li><li><p>主从同步（读写分离）</p></li><li><p>池化技术</p></li><li><p>使用缓存</p></li><li><p>CDN加速静态资源访问</p></li><li><p>Elasticsearch</p></li><li><p>降级熔断</p></li><li><p>限流</p></li><li><p>异步（消息队列）</p></li><li><p>接口常规的优化</p></li><li><p>压力测试确定系统瓶颈</p></li><li><p>应对突发流量峰值：扩容+切流量</p></li></ul>',42),t=[e];function u(h,o){return l(),p("div",null,t)}const s=i(r,[["render",u],["__file","系统架构设计.html.vue"]]);export{s as default};
