const e=JSON.parse('{"key":"v-517501f6","path":"/home/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9CMySQL%E5%92%8CRedis%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7.html","title":"如何保障MySQL和Redis的数据一致性","lang":"zh-CN","frontmatter":{"title":"如何保障MySQL和Redis的数据一致性","description":"如何保障 MySQL 和 Redis 的数据一致性？ 我直接先抛一下结论：在满足实时性的条件下，不存在两者完全保存一致的方案，只有最终一致性方案。 根据网上的众多解决方案，总结出 6 种，直接看目录： MySQL和Redis的数据一致性目录 读数据的方式 读数据方式1： 先从缓存读取，缓存读取不到从DB中读取，读取到就设置到缓存","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/home/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9CMySQL%E5%92%8CRedis%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7.html"}],["meta",{"property":"og:site_name","content":"Jef Blog"}],["meta",{"property":"og:title","content":"如何保障MySQL和Redis的数据一致性"}],["meta",{"property":"og:description","content":"如何保障 MySQL 和 Redis 的数据一致性？ 我直接先抛一下结论：在满足实时性的条件下，不存在两者完全保存一致的方案，只有最终一致性方案。 根据网上的众多解决方案，总结出 6 种，直接看目录： MySQL和Redis的数据一致性目录 读数据的方式 读数据方式1： 先从缓存读取，缓存读取不到从DB中读取，读取到就设置到缓存"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://mister-hope.github.io/"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-01-27T09:32:16.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"如何保障MySQL和Redis的数据一致性"}],["meta",{"property":"article:author","content":"Jef"}],["meta",{"property":"article:modified_time","content":"2024-01-27T09:32:16.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"如何保障MySQL和Redis的数据一致性\\",\\"image\\":[\\"https://mister-hope.github.io/\\"],\\"dateModified\\":\\"2024-01-27T09:32:16.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Jef\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"读数据的方式","slug":"读数据的方式","link":"#读数据的方式","children":[]},{"level":2,"title":"不好的方案","slug":"不好的方案","link":"#不好的方案","children":[{"level":3,"title":"1. 先写 MySQL，再写 Redis","slug":"_1-先写-mysql-再写-redis","link":"#_1-先写-mysql-再写-redis","children":[]},{"level":3,"title":"2. 先写 Redis，再写 MySQL","slug":"_2-先写-redis-再写-mysql","link":"#_2-先写-redis-再写-mysql","children":[]},{"level":3,"title":"3. 先删除 Redis，再写 MySQL","slug":"_3-先删除-redis-再写-mysql","link":"#_3-先删除-redis-再写-mysql","children":[]}]},{"level":2,"title":"好的方案","slug":"好的方案","link":"#好的方案","children":[{"level":3,"title":"4. 先删除 Redis，再写 MySQL，再删除 Redis","slug":"_4-先删除-redis-再写-mysql-再删除-redis","link":"#_4-先删除-redis-再写-mysql-再删除-redis","children":[]},{"level":3,"title":"5. 先写 MySQL，再删除 Redis","slug":"_5-先写-mysql-再删除-redis","link":"#_5-先写-mysql-再删除-redis","children":[]},{"level":3,"title":"6. 先写 MySQL，通过 Binlog，异步更新 Redis","slug":"_6-先写-mysql-通过-binlog-异步更新-redis","link":"#_6-先写-mysql-通过-binlog-异步更新-redis","children":[]}]},{"level":2,"title":"几种方案比较","slug":"几种方案比较","link":"#几种方案比较","children":[]},{"level":2,"title":"个人结论","slug":"个人结论","link":"#个人结论","children":[]}],"git":{"createdTime":1705656195000,"updatedTime":1706347936000,"contributors":[{"name":"tufujie","email":"tufj@hua-cloud.com.cn","commits":2}]},"readingTime":{"minutes":6.44,"words":1932},"filePathRelative":"home/数据库/如何保障MySQL和Redis的数据一致性.md","localizedDate":"2024年1月19日","excerpt":"<p>如何保障 MySQL 和 Redis 的数据一致性？</p>\\n<p>我直接先抛一下结论：<mark><strong>在满足实时性的条件下，不存在两者完全保存一致的方案，只有最终一致性方案。</strong></mark> 根据网上的众多解决方案，总结出 6 种，直接看目录：</p>\\n<figure><figcaption>MySQL和Redis的数据一致性目录</figcaption></figure>\\n<h2> 读数据的方式</h2>\\n<p>读数据方式1：</p>\\n<blockquote>\\n<p>先从缓存读取，缓存读取不到从DB中读取，读取到就设置到缓存</p>\\n</blockquote>","autoDesc":true}');export{e as data};
