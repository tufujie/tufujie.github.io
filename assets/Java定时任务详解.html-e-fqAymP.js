import{_ as c}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as e,o as i,c as l,a as n,b as s,e as a,w as u,d as t}from"./app-AuAuVshg.js";const r="/assets/定时任务1-7tdKSLv1.jpg",d="/assets/定时任务3-J3qPniT0.jpg",k="/assets/定时任务4-sPoFFANQ.jpg",g="/assets/定时任务5-sLVsAfqR.jpg",m="/assets/定时任务6-lLM2KtU8.jpg",h="/assets/定时任务7-RCsJIS0z.jpg",v="/assets/定时任务8-GdVd14WP.jpg",b="/assets/定时任务9-LpKDrQRm.jpg",f="/assets/定时任务10-xl5aEQUd.jpg",x="/assets/定时任务11-oP1kH5aZ.jpg",T="/assets/定时任务12-NAyelBW2.jpg",y="/assets/定时任务13-L8E-i8hA.jpg",_="/assets/定时任务14-MHbBM2pt.jpg",S="/assets/定时任务15-GRPtr1jf.jpg",w="/assets/定时任务16-ri29BjY2.jpg",q={},J=t(`<h2 id="为什么需要定时任务" tabindex="-1"><a class="header-anchor" href="#为什么需要定时任务" aria-hidden="true">#</a> <strong>为什么需要定时任务？</strong></h2><p>我们来看一下几个非常常见的业务场景：</p><ol><li>某系统凌晨要进行数据备份。</li><li>某电商平台，用户下单半个小时未支付的情况下需要自动取消订单。</li><li>某媒体聚合平台，每 10 分钟动态抓取某某网站的数据为自己所用。</li><li>某博客平台，支持定时发送文章。</li><li>某基金平台，每晚定时计算用户当日收益情况并推送给用户最新的数据。</li><li>......</li></ol><p>这些场景往往都要求我们在某个特定的时间去做某个事情。</p><h2 id="单机定时任务技术选型" tabindex="-1"><a class="header-anchor" href="#单机定时任务技术选型" aria-hidden="true">#</a> <strong>单机定时任务技术选型</strong></h2><h3 id="timer" tabindex="-1"><a class="header-anchor" href="#timer" aria-hidden="true">#</a> <strong>Timer</strong></h3><p>java.util.Timer是 JDK 1.3 开始就已经支持的一种定时任务的实现方式。</p><p>Timer 内部使用一个叫做 TaskQueue 的类存放定时任务，它是一个基于最小堆实现的优先级队列。TaskQueue 会按照任务距离下一次执行时间的大小将任务排序，保证在堆顶的任务最先执行。这样在需要执行任务时，每次只需要取出堆顶的任务运行即可！</p><p>Timer 使用起来比较简单，通过下面的方式我们就能创建一个 1s 之后执行的定时任务。</p><p>// 示例代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">TimerTask</span> task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TimerTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;开始执行任务，当前时间: &quot;</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;线程名称: &quot;</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;当前时间: &quot;</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;线程名称: &quot;</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Timer</span> timer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span><span class="token string">&quot;thread Name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">long</span> delay <span class="token operator">=</span> <span class="token number">1000L</span><span class="token punctuation">;</span>
timer<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>//输出：</p><p>当前时间: Thu Dec 21 14:28:26 GMT+08:00 2023线程名称: main 开始执行任务，当前时间: Thu Dec 21 14:28:27 GMT+08:00 2023线程名称: thread Name</p><p>不过其缺陷较多，比如一个 Timer 一个线程，这就导致 Timer 的任务的执行只能串行执行，一个任务执行时间过长的话会影响其他任务（性能非常差），再比如发生异常时任务直接停止（Timer 只捕获了 InterruptedException ）。</p><p>Timer 类上的有一段注释是这样写的：</p>`,15),j=t('<p>大概的意思就是： ScheduledThreadPoolExecutor 支持多线程执行定时任务并且功能更强大，是 Timer 的替代品。</p><h3 id="scheduledexecutorservice" tabindex="-1"><a class="header-anchor" href="#scheduledexecutorservice" aria-hidden="true">#</a> <strong>ScheduledExecutorService</strong></h3><p>ScheduledExecutorService 是一个接口，有多个实现类，比较常用的是 ScheduledThreadPoolExecutor 。</p><figure><img src="'+r+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>ScheduledThreadPoolExecutor 本身就是一个线程池，支持任务并发执行。并且，其内部使用 DelayQueue 作为任务队列。</p><p>// 示例代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">TimerTask</span> repeatedTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TimerTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token annotation punctuation">@SneakyThrows</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;当前时间: &quot;</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;线程名称: &quot;</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;当前时间: &quot;</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;线程名称: &quot;</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ScheduledExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">long</span> delay <span class="token operator">=</span> <span class="token number">1000L</span><span class="token punctuation">;</span>
<span class="token keyword">long</span> period <span class="token operator">=</span> <span class="token number">1000L</span><span class="token punctuation">;</span>
executor<span class="token punctuation">.</span><span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span>repeatedTask<span class="token punctuation">,</span> delay<span class="token punctuation">,</span> period<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>delay <span class="token operator">+</span> period <span class="token operator">*</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>//输出：</p><p>当前时间: Thu Dec 21 14:32:55 GMT+08:00 2023线程名称: main 当前时间: Thu Dec 21 14:32:56 GMT+08:00 2023线程名称: pool-1-thread-1 当前时间: Thu Dec 21 14:32:57 GMT+08:00 2023线程名称: pool-1-thread-1 当前时间: Thu Dec 21 14:32:58 GMT+08:00 2023线程名称: pool-1-thread-2 当前时间: Thu Dec 21 14:32:59 GMT+08:00 2023线程名称: pool-1-thread-2 当前时间: Thu Dec 21 14:33:00 GMT+08:00 2023线程名称: pool-1-thread-2 当前时间: Thu Dec 21 14:33:01 GMT+08:00 2023线程名称: pool-1-thread-2</p><p>不论是使用 Timer 还是 ScheduledExecutorService 都无法使用 Cron 表达式指定任务执行的具体时间。</p><h3 id="spring-task" tabindex="-1"><a class="header-anchor" href="#spring-task" aria-hidden="true">#</a> <strong>Spring Task</strong></h3><p>我们直接通过 Spring 提供的 @Scheduled 注解即可定义定时任务，非常方便！</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
  cron：使用Cron表达式。　每分钟的1，2秒运行
 */</span>
<span class="token annotation punctuation">@Scheduled</span><span class="token punctuation">(</span>cron <span class="token operator">=</span> <span class="token string">&quot;1-2 * * * * ? &quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reportCurrentTimeWithCronExpression</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;Cron Expression: The time is now {}&quot;</span><span class="token punctuation">,</span> dateFormat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我在大学那会做的一个 SSM 的企业级项目，就是用的 Spring Task 来做的定时任务。</p><p>并且，Spring Task 还是支持 <strong>Cron 表达式</strong> 的。Cron 表达式主要用于定时作业(定时任务)系统定义执行时间或执行频率的表达式，非常厉害，你可以通过 Cron 表达式进行设置定时任务每天或者每个月什么时候执行等等操作。咱们要学习定时任务的话，Cron 表达式是一定是要重点关注的。推荐一个在线 Cron 表达式生成器：http://cron.qqe2.com/ 。</p><p>但是，Spring 自带的定时调度只支持单机，并且提供的功能比较单一。</p><p>Spring Task 底层是基于 JDK 的 ScheduledThreadPoolExecutor 线程池来实现的。</p><p><strong>优缺点总结：</strong></p><ul><li><p>优点： 简单，轻量，支持 Cron 表达式</p></li><li><p>缺点 ：功能单一</p></li></ul><h3 id="时间轮" tabindex="-1"><a class="header-anchor" href="#时间轮" aria-hidden="true">#</a> <strong>时间轮</strong></h3><p>Kafka、Dubbo、ZooKeeper、Netty 、Caffeine 、Akka 中都有对时间轮的实现。</p><p>时间轮简单来说就是一个环形的队列（底层一般基于数组实现），队列中的每一个元素（时间格）都可以存放一个定时任务列表。</p><p>时间轮中的每个时间格代表了时间轮的基本时间跨度或者说时间精度，加入时间一秒走一个时间格的话，那么这个时间轮的最高精度就是 1 秒（也就是说 3 s 和 3.9s 会在同一个时间格中）。</p><p>下图是一个有 12 个时间格的时间轮，转完一圈需要 12 s。当我们需要新建一个 3s 后执行的定时任务，只需要将定时任务放在下标为 3 的时间格中即可。当我们需要新建一个 9s 后执行的定时任务，只需要将定时任务放在下标为 9 的时间格中即可。</p><figure><img src="`+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>那当我们需要创建一个 13s 后执行的定时任务怎么办呢？这个时候可以引入一叫做 <strong>圈数/轮数</strong> 的概念，也就是说这个任务还是放在下标为 3 的时间格中， 不过它的圈数为 2 。</p><p>除了增加圈数这种方法之外，还有一种 <strong>多层次时间轮</strong> （类似手表），Kafka 采用的就是这种方案。</p><p>针对下图的时间轮，我来举一个例子便于大家理解。</p><figure><img src="'+k+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>上图的时间轮，第 1 层的时间精度为 1 ，第 2 层的时间精度为 20 ，第 3 层的时间精度为 400。假如我们需要添加一个 350s 后执行的任务 A 的话（当前时间是 0s），这个任务会被放在第 2 层（因为第二层的时间跨度为 20*20=400&gt;350）的第 350/20=17 个时间格子。</p><p>当第一层转了 17 圈之后，时间过去了 340s ，第 2 层的指针此时来到第 17 个时间格子。此时，第 2 层第 17 个格子的任务会被移动到第 1 层。</p><p>任务 A 当前是 10s 之后执行，因此它会被移动到第 1 层的第 10 个时间格子。</p><p>这里在层与层之间的移动也叫做时间轮的升降级。参考手表来理解就好！</p><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>时间轮比较适合任务数量比较多的定时任务场景，它的任务写入和执行的时间复杂度都是 0（1）。</strong></p><h2 id="分布式定时任务技术选型" tabindex="-1"><a class="header-anchor" href="#分布式定时任务技术选型" aria-hidden="true">#</a> <strong>分布式定时任务技术选型</strong></h2><p>上面提到的一些定时任务的解决方案都是在单机下执行的，适用于比较简单的定时任务场景比如每天凌晨备份一次数据。</p><p>如果我们需要一些高级特性比如支持任务在分布式场景下的分片和高可用的话，我们就需要用到分布式任务调度框架了。</p><p>通常情况下，一个定时任务的执行往往涉及到下面这些角色：</p><ul><li><p><strong>任务</strong> ： 首先肯定是要执行的任务，这个任务就是具体的业务逻辑比如定时发送文章。</p></li><li><p><strong>调度器</strong> ：其次是调度中心，调度中心主要负责任务管理，会分配任务给执行器。</p></li><li><p><strong>执行器</strong> ： 最后就是执行器，执行器接收调度器分派的任务并执行。</p></li></ul><h3 id="quartz" tabindex="-1"><a class="header-anchor" href="#quartz" aria-hidden="true">#</a> <strong>Quartz</strong></h3><figure><img src="'+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>一个很火的开源任务调度框架，完全由Java写成。Quartz 可以说是 Java 定时任务领域的老大哥或者说参考标准，其他的任务调度框架基本都是基于 Quartz 开发的，比如当当网的elastic-job就是基于quartz二次开发之后的分布式调度解决方案。</p><p>使用 Quartz 可以很方便地与 Spring 集成，并且支持动态添加任务和集群。但是，Quartz 使用起来也比较麻烦，API 繁琐。</p>',44),E={href:"https://github.com/zhaopeiym/quartzui",target:"_blank",rel:"noopener noreferrer"},C=t('<p>另外，Quartz 虽然也支持分布式任务。但是，它是在数据库层面，通过数据库的锁机制做的，有非常多的弊端比如系统侵入性严重、节点负载不均衡。有点伪分布式的味道。</p><p><strong>优缺点总结：</strong></p><ul><li><p>优点： 可以与 Spring 集成，并且支持动态添加任务和集群。</p></li><li><p>缺点 ：分布式支持不友好，没有内置 UI 管理控制台、使用麻烦（相比于其他同类型框架来说）</p></li></ul><h3 id="elastic-job" tabindex="-1"><a class="header-anchor" href="#elastic-job" aria-hidden="true">#</a> <strong>Elastic-Job</strong></h3><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>Elastic-Job 是当当网开源的一个基于Quartz和ZooKeeper的分布式调度解决方案，由两个相互独立的子项目 Elastic-Job-Lite 和 Elastic-Job-Cloud 组成，一般我们只要使用 Elastic-Job-Lite 就好。</p><p>ElasticJob 支持任务在分布式场景下的分片和高可用、任务可视化管理等功能。</p><figure><img src="'+v+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>ElasticJob-Lite 的架构设计如下图所示：</p><figure><img src="'+b+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>从上图可以看出，Elastic-Job 没有调度中心这一概念，而是使用 ZooKeeper 作为注册中心，注册中心负责协调分配任务到不同的节点上。</p><p>Elastic-Job 中的定时调度都是由执行器自行触发，这种设计也被称为去中心化设计（调度和处理都是执行器单独完成）。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@ElasticJobConf</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">&quot;dayJob&quot;</span><span class="token punctuation">,</span> cron <span class="token operator">=</span> <span class="token string">&quot;0/10 * * * * ?&quot;</span><span class="token punctuation">,</span> shardingTotalCount <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span>
        shardingItemParameters <span class="token operator">=</span> <span class="token string">&quot;0=AAAA,1=BBBB&quot;</span><span class="token punctuation">,</span> description <span class="token operator">=</span> <span class="token string">&quot;简单任务&quot;</span><span class="token punctuation">,</span> failover <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestJob</span> <span class="token keyword">implements</span> <span class="token class-name">SimpleJob</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">ShardingContext</span> shardingContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;TestJob任务名：【{}】, 片数：【{}】, param=【{}】&quot;</span><span class="token punctuation">,</span> shardingContext<span class="token punctuation">.</span><span class="token function">getJobName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> shardingContext<span class="token punctuation">.</span><span class="token function">getShardingTotalCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                shardingContext<span class="token punctuation">.</span><span class="token function">getShardingParameter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>相关地址：</strong></p><ul><li><p>Github 地址：https://github.com/apache/shardingsphere-elasticjob。</p></li><li><p>官方网站：https://shardingsphere.apache.org/elasticjob/index_zh.html 。</p></li></ul><p><strong>优缺点总结：</strong></p><ul><li><p>优点 ：可以与 Spring 集成、支持分布式、支持集群、性能不错</p></li><li><p>缺点 ：依赖了额外的中间件比如 Zookeeper（复杂度增加，可靠性降低、维护成本变高）</p></li></ul><h3 id="xxl-job" tabindex="-1"><a class="header-anchor" href="#xxl-job" aria-hidden="true">#</a> <strong>XXL-JOB</strong></h3><figure><img src="`+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>XXL-JOB 于 2015 年开源，是一款优秀的轻量级分布式任务调度框架，支持任务可视化管理、弹性扩容缩容、任务失败重试和告警、任务分片等功能，</p><figure><img src="'+x+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>根据 XXL-JOB 官网介绍，其解决了很多 Quartz 的不足。</p><figure><img src="'+T+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>XXL-JOB 的架构设计如下图所示：</p><figure><img src="'+y+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>从上图可以看出，XXL-JOB 由 <strong>调度中心</strong> 和 <strong>执行器</strong> 两大部分组成。调度中心主要负责任务管理、执行器管理以及日志管理。执行器主要是接收调度信号并处理。另外，调度中心进行任务调度时，是通过自研 RPC 来实现的。</p><p>不同于 Elastic-Job 的去中心化设计， XXL-JOB 的这种设计也被称为中心化设计（调度中心调度多个执行器执行任务）。</p><p>和 Quzrtz 类似 XXL-JOB 也是基于数据库锁调度任务，存在性能瓶颈。不过，一般在任务量不是特别大的情况下，没有什么影响的，可以满足绝大部分公司的要求。</p><p>不要被 XXL-JOB 的架构图给吓着了，实际上，我们要用 XXL-JOB 的话，只需要重写 IJobHandler 自定义任务执行逻辑就可以了，非常易用！</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@JobHandler</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">&quot;myApiJobHandler&quot;</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyApiJobHandler</span> <span class="token keyword">extends</span> <span class="token class-name">IJobHandler</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">ReturnT</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">String</span> param<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token comment">//......</span>
        <span class="token keyword">return</span> <span class="token class-name">ReturnT</span><span class="token punctuation">.</span><span class="token constant">SUCCESS</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>还可以直接基于注解定义任务。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@XxlJob</span><span class="token punctuation">(</span><span class="token string">&quot;myAnnotationJobHandler&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">ReturnT</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">myAnnotationJobHandler</span><span class="token punctuation">(</span><span class="token class-name">String</span> param<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
  <span class="token comment">//......</span>
  <span class="token keyword">return</span> <span class="token class-name">ReturnT</span><span class="token punctuation">.</span><span class="token constant">SUCCESS</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>相关地址：</strong></p><ul><li><p>Github 地址：https://github.com/xuxueli/xxl-job/。</p></li><li><p>官方介绍：https://www.xuxueli.com/xxl-job/ 。</p></li></ul><p><strong>优缺点总结：</strong></p>',36),L=n("li",null,[n("p",null,"优点：开箱即用（学习成本比较低）、与 Spring 集成、支持分布式、支持集群、内置了 UI 管理控制台。")],-1),D={href:"https://github.com/xuxueli/xxl-job/issues/277",target:"_blank",rel:"noopener noreferrer"},z=n("h3",{id:"powerjob",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#powerjob","aria-hidden":"true"},"#"),s(),n("strong",null,"PowerJob")],-1),M=n("figure",null,[n("img",{src:S,alt:"",tabindex:"0",loading:"lazy"}),n("figcaption")],-1),X=n("p",null,"非常值得关注的一个分布式任务调度框架，分布式任务调度领域的新星。目前，已经有很多公司接入比如 OPPO、京东、中通、思科。",-1),A=n("p",null,"这个框架的诞生也挺有意思的，PowerJob 的作者当时在阿里巴巴实习过，阿里巴巴那会使用的是内部自研的 SchedulerX（阿里云付费产品）。实习期满之后，PowerJob 的作者离开了阿里巴巴。想着说自研一个 SchedulerX，防止哪天 SchedulerX 满足不了需求，于是 PowerJob 就诞生了。",-1),P={href:"https://www.bilibili.com/video/BV1SK411A7F3/",target:"_blank",rel:"noopener noreferrer"},O=t('<p>由于 SchedulerX 属于人民币产品，我这里就不过多介绍。PowerJob 官方也对比过其和 QuartZ、XXL-JOB 以及 SchedulerX。</p><figure><img src="'+w+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> <strong>总结</strong></h2><p>这篇文章中，我主要介绍了：</p><ul><li><p><strong>定时任务的相关概念</strong> ：为什么需要定时任务、定时任务中的核心角色、分布式定时任务。</p></li><li><p><strong>定时任务的技术选型</strong> ： XXL-JOB 2015 年推出，已经经过了很多年的考验。XXL-JOB 轻量级，并且使用起来非常简单。虽然存在性能瓶颈，但是，在绝大多数情况下，对于企业的基本需求来说是没有影响的。PowerJob 属于分布式任务调度领域里的新星，其稳定性还有待继续考察。ElasticJob 由于在架构设计上是基于 Zookeeper ，而 XXL-JOB 是基于数据库，性能方面的话，ElasticJob 略胜一筹。</p></li></ul><p>这篇文章并没有介绍到实际使用，但是，并不代表实际使用不重要。我在写这篇文章之前，已经动手写过相应的 Demo。像 Quartz，我在大学那会就用过。不过，当时用的是 Spring 。为了能够更好地体验，我自己又在 Spring Boot 上实际体验了一下。如果你并没有实际使用某个框架，就直接说它并不好用的话，是站不住脚的。</p><h2 id="cron表达式" tabindex="-1"><a class="header-anchor" href="#cron表达式" aria-hidden="true">#</a> <strong>cron表达式</strong></h2><p>cron表达式用于配置cronTrigger的实例。cron表达式实际上是由七个子表达式组成。这些表达式之间用空格分隔。</p><p>1.Seconds （秒）</p><p>2.Minutes（分）</p><p>3.Hours（小时）</p><p>4.Day-of-Month （天）</p><p>5.Month（月）</p><p>6.Day-of-Week （周）</p><p>7.Year（年）</p><p>例：&quot;0 0 12 ? * WED” 意思是：每个星期三的中午12点执行。</p><p>个别子表达式可以包含范围或者列表。例如：上面例子中的WED可以换成&quot;MON-FRI&quot;，&quot;MON,WED,FRI&quot;，甚至&quot;MON-WED,SAT&quot;。</p><h3 id="子表达式范围" tabindex="-1"><a class="header-anchor" href="#子表达式范围" aria-hidden="true">#</a> <strong>子表达式范围</strong></h3><p>1.Seconds (0~59)</p><p>2.Minutes (0~59)</p><p>3.Hours (0~23)</p><p>4.Day-of-Month (1~31,但是要注意有些月份没有31天)</p><p>5.Month (1~12，或者&quot;JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV,DEC&quot;)</p><p>6.Day-of-Week (1~7,1=SUN 或者&quot;SUN, MON, TUE, WED, THU, FRI, SAT”)</p><p>7.Year (1970~2099)</p><p>Cron表达式的格式：<strong>秒 分 时 日 月 周 年</strong>(可选)。</p><p>字段名 允许的值 允许的特殊字符</p><p>秒 0-59 , - * /</p><p>分 0-59 , - * /</p><p>小时 0-23 , - * /</p><p>日 1-31 , - * ? / L W C</p><p>月 1-12 or JAN-DEC , - * /</p><p>周几 1-7 or SUN-SAT , - * ? / L C ##</p><p>年(可选字段) empty 1970-2099 , - * /</p><h3 id="字符含义" tabindex="-1"><a class="header-anchor" href="#字符含义" aria-hidden="true">#</a> <strong>字符含义</strong></h3><p>**** ：代表所有可能的值。因此，“*”在Month中表示每个月，在Day-of-Month中表示每天，在Hours表示每小时</p><p><strong>-</strong> ：表示指定范围。</p><p><strong>,</strong> ：表示列出枚举值。例如：在Minutes子表达式中，“5,20”表示在5分钟和20分钟触发。</p><p><strong>/</strong> ：被用于指定增量。例如：在Minutes子表达式中，“0/15”表示从0分钟开始，每15分钟执行一次。&quot;3/20&quot;表示从第三分钟开始，每20分钟执行一次。和&quot;3,23,43&quot;（表示第3，23，43分钟触发）的含义一样。</p><p><strong>?</strong> ：用在Day-of-Month和Day-of-Week中，指“没有具体的值”。当两个子表达式其中一个被指定了值以后，为了避免冲突，需要将另外一个的值设为“?”。例如：想在每月20日触发调度，不管20号是星期几，只能用如下写法：0 0 0 20 * ?，其中最后以为只能用“?”，而不能用“*”。</p><p><strong>L</strong> ：用在day-of-month和day-of-week字串中。它是单词“last”的缩写。它在两个子表达式中的含义是不同的。</p><p>在day-of-month中，“L”表示一个月的最后一天，一月31号，3月30号。</p><p>在day-of-week中，“L”表示一个星期的最后一天，也就是“7”或者“SAT”</p><p>如果“L”前有具体内容，它就有其他的含义了。例如：“6L”表示这个月的倒数第六天。“FRIL”表示这个月的最后一个星期五。</p><p>注意：在使用“L”参数时，不要指定列表或者范围，这样会出现问题。</p><p><strong>W</strong> ：“Weekday”的缩写。只能用在day-of-month字段。用来描叙最接近指定天的工作日（周一到周五）。例如：在day-of-month字段用“15W”指“最接近这个月第15天的工作日”，即如果这个月第15天是周六，那么触发器将会在这个月第14天即周五触发；如果这个月第15天是周日，那么触发器将会在这个月第 16天即周一触发；如果这个月第15天是周二，那么就在触发器这天触发。注意一点：这个用法只会在当前月计算值，不会越过当前月。“W”字符仅能在 day-of-month指明一天，不能是一个范围或列表。也可以用“LW”来指定这个月的最后一个工作日，即最后一个星期五。</p><p><strong>C</strong>：Calendar，表示距离指定日期最近的那个日子，比如0 0 0 1C * ?表示当月的第一个工作日执行任务。如果1号是工作日，则执行任务；如果1号是周末，则任务会延后到最近的工作日即2号执行。</p><p>其中，W和C的区别在于W只能用在日字段上，表示距离指定日期最近的工作日；而C可以用在月、日、星期字段上，表示距离指定日期最近的那个日子。同时，C还可以与星期字段结合使用，比如0 0 0 ? * 2##2表示每月第二个星期二执行任务；</p><p><strong>##</strong> ：只能用在day-of-week字段。用来指定这个月的第几个周几。例：在day-of-week字段用&quot;6##3&quot; or &quot;FRI##3&quot;指这个月第3个周五（6指周五，3指第3个）。如果指定的日期不存在，触发器就不会触发。</p><h3 id="表达式例子" tabindex="-1"><a class="header-anchor" href="#表达式例子" aria-hidden="true">#</a> <strong>表达式例子</strong></h3><p>0 * * * * ? 每1分钟触发一次</p><p>0 0 * * * ? 每天每1小时触发一次</p><p>0 0 10 * * ? 每天10点触发一次</p><p>0 * 14 * * ? 在每天下午2点到下午2:59期间的每1分钟触发</p><p>0 30 9 1 * ? 每月1号上午9点半</p><p>0 15 10 15 * ? 每月15日上午10:15触发</p><p>*/5 * * * * ? 每隔5秒执行一次</p><p>0 */1 * * * ? 每隔1分钟执行一次</p><p>0 0 5-15 * * ? 每天5-15点整点触发</p><p>0 0/3 * * * ? 每三分钟触发一次</p><p>0 0-5 14 * * ? 在每天下午2点到下午2:05期间的每1分钟触发</p><p>0 0/5 14 * * ? 在每天下午2点到下午2:55期间的每5分钟触发</p><p>0 0/5 14,18 * * ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发</p><p>0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时</p><p>0 0 10,14,16 * * ? 每天上午10点，下午2点，4点</p><p>0 0 12 ? * WED 表示每个星期三中午12点</p><p>0 0 17 ? * TUES,THUR,SAT 每周二、四、六下午五点</p><p>0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发</p><p>0 15 10 ? * MON-FRI 周一至周五的上午10:15触发</p><p>0 0 23 L * ? 每月最后一天23点执行一次</p><p>0 15 10 L * ? 每月最后一日的上午10:15触发</p><p>0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发</p><p>0 15 10 * * ? 2005 2005年的每天上午10:15触发</p><p>0 15 10 ? * 6L 2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发</p><p>0 15 10 ? * 6##3 每月的第三个星期五上午10:15触发</p>',75);function N(B,W){const o=e("tt"),p=e("ExternalLinkIcon");return i(),l("div",null,[J,n("blockquote",null,[n("p",null,[s("This class does not offer real-time guarantees: it schedules tasks using the "),a(o,null,{default:u(()=>[s("Object.wait(long)")]),_:1}),s(" method. *Java 5.0 introduced the {@code java.util.concurrent} package and one of the concurrency utilities therein is the {@link java.util.concurrent.ScheduledThreadPoolExecutor ScheduledThreadPoolExecutor} which is a thread pool for repeatedly executing tasks at a given rate or delay. It is effectively a more versatile replacement for the {@code Timer}/{@code TimerTask} combination, as it allows multiple service threads, accepts various time units, and doesn't require subclassing {@code TimerTask} (just implement {@code Runnable}). Configuring {@code ScheduledThreadPoolExecutor} with one thread makes it equivalent to {@code Timer}.")])]),j,n("p",null,[s("并且，Quzrtz 并没有内置 UI 管理控制台，不过你可以使用 "),n("a",E,[s("quartzui"),a(p)]),s(" 这个开源项目来解决这个问题。")]),C,n("ul",null,[L,n("li",null,[n("p",null,[s("缺点：不支持动态添加任务（如果一定想要动态创建任务也是支持的，参见："),n("a",D,[s("xxl-job issue277"),a(p)]),s("）。")])])]),z,M,X,A,n("p",null,[s("更多关于 PowerJob 的故事，小伙伴们可以去看看 PowerJob 作者的视频 "),n("a",P,[s("《我和我的任务调度中间件》"),a(p)]),s("。简单点概括就是：“游戏没啥意思了，我要扛起了新一代分布式任务调度与计算框架的大旗！”。")]),O])}const Q=c(q,[["render",N],["__file","Java定时任务详解.html.vue"]]);export{Q as default};
