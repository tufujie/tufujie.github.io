import{_ as n}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as t,d as s}from"./app-AuAuVshg.js";const e="/assets/网关框架-53ctMIgw.png",p={},i=s('<h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介" aria-hidden="true">#</a> 简介</h2><p>本文介绍微服务为什么要有网关。</p><h2 id="网关作用" tabindex="-1"><a class="header-anchor" href="#网关作用" aria-hidden="true">#</a> 网关作用</h2><p>服务网关 = 路由转发 + 过滤器</p><p>1、路由转发：外界<strong>请求</strong>转发到<strong>微服务</strong></p><p>2、过滤器：<strong>权限校验、限流</strong>、<strong>监控</strong>（路由转发也通过过滤器）</p><h2 id="为什么需要网关" tabindex="-1"><a class="header-anchor" href="#为什么需要网关" aria-hidden="true">#</a> 为什么需要网关</h2><p>若不使用网关，情况如下：</p><ul><li><p>运维角度：路由规则与服务实例列表：若有实例增减或是IP地址变动等需要手动修改。</p></li><li><p>开发角度：以权限校验为例：需要每个微服务写同样的校验逻辑</p></li></ul><p>使用网关之后</p><ul><li><p>网关可自动获得其他微服务实例信息</p></li><li><p>网关统一维护权限</p></li></ul><h2 id="框架" tabindex="-1"><a class="header-anchor" href="#框架" aria-hidden="true">#</a> 框架</h2><figure><img src="'+e+`" alt="网关框架" tabindex="0" loading="lazy"><figcaption>网关框架</figcaption></figure><p>微服务架构：服务网关、open-service和service。</p><p><strong>1、流程：</strong></p><ul><li><p>服务网关、open-service和service启动时注册到注册中心上去；</p></li><li><p>网关做智能路由转发（包括服务发现，负载均衡）到open-service，这其中包含权限校验、监控、限流等操作，open-service聚合内部service响应，返回给网关，网关再返回给用户</p></li></ul><p><strong>2、注意点</strong></p><p><strong>多一层转发</strong>，性能下降(不大)；尽量轻</p><p><strong>防止网关单点</strong>：前边再<strong>挂nginx</strong>性能极高，基本不挂，网关就可不断添加机器。<strong>最好</strong>是网关<strong>单点</strong>服务部署在一台<strong>牛机器上</strong>（压测估算），且nginx与zuul性能相差不大。</p><p><strong>3、基本功能</strong></p><p><strong>智能路由</strong>：接收<strong>外部</strong>一切请求，并转发到后端的对外服务open-service上去；服务之间不走网关</p><p><strong>权限校验</strong>：只校验用户open-service服务请求，不校验内部</p><p><strong>API监控</strong>：监控请求，本身性能指标（如gc）；</p><p><strong>限流</strong>：配合监控限流</p><p>**API日志统一收集：**类似aspect切面，接口进出日志。</p><p><strong>A|B测试</strong>：实验配置、数据埋点（看转化率）及分流引擎(调用内部服务在open-service中)</p><h2 id="技术选型" tabindex="-1"><a class="header-anchor" href="#技术选型" aria-hidden="true">#</a> 技术选型</h2><p>开发语言：java + groovy，groovy的好处是网关服务不需要重启就可以动态的添加filter来实现一些功能；</p><p>微服务基础框架：springboot；</p><p>网关基础组件：<strong>netflix zuul；</strong></p><p>服务注册中心：consul；</p><p>权限校验：jwt；</p><p>API监控：prometheus + grafana；</p><p>API统一日志收集：logback + ELK；</p><p>压力测试：Jmeter；</p><h2 id="spring-cloud-gateway工作流程" tabindex="-1"><a class="header-anchor" href="#spring-cloud-gateway工作流程" aria-hidden="true">#</a> Spring Cloud Gateway工作流程</h2><p>![Spring Cloud Gateway工作流程](.\\media\\Spring Cloud Gateway工作流程.png)</p><p>具体的流程分析：</p><ol><li><strong>路由判断</strong>：客户端的请求到达网关后，先经过 Gateway Handler Mapping 处理，这里面会做断言（Predicate）判断，看下符合哪个路由规则，这个路由映射后端的某个服务。</li><li><strong>请求过滤</strong>：然后请求到达 Gateway Web Handler，这里面有很多过滤器，组成过滤器链（Filter Chain），这些过滤器可以对请求进行拦截和修改，比如添加请求头、参数校验等等，有点像净化污水。然后将请求转发到实际的后端服务。这些过滤器逻辑上可以称作 Pre-Filters，Pre 可以理解为“在...之前”。</li><li><strong>服务处理</strong>：后端服务会对请求进行处理。</li><li><strong>响应过滤</strong>：后端处理完结果后，返回给 Gateway 的过滤器再次做处理，逻辑上可以称作 Post-Filters，Post 可以理解为“在...之后”。</li><li><strong>响应返回</strong>：响应经过过滤处理后，返回给客户端。</li></ol><p>总结：客户端的请求先通过匹配规则找到合适的路由，就能映射到具体的服务。然后请求经过过滤器处理后转发给具体的服务，服务处理后，再次经过过滤器处理，最后返回给客户端。</p><h2 id="配置详解" tabindex="-1"><a class="header-anchor" href="#配置详解" aria-hidden="true">#</a> 配置详解</h2><h3 id="application-yaml" tabindex="-1"><a class="header-anchor" href="#application-yaml" aria-hidden="true">#</a> application.yaml</h3><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token comment"># 端口</span>
<span class="token key atrule">server</span><span class="token punctuation">:</span>
  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">9001</span>

<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> cloud<span class="token punctuation">-</span>gateway
  <span class="token comment">## GateWay配置</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">gateway</span><span class="token punctuation">:</span>
      <span class="token key atrule">routes</span><span class="token punctuation">:</span> <span class="token comment">#多个路由</span>
        <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> payment_routh  <span class="token comment"># 路由ID ， 没有固定的规则但要求唯一，建议配合服务名</span>

          <span class="token comment"># uri+predicates  要访问这个路径得先经过9001处理</span>
          <span class="token comment">#          uri: http://localhost:8001  # 匹配成功后提供服务的路由地址</span>
          <span class="token comment"># lb 属于GateWay 的关键字，代表是动态uri，即代表使用的是服务注册中心的微服务名，它默认开启使用负载均衡机制</span>
          <span class="token comment"># 可以有多个微服务，例如：cloud-order-service，cloud-goods-service，通过一个网关层</span>
          <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//cloud<span class="token punctuation">-</span>payment<span class="token punctuation">-</span>service
          <span class="token key atrule">predicates</span><span class="token punctuation">:</span>
            <span class="token punctuation">-</span> Path=/api/payment/get/<span class="token important">**</span>  <span class="token comment"># 断言，路径相匹配的进行路由，**可以多级路径，*单一路径</span>
          <span class="token key atrule">filters</span><span class="token punctuation">:</span>
            <span class="token punctuation">-</span> RewritePath=/api/(<span class="token punctuation">?</span>&lt;segment<span class="token punctuation">&gt;</span>.<span class="token important">*)</span><span class="token punctuation">,</span>/$\\<span class="token punctuation">{</span>segment<span class="token punctuation">}</span>
          <span class="token comment"># 将跳转路径中包含的/api替换成空</span>
          <span class="token comment"># 访问http://ip1:9001/api/payment/get/1就是访问http://ip2:8001/payment/get/1</span>
          <span class="token comment"># 拓展：访问http://ip1:9001/api/order/get/1就是访问http://ip3:8001/order/get/1</span>
          <span class="token comment"># 一般来说：线上都是分布式部署+集群，以实现高性能，所以都是每个服务器部署一个服务，即多个服务间ip不同，但是端口相同，通过网关统一转发到各个服务的对应接口</span>
          <span class="token comment"># 本地开发是单机模式，所以只能是多个服务ip相同，但是端口不同来进行开发测试</span>

        <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> payment_routh2
          <span class="token comment">#          uri: http://localhost:8001</span>
          <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//cloud<span class="token punctuation">-</span>payment<span class="token punctuation">-</span>service
          <span class="token key atrule">predicates</span><span class="token punctuation">:</span>
            <span class="token punctuation">-</span> Path=/payment/lb/<span class="token important">**</span>

<span class="token comment"># Eureka配置</span>
<span class="token key atrule">eureka</span><span class="token punctuation">:</span>
  <span class="token key atrule">instance</span><span class="token punctuation">:</span>
    <span class="token comment"># eureka服务端的实例名称</span>
    <span class="token key atrule">hostname</span><span class="token punctuation">:</span> cloud<span class="token punctuation">-</span>eureka<span class="token punctuation">-</span>server
  <span class="token key atrule">client</span><span class="token punctuation">:</span>
    <span class="token comment"># true表示向注册中心注册自己</span>
    <span class="token key atrule">register-with-eureka</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
    <span class="token comment"># true表示自己需要注册，# 注册进 eureka Server # 网关他本身也是一个微服务，也要注册进注册主中心</span>
    <span class="token key atrule">fetch-registry</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
    <span class="token comment"># 设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址</span>
    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>
      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>8761/eureka
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="spring-cloud-gateway-路由断言规则" tabindex="-1"><a class="header-anchor" href="#spring-cloud-gateway-路由断言规则" aria-hidden="true">#</a> Spring Cloud GateWay 路由断言规则</h3><table><thead><tr><th></th><th></th><th>例子</th><th>匹配规则</th></tr></thead><tbody><tr><td>时间</td><td>- After</td><td>- After=2022-03-20T21:02:47.789-07:00[AsiaShanghai]</td><td>请求时间在断言时间后</td></tr><tr><td>时间</td><td>- Before</td><td>- Before=2022-03-20T21:02:47.789-07:00[AsiaShanghai]</td><td>请求时间在断言时间前</td></tr><tr><td>时间</td><td>- Between</td><td>- Between=2022-03-20T21:02:47.789-07:00[AsiaShanghai]</td><td>请求时间在断言时间之间</td></tr><tr><td>Cookie</td><td>- Cookie</td><td>- Cookie=token123</td><td>请求携带的cookie有token且值为123</td></tr><tr><td>请求头</td><td>- Header</td><td>- Header=token123</td><td>请求的请求头中有token且值为123</td></tr><tr><td>Host</td><td>- Host</td><td>- Host=**.haha.com:81</td><td>请求的url的二级域名为haha，顶级域名为com，三级域名随便，可以没有，端口为81</td></tr><tr><td>请求方式</td><td>- Method</td><td>- Method=GET,POST</td><td>请求的方式为GET和POST</td></tr><tr><td>路径</td><td>- Path</td><td>- Path=/say/**</td><td>请求的路径为/say后面可以跟多级路径也可以没有</td></tr><tr><td>查询参数</td><td>- Query</td><td>- Query=skuID<br>- Query=skuID,11</td><td>请求携带参数，且参数名为skuID<br>请求携带参数，且参数名为skulD，值为11</td></tr><tr><td>权重</td><td>- Weight</td><td>- Weight=group,5</td><td>匹配到路由将在同一个组中按权重分发请求</td></tr></tbody></table><h3 id="路由和断言的对应关系" tabindex="-1"><a class="header-anchor" href="#路由和断言的对应关系" aria-hidden="true">#</a> 路由和断言的对应关系</h3><ul><li><p><strong>一对多</strong>：一个路由规则可以包含多个断言。</p></li><li><p><strong>同时满足</strong>：如果一个路由规则中有多个断言，则需要同时满足才能匹配。如上图中路由 Route2 配置了两个断言，客户端发送的请求必须同时满足这两个断言，才能匹配路由 Route2。</p></li><li><p><strong>第一个匹配成功</strong>：如果一个请求可以匹配多个路由，则映射第一个匹配成功的路由。</p></li></ul><h3 id="常见的局部过滤器" tabindex="-1"><a class="header-anchor" href="#常见的局部过滤器" aria-hidden="true">#</a> 常见的局部过滤器</h3><table><thead><tr><th>过滤器工厂</th><th>作用</th><th>参数</th><th>示例</th></tr></thead><tbody><tr><td>AddRequestHeader</td><td>为原始请求添加Header</td><td>Header的名称及值</td><td>- AddRequestHeader=my-request-header1024.<br>为原始请求添加名为 my-request-header，值为 1024 的请求头</td></tr><tr><td>AddRequestParameter</td><td>为原始请求添加请求参数</td><td>参数名称及值</td><td>- AddRequestParameter=my-request-param, passjava.cn</td></tr><tr><td>AddResponseHeader</td><td>为原始响应添加Header</td><td>Header的名称及值</td><td>- AddResponseHeader=my-response-header,passjava.cn</td></tr><tr><td>PrefixPath</td><td>为原始请求路径添加前缀</td><td>前缀路径</td><td>- PrefixPath=/consumer</td></tr><tr><td>RedirectTo</td><td>重定向到指定的URL</td><td>http状态码及重定向的url</td><td>- RedirectTo=302,http://www.passjava.cn</td></tr><tr><td>RewritePath</td><td>重写原始的请求路径</td><td>原始路经正则表达式以及重写后路径的正则表达式</td><td>示例如下</td></tr></tbody></table><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token punctuation">-</span> RewritePath=/api/(&lt;segment<span class="token punctuation">&gt;</span>.<span class="token important">*)</span><span class="token punctuation">,</span>/$\\<span class="token punctuation">{</span>segment<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,50),r=[i];function d(o,l){return a(),t("div",null,r)}const m=n(p,[["render",d],["__file","微服务网关总结.html.vue"]]);export{m as default};
