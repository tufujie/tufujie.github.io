import{_ as t}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as d,c as r,d as o}from"./app-AuAuVshg.js";const s={},n=o('<h2 id="kafka、activemq、rabbitmq、rocketmq" tabindex="-1"><a class="header-anchor" href="#kafka、activemq、rabbitmq、rocketmq" aria-hidden="true">#</a> Kafka、ActiveMQ、RabbitMQ、RocketMQ</h2><table><thead><tr><th></th><th><strong>RabbitMQ</strong></th><th><strong>ActiveMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td><strong>公司/社区</strong></td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td><strong>开发语言</strong></td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td><strong>协议支持</strong></td><td>AMQP</td><td>OpenWire、STOMP、REST、XMPP、AMQP</td><td>自定义</td><td>自定义协议，社区封装了http协议支持</td></tr><tr><td><strong>客户端支持语言</strong></td><td>官方支持Erlang、Java、Ruby等，社区查出多种API，几乎支持所有语言</td><td>Java、C、C++、Python、PHPPerl、.net等</td><td>Java、C++(不成熟)</td><td>官方支持Java，社区产出多种API，如PHP，Python等</td></tr><tr><td><strong>单机吞吐量</strong></td><td>万级（5.95w/s）。 为保证消息可靠性在吞吐量上做了取舍。</td><td>万级</td><td>十万级（11.6w/s）</td><td>十万级（17.3w/s）</td></tr><tr><td><strong>消息延迟/时效性</strong></td><td>微秒级。 RabbitMQ的一大特点，延迟最低。</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td><strong>可用性</strong></td><td>高，基于主从架构实现可用性</td><td>高，基于主从架构实现可用性</td><td>非常高，分布式架构</td><td>非常高，分布式架构，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td><strong>消息可靠性</strong></td><td>经过参数优化配置，可以做到0丢失</td><td>有较低的概率丢失数据</td><td>经过参数优化配置，可以做到0丢失</td><td>经过参数优化配置，可以做到0丢失</td></tr><tr><td><strong>性能的稳定性</strong></td><td>消息堆积时，性能不稳定、明显下降</td><td></td><td>队列较多、消息堆积时性能稳定</td><td>队列/分区多时性能不稳定，明显下降。消息堆积时性能稳定</td></tr><tr><td><strong>功能支持</strong></td><td>基于erlang开发，所以并发性能极强，性能极好，延时低</td><td>MQ领域的功能极其完备</td><td>MQ功能较为完备，分布式扩展性好</td><td>功能较为简单，主要支持加单MQ功能</td></tr><tr><td><strong>优势</strong></td><td>erlang语言开发，性能极好、延时很低，吞吐量万级、MQ功能完备，管理界面非常好，社区活跃；互联网公司使用较多</td><td>非常成熟，功能强大，在业内大量公司和项目中都有应用</td><td>接口简单易用，阿里出品有保障，吞吐量大，分布式扩展方便、社区比较活跃，支持大规模的Topic、支持复杂的业务场景，可以基于源码进行定制开发。</td><td>超高吞吐量，ms级的时延，极高的可用性和可靠性，分布式扩展方便</td></tr><tr><td><strong>劣势</strong></td><td>吞吐量较低，erlang语音开发不容易进行定制开发，集群动态扩展麻烦</td><td>偶尔有较低概率丢失消息，社区活跃度不高</td><td>接口不是按照标准JMS规范走的，有的系统迁移要修改大量的代码，技术有被抛弃的风险</td><td>有可能进行消息的重复消费</td></tr><tr><td><strong>应用/使用场景</strong></td><td>适合对可靠性和实时性要求高，对速度要求不高的场景。适合小公司。</td><td>主要用于解耦和异步，较少用在大规模吞吐的场景中</td><td>用于大规模吞吐、复杂业务中。适合对可靠性要求很高的场景。适合金融互联网（特别是电商的大量交易涌入，后端无法及时处理的情况）。在阿里双11已经经历了多次考验。</td><td>主要追求高吞吐量、高速度与持久化。主要用于处理活跃的流式数据，大数据量的数据处理上。适合日志采集，数据采集。在大数据的实时计算和日志采集中被大规模使用，是业界的标准</td></tr></tbody></table><h2 id="功能对比" tabindex="-1"><a class="header-anchor" href="#功能对比" aria-hidden="true">#</a> <strong>功能对比</strong></h2><table><thead><tr><th><strong>项</strong></th><th><strong>RabbitMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td><strong>延迟消息</strong></td><td>支持</td><td>支持</td><td>不支持。 但可以手写代码来间接支持。</td></tr><tr><td><strong>主从切换</strong></td><td>自动切换。 最早加入集群的slave会成为master；因为新加入的slave不同步master之前的数据，所以可能会出现部分数据丢失</td><td>不支持自动切换。 master失效以后不能向master发送信息，consumer大概30s（默认）可以感知此事件，此后从slave消费；如果master无法恢复，异步复制时可能出现部分信息丢失</td><td>自动切换。 N个副本，允许N-1个失效；master失效以后自动从isr中选择一个主。</td></tr><tr><td><strong>事务消息</strong></td><td>支持</td><td>支持</td><td>不支持</td></tr><tr><td><strong>顺序消费</strong></td><td>支持顺序消费。</td><td>支持。 在顺序消息场景下，消费失败时消费队列将会暂停</td><td>支持。 但是一台Broker宕机后，就会产生消息乱序</td></tr><tr><td><strong>消费失败重试</strong></td><td>支持失败重试</td><td>支持失败重试。 offset存储在broker中</td><td>不支持失败重试。 offset存储在consumer中，无法保证。 0.8.2版本后支持将offset存储在zk中。</td></tr><tr><td><strong>消息重新消费</strong></td><td></td><td>支持按照时间来重新消息</td><td>支持通过修改offset来重新消费</td></tr><tr><td><strong>Broker端消息过滤</strong></td><td>不支持</td><td>支持 通过tag过滤，类似于子topic</td><td>不支持</td></tr><tr><td><strong>消费并行度</strong></td><td>可一次抓取多条一起消费。 镜像模式下其实也是从master消费</td><td>顺序消费：消费并行度和分区数一致 乱序消费：消费服务器的消费线程数之和</td><td>消费并行度和分区数一致</td></tr><tr><td><strong>消费方式</strong></td><td>broker push</td><td>consumer pull 或 broker push</td><td>consumer pull</td></tr><tr><td><strong>批量发送</strong></td><td>不支持</td><td>不支持</td><td>支持 默认producer缓存、压缩，然后批量发送</td></tr><tr><td><strong>消息清理</strong></td><td>支持。</td><td>支持。</td><td>支持。</td></tr></tbody></table><h2 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点" aria-hidden="true">#</a> <strong>优缺点</strong></h2><table><thead><tr><th><strong>项</strong></th><th><strong>RabbitMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>kafka</strong></th></tr></thead><tbody><tr><td><strong>优点</strong></td><td>1、稳定可靠，数据不会丢失。 2、管理界面较丰富</td><td>1、在高吞吐、低延迟、高可用上有非常好的表现；消息堆积时，性能也很好。 2、稳定可靠，数据不会丢失。 3、支持多种消费方式、broker消息过滤、消息顺序消费、consumer可水平扩展，消费能力很强。 4、支持事务</td><td>1、这些方面表现很好：高吞吐、低延迟、高可用、集群热扩展、集群容错 2、producer端提供缓存、压缩功能，可节省性能，提高效率。 3、提供顺序消费能力 4、生态完善，在大数据处理方面有大量配套的设施。</td></tr><tr><td><strong>缺点</strong></td><td>1、在吞吐量、高可用略差。 2. erlang 语言难度较大。基本只能依赖于开源社区的快速维护和修复bug，不利于做二次开发和维护 3、不支持事务。 4、消息吞吐能力较差，消息堆积时，性能会明显降低。</td><td>1、吞吐量不如于kafka。 2、不支持主从自动切换，master失效后，消费者需要一定的时间才能感知。 3、客户端只支持Java 4、生态的支持度不如RabbitMQ和kafka。</td><td>1、消费集群数目受到分区数目的限制。 2、单机topic多时，性能会明显降低。单机超过64个队列/分区，Load会发生明显的飙高现象，队列越多，load越高，发送消息响应时间变长 3、不支持事务 4、支持消息顺序，但是一台代理宕机后，就会产生消息乱序； 5、消费失败不支持重试</td></tr></tbody></table><h2 id="基础对比" tabindex="-1"><a class="header-anchor" href="#基础对比" aria-hidden="true">#</a> <strong>基础对比</strong></h2><table><thead><tr><th><strong>项</strong></th><th><strong>RabbitMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>kafka</strong></th></tr></thead><tbody><tr><td><strong>设计定位</strong></td><td>可靠消息传输。和RocketMQ类似。</td><td>非日志的可靠消息传输。 例如：订单，交易，充值，流计算，消息推送，日志流式处理，binglog分发等</td><td>系统间的数据流管道，实时数据处理。 例如：常规的消息系统、网站活性跟踪，监控数据，日志收集、处理等</td></tr><tr><td><strong>成熟度</strong></td><td>成熟</td><td>成熟</td><td>日志领域成熟</td></tr><tr><td><strong>所属社区／公司</strong></td><td>Mozilla Public License</td><td>Alibaba开发，已加入到Apache下</td><td>Apache</td></tr><tr><td><strong>社区活跃度</strong></td><td>高</td><td>搞</td><td>高</td></tr><tr><td><strong>API完备性</strong></td><td>高</td><td>高</td><td>高</td></tr><tr><td><strong>文档完备性</strong></td><td>高</td><td>高</td><td>高</td></tr><tr><td><strong>开发语言</strong></td><td>Erlang</td><td>Java</td><td>Scala</td></tr><tr><td><strong>支持协议</strong></td><td>AMQP，同时支持MQTT、STOMP等协议。</td><td>自己定义的JMS协议。</td><td>一套自行设计的基于TCP的二进制协议。</td></tr><tr><td><strong>客户端语言</strong></td><td>Java、C、 C++、 Python、 PHP、Perl 等</td><td>Java</td><td>C/C++、Python、Go、Erlang、.NET、Ruby、Node.js、PHP等</td></tr><tr><td><strong>持久化方式</strong></td><td>内存、文件</td><td>磁盘文件</td><td>磁盘文件</td></tr></tbody></table><h2 id="可用性与可靠性对比" tabindex="-1"><a class="header-anchor" href="#可用性与可靠性对比" aria-hidden="true">#</a> <strong>可用性与可靠性对比</strong></h2><table><thead><tr><th><strong>项</strong></th><th><strong>RabbitMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>kafka</strong></th></tr></thead><tbody><tr><td><strong>部署方式</strong></td><td>单机／集群</td><td>单机／集群</td><td>单机／集群</td></tr><tr><td><strong>集群管理</strong></td><td></td><td>name server</td><td>zookeeper</td></tr><tr><td><strong>选主方式</strong></td><td>最早加入集群的broker</td><td>不支持自动选主。通过设定brokername、brokerId实现，brokername相同，brokerid=0时为maser，其他为slave</td><td>从ISR中自动选举一个leader</td></tr><tr><td><strong>可用性</strong></td><td>高 主从，采用镜像模式实现，数据量大时可能产生性能瓶颈</td><td>非常高 分布式、主从</td><td>非常高 分布式、主从</td></tr><tr><td><strong>主从切换</strong></td><td>自动切换。 最早加入集群的slave会成为master；因为新加入的slave不同步master之前的数据，所以可能会出现部分数据丢失</td><td>不支持自动切换。 master失效以后不能向master发送信息，consumer大概30s（默认）可以感知此事件，此后从slave消费；如果master无法恢复，异步复制时可能出现部分信息丢失</td><td>自动切换。 N个副本，允许N-1个失效；master失效以后自动从isr中选择一个主；</td></tr><tr><td><strong>数据可靠性</strong></td><td>好。 producer支持同步／异步ack。支持队列数据持久化，镜像模式中支持主从同步</td><td>很好。 producer单条发送，broker端支持同步刷盘、异步刷盘，同步双写，异步复制。</td><td>很好。 支持producer单条发送、同步刷盘、同步复制、异步。</td></tr><tr><td><strong>消息写入性能</strong></td><td>一般。 约为RocketMQ的1/2，</td><td>很好。 每条10个字节测试：单机单broker约7w/s，单机3个broker约12w/s</td><td>非常好。 每条10个字节测试：百万条/s</td></tr><tr><td><strong>性能的稳定性</strong></td><td>消息堆积时，性能不稳定、明显下降</td><td>队列较多、消息堆积时性能稳定</td><td>队列/分区多时性能不稳定，明显下降。 消息堆积时性能稳定</td></tr><tr><td><strong>单机支持的队列数</strong></td><td>依赖于内存</td><td>单机支持最高5万个队列，Load不会发生明显变化</td><td>单机超过64个队列/分区，Load会发生明显的飙高现象，队列越多，load越高，发送消息响应时间变长</td></tr><tr><td><strong>堆积能力</strong></td><td>一般。 生产者、消费者正常时，性能表现稳定；消费者不消费时，性能不稳定</td><td>非常好 所有消息存储在同一个commit log中</td><td>非常好 消息存储在log中，每个分区由一个或多个segment log文件</td></tr><tr><td><strong>复制备份</strong></td><td>普通模式下不复制； 镜像模式下：消息先到master，然后写到slave上。加入集群之前的消息不会被复制到新的slave上。</td><td>同步双写 异步复制：slave启动线程从master中拉数据</td><td>消息先写入leader的log，followers从leader中pull数据，pull到数据以后先ack leader，然后写入log中。 ISR中维护与leader同步的列表，落后太多的follwer会被删除掉</td></tr><tr><td><strong>消息投递实时性</strong></td><td>毫秒级</td><td>毫秒级 支持pull、push两种模式，延时通常在毫秒级</td><td>毫秒级 具体由consumer轮询间隔时间决定</td></tr></tbody></table><h2 id="运维对比" tabindex="-1"><a class="header-anchor" href="#运维对比" aria-hidden="true">#</a> <strong>运维对比</strong></h2><table><thead><tr><th><strong>项</strong></th><th><strong>RabbitMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>kafka</strong></th></tr></thead><tbody><tr><td><strong>系统维护</strong></td><td>Erlang语言开发，维护成本高</td><td>java语言开发，维护成本低</td><td>Scala语言开发，维护成本高</td></tr><tr><td><strong>部署依赖</strong></td><td>Erlang环境</td><td>nameserver</td><td>zookeeper</td></tr><tr><td><strong>管理后台</strong></td><td>官方提供rabbitmqadmin</td><td>官方提供，rocketmq-console</td><td>官网不提供，第三方开源管理工具可供使用；不用重新开发</td></tr><tr><td><strong>管理后台功能</strong></td><td>overview、connections、channels、exchanges、queues、admin</td><td>Cluster、Topic、Connection、NameServ、Message、Broker、Offset、Consumer</td><td><strong>Kafka Web Conslole</strong> Brokers列表；Kafka 集群中 Topic列表，及对应的Partition、LogSize等信息；Topic对应的Consumer Groups、Offset、Lag等信息； 生产和消费流量图、消息预览 <strong>KafkaOffsetMonitor</strong> Kafka集群状态；Topic、Consumer Group列表；图形化展示topic和consumer之间的关系；图形化展示consumer的Offset、Lag等信息 <strong>Kafka Manager</strong> 管理几个不同的集群；监控集群的状态(topics, brokers, 副本分布, 分区分布)；产生分区分配(Generate partition assignments)基于集群的当前状态；重新分配分区</td></tr></tbody></table><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>对于吞吐量来说kafka和RocketMQ支撑高吞吐，ActiveMQ和RabbitMQ比他们低一个数量级。对于延迟量来说RabbitMQ是最低的。</p><p><strong>总结一下：</strong></p><p>选择中间件的可以从这些维度来考虑：可靠性，性能，功能，可运维行，可拓展性，社区活跃度。目前常用的几个中间件，ActiveMQ作为&quot;老古董&quot;，市面上用的已经不多，其它几种：</p><p><strong>RabbitMQ：</strong></p><p>优点：轻量，迅捷，容易部署和使用，拥有灵活的路由配置</p><p>缺点：性能和吞吐量不太理想，不易进行二次开发</p><p><strong>RocketMQ：</strong></p><p>优点：性能好，高吞吐量，稳定可靠，有活跃的中文社区</p><p>缺点：兼容性上不是太好</p><p><strong>Kafka</strong>：</p><p>优点：拥有强大的性能及吞吐量，兼容性很好</p><p>缺点：由于&quot;攒一波再处理&quot;导致延迟比较高</p><ol><li><p>中⼩型公司⾸选RabbitMQ：管理界⾯简单，⾼并发。</p></li><li><p>⼤型公司可以选择RocketMQ：更⾼并发，可对rocketmq进⾏定制化开发。</p></li><li><p>⽇志采集功能，⾸选kafka，专为⼤数据准备（<mark>高吞吐量、低延迟</mark>）。</p></li></ol><p>我们的系统是面向用户的C端系统，<strong>具有一定的并发量，对性能也有比较高的要求，所以选择了低延迟、吞吐量比较高，可用性比较好的RocketMQ</strong>。</p>',27),a=[n];function e(g,h){return d(),r("div",null,a)}const c=t(s,[["render",e],["__file","消息队列对比.html.vue"]]);export{c as default};
