import{_ as i}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as l,c as p,d as a}from"./app-AuAuVshg.js";const r="/assets/jstack问题定位-SXKo1nfI.png",e={},o=a(`<h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介" aria-hidden="true">#</a> 简介</h2><p>本文介绍如何排查Java的系统问题。包括：如何得知系统出问题了，排查步骤简述，CPU、内存、磁盘、网络、垃圾回收、死锁的详细排查步骤。</p><p>如果线上出了问题，首先判断是业务问题还是整个系统的问题。如果是业务问题，就去看<mark>应用的日志</mark>等进行排查。如果出现了如下问题，就可能是整个系统的问题</p><ol><li><p><mark>大量接口都很慢</mark></p></li><li><p><mark>页面打不开</mark></p></li></ol><h2 id="系统问题排查简介" tabindex="-1"><a class="header-anchor" href="#系统问题排查简介" aria-hidden="true">#</a> 系统问题排查简介</h2><p><strong>如何得知系统出问题了？</strong></p><p>系统出问题时，我们需要进行详细排查，一般情况下，有以下场景我们可以得知线上出问题了：</p><ol><li><p><mark>用户反馈</mark>功能不能正常使用</p></li><li><p>监控系统报警提醒</p></li><li><p><mark>监控系统的邮件或者短信提醒</mark></p></li></ol><p><strong>系统问题排查步骤</strong></p><p>以下按顺序进行</p><ol><li><p>是否<mark>CPU</mark>占用过高</p></li><li><p>是否<mark>内存</mark>占用过高</p></li><li><p>是否<mark>磁盘</mark>占用过高</p></li><li><p>是否<mark>网络</mark>故障</p></li><li><p>查看<mark>后台日志</mark></p></li><li><p>是否是<mark>数据库</mark>问题（比如：<mark>索引失效、死锁</mark>）</p></li><li><p>是否是<mark>垃圾回收</mark>导致</p></li><li><p>是否<mark>死锁</mark>等</p></li></ol><h2 id="cpu占用过高" tabindex="-1"><a class="header-anchor" href="#cpu占用过高" aria-hidden="true">#</a> CPU占用过高</h2><h3 id="什么场景需要排查cpu占用" tabindex="-1"><a class="header-anchor" href="#什么场景需要排查cpu占用" aria-hidden="true">#</a> <strong>什么场景需要排查CPU占用？</strong></h3><ol><li><p>访问接口的响应速度很慢。</p></li><li><p>系统崩溃无响应</p></li><li><p>压测时要查看CPU、内存、load、rt、qps等指标</p></li></ol><h3 id="步骤简述" tabindex="-1"><a class="header-anchor" href="#步骤简述" aria-hidden="true">#</a> <strong>步骤简述</strong></h3><ol><li><p>定位进程         （命令：<mark>top</mark>）</p></li><li><p>定位线程         （命令：<mark>top -Hp</mark> 进程号）</p></li><li><p>定位代码位置  （命令：<mark>jstack</mark>）</p></li></ol><h3 id="排查方法详述" tabindex="-1"><a class="header-anchor" href="#排查方法详述" aria-hidden="true">#</a> <strong>排查方法详述</strong></h3><ol><li><p>找到占CPU最高的进程。</p><ol><li>top命令，记下进程号（PID）。假设最高的是：6418</li></ol></li><li><p>通过进程找到对应的线程。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code># 因为Java是单进程多线程的，假设最高的是：4519
top -Hp 6418
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>通过线程定位到代码大概的位置信息。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>printf %x 4519。结果为：0x1af4
jstack 6418 | grep &#39;0x1af4&#39; -A 30 ---color
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>结果大概是这样的：</p></li></ol><figure><img src="`+r+'" alt="IMG_256" tabindex="0" loading="lazy"><figcaption>IMG_256</figcaption></figure><p><strong>可能导致CPU使用率飙升的操作</strong></p><ol><li><p>无限循环（死循环）的while</p></li><li><p>经常使用Young GC</p></li><li><p>频繁的GC 如果访问量很高，可能会导致频繁的GC甚至Full GC。当调用量很大时，内存分配将如此之快以至于GC线程将连续执行，这将导致CPU飙升。</p></li><li><p>序列化和反序列化</p><ol><li>稍后将给出一个示例：当程序执行xml解析时，调用量会增加，从而导致CPU变满。</li></ol></li><li><p>正则表达式</p><ol><li>我遇到了正则表达式使CPU充满的情况：原因可能是Java正则表达式使用的引擎实现是NFA自动机，它将在字符匹配期间执行回溯。</li></ol></li><li><p>线程上下文切换。</p><ol><li>有许多已启动的线程，这些线程的状态在Blocked（锁定等待，IO等待等）和Running之间发生变化。当锁争用激烈时，这种情况很容易发生。</li></ol></li></ol><h2 id="内存占用过高" tabindex="-1"><a class="header-anchor" href="#内存占用过高" aria-hidden="true">#</a> 内存占用过高</h2><h3 id="步骤简述-1" tabindex="-1"><a class="header-anchor" href="#步骤简述-1" aria-hidden="true">#</a> <strong>步骤简述</strong></h3><p>定位Java程序内存使用过高或者内存泄漏的问题跟CPU也类似，可分为以下步骤：</p><ol><li><p>定位进程         （命令：top）</p></li><li><p>定位线程         （命令：top -Hp 进程号）</p></li><li><p>定位代码位置  （命令：jmap生成快照，**MAT **/ **jprofiler **/VisualVM / jhat 查看快照数据）</p></li></ol><p><strong>1.定位进程</strong></p><ol><li><p>top</p></li><li><p>按下M（按内存占用由大到小排序）</p><ol><li>// 假设定位到的进程ID为14279。</li></ol></li></ol><p><strong>2.定位线程</strong></p><p>top -Hp 14279;</p><p>按下M（按内存占用由大到小排序）</p><p>top - 18:33:07 up 25 days,  7:48,  1 user,  load average: 0.17, 0.27, 0.23Threads:  54 total,   1 running,  53 sleeping,   0 stopped,   0 zombie%Cpu(s):  0.5 us,  0.7 sy,  0.0 ni, 98.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 stKiB Mem :  8168236 total,   231696 free,  3660496 used,  4276044 buff/cacheKiB Swap:   969964 total,   969964 free,        0 used.  4197860 avail Mem</p><p>PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND14293 weiping   20   0 4508772  97036  18112 S  10    12 152:35.42 java14279 weiping   20   0 4508772  97036  18112 S  5.0  1.2   0:00.00 java14282 weiping   20   0 4508772  97036  18112 S  0.0  1.2   0:00.37 java</p><p>注意观察两点：</p><ol><li><p>线程的数量</p><ol><li><p>可以看到，它线程数是54（左上角的Threads项），属于正常。</p></li><li><p>若比较大（比如大于1000），要考虑是不是代码有问题：</p><ol><li><p>是不是代码里手动起了多个线程。比如：使用OkHttpClient时每次都创建了连接池（ConnectionPool）；应该是只创建一个连接池的。</p></li><li><p>是不是自己创建的线程池最大个数太大了。</p></li></ol></li></ol></li><li><p>占内存大的线程的PID</p><ol><li>如果线程数量正常，就要dump内存的快照信息来查看。</li></ol></li></ol><p><strong>3.定位代码位置</strong></p><p>如果是线上环境，注意dump之前必须先将流量切走，否则大内存dump是直接卡死服务。</p><p>dump当前快照：jmap -dump:format=b,file=dump.hprof 14279</p><p>查找实例数比较多的业务相关的实例，然后找到相应代码查看。（使用工具查看dump.hprof。比如：MAT、VisualVM、jhat）</p><h2 id="磁盘问题" tabindex="-1"><a class="header-anchor" href="#磁盘问题" aria-hidden="true">#</a> 磁盘问题</h2><p><strong>步骤简介</strong></p><ol><li><p>是否磁盘快用完了（命令：<strong>df</strong>、du）</p></li><li><p>TPS是否正常（命令：<strong>iostat</strong>、vmstat、lsof）</p></li></ol><p><strong>1. 磁盘快用尽</strong></p><p>df、du 查看磁盘使用情况。</p><p><strong>2. TPS</strong></p><p>iostat查看tps。</p><h2 id="网络问题" tabindex="-1"><a class="header-anchor" href="#网络问题" aria-hidden="true">#</a> 网络问题</h2><p>dstat或者netstat</p><p>dstat -n</p><p>netstat</p><h2 id="垃圾回收" tabindex="-1"><a class="header-anchor" href="#垃圾回收" aria-hidden="true">#</a> 垃圾回收</h2><p><strong>什么情况下，GC会对程序产生影响？</strong></p><p>不管Minor GC还是FGC，都会造成一定程度的程序卡顿（即Stop The World：GC线程开始工作，其他工作线程被挂起），即使采用ParNew、CMS或者G1这些更先进的垃圾回收算法，也只是在减少卡顿时间，而并不能完全消除卡顿。</p><p>那到底什么情况下，GC会对程序产生影响呢？根据严重程度从高到底，包括以下4种情况：</p><ol><li><p>FGC过于频繁</p><ol><li><p>FGC通常比较慢，少则几百毫秒，多则几秒，正常情况FGC每隔几个小时甚至几天才执行一次，对系统的影响还能接受。</p></li><li><p>一旦出现FGC频繁（比如几十分钟执行一次），是存在问题的，会导致工作线程频繁被停止，让系统看起来一直有卡顿现象，也会使得程序的整体性能变差。</p></li></ol></li><li><p>YGC耗时过长</p><ol><li><p>一般来说，YGC的总耗时在几十或者上百毫秒是比较正常的，虽然会引起系统卡顿几毫秒或者几十毫秒，这种情况几乎对用户无感知，对程序的影响可以忽略不计。</p></li><li><p>如果YGC耗时达到了1秒甚至几秒（都快赶上FGC的耗时了），那卡顿时间就会增大，加上YGC本身比较频繁，就会导致比较多的服务超时问题。</p></li></ol></li><li><p>FGC耗时过长</p><ol><li>FGC耗时增加，卡顿时间也会随之增加，尤其对于高并发服务，可能导致FGC期间比较多的超时问题，可用性降低，这种也需要关注。</li></ol></li><li><p>YGC过于频繁</p><ol><li>即使YGC不会引起服务超时，但是YGC过于频繁也会降低服务的整体性能，对于高并发服务也是需要关注的。</li></ol></li></ol><p>其中，「<strong>FGC过于频繁</strong>」和「<strong>YGC耗时过长</strong>」，这两种情况属于比较典型的GC问题，大概率会对程序的服务质量产生影响。剩余两种情况的严重程度低一些，但是对于高并发或者高可用的程序也需要关注。</p><h3 id="如何排查" tabindex="-1"><a class="header-anchor" href="#如何排查" aria-hidden="true">#</a> <strong>如何排查</strong></h3><ol><li><p>公司的监控系统：大部分公司都会有，可全方位监控JVM的各项指标。</p></li><li><p>JDK自带工具：jmap、jstat</p><ol><li><p>查看堆内存各区域的使用率以及GC情况：jstat -gcutil pid 1000   （重点关注结果中的YGC、YGCT、FGC、FGCT、GCT）</p></li><li><p>查看堆内存中的存活对象，并按空间排序：jmap -histo pid | head -n20</p></li><li><p>dump堆内存文件：jmap -dump:format=b,file=heap pid</p></li></ol></li><li><p>第三方工具：MAT、jprofiler</p></li></ol>',57),t=[o];function n(s,d){return l(),p("div",null,t)}const c=i(e,[["render",n],["__file","Java系统问题排查方法.html.vue"]]);export{c as default};
