import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as n,c as s,d as t}from"./app-AuAuVshg.js";const p={},e=t(`<ul><li><p>数字TopK，从大到小，例如分数排名，例如：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>字符串出现次数TopK，例如<mark>排行榜</mark>，<mark>热搜</mark>，例如：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> strArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">&quot;test&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;test&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;test1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;test2&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code><span class="token comment">// 先生成Map，统计每个字符串出现的个数，value是字符串出现的个数，然后根据个数排序</span>
<span class="token punctuation">{</span>
    <span class="token property">&quot;test&quot;</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    <span class="token property">&quot;test1&quot;</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token property">&quot;test2&quot;</span><span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="堆排序法" tabindex="-1"><a class="header-anchor" href="#堆排序法" aria-hidden="true">#</a> 堆排序法</h2><p>这里说的是堆排序法，而不是快排或者希尔排序。虽然理论时间复杂度都是 O(nlogn)，但是堆排在做 topK 的时候有一个优势，就是可以维护一个仅包含 k 个数字的小顶堆（想清楚，为啥是小顶堆哦），当新加入的数字大于堆顶数字的时候，将堆顶元素剔除，并加入新的数字。</p><h2 id="类似快排法" tabindex="-1"><a class="header-anchor" href="#类似快排法" aria-hidden="true">#</a> 类似快排法</h2><p>快排大家都知道，针对 topK 问题，可以对快排进行改进。仅对部分数据进行递归计算。比如，在 100 个数字中，找最大的 10 个，第一次循环的时候，povit 被移动到了 80 的位置，则接下来仅需要在后面的 20 个数字中找最大的 10 个即可。</p><p>这样做的优势是，理论最优时间复杂度可以达到 O(n)，不过平均时间复杂度还是 O(nlogn)。需要说明的是，通过这种方式，找出来的最大的 k 个数字之间，是无序的。</p><h2 id="使用-bitmap" tabindex="-1"><a class="header-anchor" href="#使用-bitmap" aria-hidden="true">#</a> 使用 bitmap</h2><p>有时候 topK 问题会遇到数据量过大，内存无法全部加载。这个时候，可以考虑将数据存放至 bitmap 中，方便查询。</p><p>比如，给出 10 个 int 类型的数据，分别是【13，12，11，1，2，3，4，5，6，7】，int 类型的数据每个占据 4 个字节，那这个数组就占据了 40 个字节。现在，把它们放到一个 16 个长度 bool 的 bitmap 中，结果就是二进制的【0011100011111110】，在将空间占用降低至 4 字节的同时，也可以很方便的看出，最大的 3 个数字，分别是 13，12 和 11。</p><p>需要说明的是，bitmap 结合跳表一起使用往往有奇效。比如以上数据还可以记录成：从第 1 位开始，有连续 7 个 1；从第 11 位开始，有连续 3 个 1。这样做，空间复杂度又得到了进一步的降低。</p><p>这种做法的优势，当然是降低了空间复杂度。不过需要注意一点，bitmap 比较适合不重复且有范围（比如，数据均在 0 ～ 10 亿之间）的数据的查询。至于有重复数据的情况，可以考虑与 hash 等结构的混用。</p><h2 id="使用-hash" tabindex="-1"><a class="header-anchor" href="#使用-hash" aria-hidden="true">#</a> 使用 hash</h2><p>如果遇到了查询 string 类型数据的大小，可以考虑 hash 方法。</p><p>举个例子，10 个 string 数字【&quot;1001&quot;，&quot;23&quot;，&quot;1002&quot;，&quot;3003&quot;，&quot;2001&quot;，&quot;1111&quot;，&quot;65&quot;，&quot;834&quot;，&quot;5&quot;，&quot;987&quot;】找最大的 3 个。我们先通过长度进行 hash，得到长度最大为 4，且有 5 个长度为 4 的 string。接下来再通过最高位值做 hash，发现有 1 个最高位为&quot;3&quot;的，1 个为&quot;2&quot;的，3 个为&quot;1&quot;的。接下来，可以通过再设计 hash 函数，或者是循环的方式，在 3 个最高位为&quot;1&quot;的 string 中找到最大的一个，即可找到 3 个最值大的数据。</p><p>这种方法比较适合网址或者电话号码的查询。缺点就是如果需要多次查询的话，需要多次计算 hash，并且需要根据实际情况设计多个 hash 函数。</p><h2 id="hashmap" tabindex="-1"><a class="header-anchor" href="#hashmap" aria-hidden="true">#</a> HashMap</h2><p>接着统计每个小文件中出现频数最高的100个词。可以使用HashMap来实现，其中key为词，value为该词出现的频率。</p><ul><li>对于遍历到的词x，如果在map中不存在，则执行 map.put(x, 1)。</li><li>若存在，则执行 map.put(x, map.get(x)+1)，将该词出现的次数加1。</li><li>接着遍历 map，构建一个 100 个元素的小顶堆，若遍历到的字符串的出现次数大于堆顶字符串的出现次数，则进行替换</li></ul><h2 id="字典树" tabindex="-1"><a class="header-anchor" href="#字典树" aria-hidden="true">#</a> 字典树</h2><p>字典树（trie）的具体结构和查询方式。这里主要说一下优缺点。</p><p>字典树的思想，还是通过前期建立索引信息，后期可以反复多次查询，并且后期增删数据也很方便。比较适合于需要反复多次查询的情况。</p><p>比如，反复多次查询字符序（例如：z&gt;y&gt;...&gt;b&gt;a）最大的 k 个 url 这种，使用字典树把数据存储一遍，就非常适合。既减少了空间复杂度，也加速了查询效率。</p><h2 id="堆排序" tabindex="-1"><a class="header-anchor" href="#堆排序" aria-hidden="true">#</a> 堆排序</h2><p><strong>小顶堆</strong>，PriorityQueue默认小顶堆，即优先级最小的元素位于队列头部</p><h3 id="混合查询" tabindex="-1"><a class="header-anchor" href="#混合查询" aria-hidden="true">#</a> <strong>混合查询</strong></h3><p>以上几种方法，都是比较独立的方法。其实，在实际工作中，遇到更多的问题还是混合问题，这就需要我们对相关的内容，融会贯通并且做到活学活用。</p><p>我举个例子：我们的分布式服务跑在 10 台不同机器上，每台机器上部署的服务均被请求 10000 次，并且记录了这 10000 次请求的耗时（耗时值为 int 数据），找出这 10*10000 次请求中，从高到低的找出耗时最大的 50 个。看看这个问题，很现实吧。我们试着用上面介绍的方法，组合一下来求解。</p><h4 id="方法一" tabindex="-1"><a class="header-anchor" href="#方法一" aria-hidden="true">#</a> <strong>方法一</strong></h4><p>首先，对每台机器上的 10000 个做类似快排，找出每台机器上 top50 的耗时信息。此时，单机上的这 50 条数据是无序的。</p><p>然后，再将 10 台机器上的 50 条数据（共 500 条）放到一起，再做一次类似快排，找到最大的 50 个（此时应该这 50 个应该是无序的）。</p><p>最后，对这 50 个数据做快排，从而得到最终结果。</p><h4 id="方法二" tabindex="-1"><a class="header-anchor" href="#方法二" aria-hidden="true">#</a> <strong>方法二</strong></h4><p>首先通过堆排，分别找出 10 台机器上耗时最高的 50 个数据，此时的这 50 个数据，已经是从大到小有序的了。</p><p>然后，我们依次取出 10 台机器中，耗时最高的 5 条放入小顶堆中。</p><p>最后，遍历 10 台机器上的数据，每台机器从第 6 个数据开始往下循环，如果这个值比堆顶的数据大，则抛掉堆顶数据并且把它加入，继续用下一个值进行同样比较。如果这个值比堆顶的值小，则结束当前循环，并且在下一台机器上做同样操作。</p><p>以上我介绍了两种方法，并不是为了说明哪种方法更好，或者时间复杂度更低。而是想说同样的事情有多种不同的解决方法，而且随着数据量的增加，可能会需要更多组合形式。在这个领域，数据决定了数据结构，数据结构决定了算法。</p><p><strong>没有最好的方法，只有不断找寻更好的方法的程序员。适合的，才会是最好的。</strong></p><p>如果是海量数据，则思路如下：</p><ol><li>分治</li><li>排序算法</li></ol>`,40),o=[e];function i(r,u){return n(),s("div",null,o)}const d=a(p,[["render",i],["__file","TopK-排序.html.vue"]]);export{d as default};
