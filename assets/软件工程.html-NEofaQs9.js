import{_ as t}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as r,c as n,d as s}from"./app-AuAuVshg.js";const a="/assets/系统架构设计师16-cytLjsIB.png",o="/assets/系统架构设计师17-jt6e8rx-.png",g="/assets/系统架构设计师18-Y-U6S7g6.jpg",p="/assets/系统架构设计师19-rrYMeaKq.jpg",e="/assets/系统架构设计师20-N1X_8Ylw.png",d="/assets/系统架构设计师21-oTrWOPlX.png",i="/assets/系统架构设计师22-NsKT3_Nl.png",h="/assets/系统架构设计师23--UhSKXYh.jpg",c="/assets/系统架构设计师24-BNdUp-wp.jpg",_="/assets/系统架构设计师26-54Sy2C6a.png",l="/assets/系统架构设计师27-B-b__b5w.jpg",f="/assets/系统架构设计师29-dyoFVF7x.png",u="/assets/系统架构设计师30-hfzlbimg.png",b="/assets/系统架构设计师31-qM9nkTEc.png",x="/assets/系统架构设计师32-FInFvNJZ.png",m="/assets/系统架构设计师33-UKeki8W6.png",y="/assets/系统架构设计师34-zYCH8_py.png",z="/assets/系统架构设计师35-tihE0XTD.png",D="/assets/系统架构设计师36-WtayLgtu.png",L="/assets/系统架构设计师37-bucPEKaY.png",A="/assets/系统架构设计师38-SWj1--Lz.png",R="/assets/系统架构设计师39-fozMr2AE.png",M="/assets/系统架构设计师40-Pl0tcp5f.png",U="/assets/系统架构设计师41-Dn85lI3P.png",C="/assets/系统架构设计师42-WWZ-G1Ms.png",F="/assets/系统架构设计师43-KntYRM_i.png",S="/assets/系统架构设计师44-VgElHoJk.png",j="/assets/系统架构设计师45-yczu3IwA.png",P="/assets/系统架构设计师46-PXWGVROo.png",E="/assets/系统架构设计师47-XfVmJ2-x.png",v="/assets/系统架构设计师48-JRL071sQ.png",B="/assets/系统架构设计师50-RB5xrkWf.png",J="/assets/系统架构设计师51-8LadALiF.png",w="/assets/系统架构设计师52-D4hChQGr.jpg",N="/assets/系统架构设计师53-8F73wwAP.jpg",O="/assets/系统架构设计师54-a16z1hoe.jpg",W="/assets/系统架构设计师55-iwcAZsx1.jpg",k="/assets/系统架构设计师56-AsfzuF4J.jpg",I="/assets/系统架构设计师57-BBFCS72T.jpg",T="/assets/系统架构设计师58-8ID2Bns0.jpg",X={},Y=s('<h2 id="_2-1-考情分析" tabindex="-1"><a class="header-anchor" href="#_2-1-考情分析" aria-hidden="true">#</a> <strong>2.1.考情分析</strong></h2><p>根据对历年的考试真题进行分析，本章要求考生掌握以下几个方面的知识：</p><p>（1） 了解软件开发方法，掌握软件开发模型。</p><p>（2） 了解需求工程概念，熟悉面向对象分析，掌握结构化分析，掌握需求管理过程。</p><p>（3） 了解系统建模过程。</p><p>（4） 了解系统设计的过程，了解人机界面设计和结构化设计，熟悉面向对象设计。</p><p>（5） 了解软件测试的概念和目标，了解软件测试的原则，熟悉基本的软件测试活动，掌握软件测试的阶段和分类，了解面向对象测试。</p><p>（6） 了解软件调试方法，区分软件调试与软件测试。</p><p>（7） 掌握系统转换计划，了解系统维护的概念。</p><p>（8） 了解软件开发环境与工具。</p><h3 id="_2-1-1-本章概要" tabindex="-1"><a class="header-anchor" href="#_2-1-1-本章概要" aria-hidden="true">#</a> <strong>2.1.1.本章概要</strong></h3><table><thead><tr><th>序号</th><th>知识领域</th><th>知识点详情</th></tr></thead><tbody><tr><td>1</td><td>软件开发</td><td>软件开发方法（⭐）</td></tr><tr><td>2</td><td></td><td>软件开发模型（⭐⭐⭐⭐⭐）</td></tr><tr><td>3</td><td></td><td>逆向工程（⭐）</td></tr><tr><td>4</td><td></td><td>净室工程</td></tr><tr><td>1</td><td>需求工程</td><td>概述</td></tr><tr><td>2</td><td></td><td>需求开发（⭐⭐⭐⭐⭐）</td></tr><tr><td>3</td><td></td><td>需求管理（⭐⭐⭐）</td></tr><tr><td>1</td><td>系统建模过程</td><td>系统建模过程</td></tr><tr><td>1</td><td>系统设计</td><td>系统设计过程</td></tr><tr><td>2</td><td></td><td>人机界面设计（⭐）</td></tr><tr><td>3</td><td></td><td>结构化设计（⭐）</td></tr><tr><td>4</td><td></td><td>面向对象设计（⭐⭐⭐⭐⭐）</td></tr><tr><td>1</td><td>软件测试（⭐⭐⭐⭐⭐）</td><td>概念和目标</td></tr><tr><td>2</td><td></td><td>软件测试原则</td></tr><tr><td>3</td><td></td><td>基本测试活动</td></tr><tr><td>4</td><td></td><td>测试阶段和分类</td></tr><tr><td>5</td><td></td><td>面向对象测试</td></tr><tr><td>1</td><td>软件调试（⭐）</td><td>软件调试方法</td></tr><tr><td>2</td><td></td><td>软件调试与测试的区别</td></tr><tr><td>1</td><td>系统运行与软件维护</td><td>系统转换计划（⭐⭐⭐）</td></tr><tr><td>2</td><td></td><td>系统维护 （⭐）</td></tr><tr><td>1</td><td>软件开发环境与工具（⭐）</td><td>环境机制</td></tr><tr><td>2</td><td></td><td>工具</td></tr></tbody></table><h2 id="_2-2-考点精讲" tabindex="-1"><a class="header-anchor" href="#_2-2-考点精讲" aria-hidden="true">#</a> <strong>2.2.考点精讲</strong></h2><h3 id="_2-2-1-软件开发" tabindex="-1"><a class="header-anchor" href="#_2-2-1-软件开发" aria-hidden="true">#</a> <strong>2.2.1.软件开发</strong></h3><h4 id="_2-2-1-1-软件开发方法-⭐" tabindex="-1"><a class="header-anchor" href="#_2-2-1-1-软件开发方法-⭐" aria-hidden="true">#</a> <strong>2.2.1.1.软件开发方法（⭐）</strong></h4><h5 id="_2-2-1-1-1-结构化开发方法" tabindex="-1"><a class="header-anchor" href="#_2-2-1-1-1-结构化开发方法" aria-hidden="true">#</a> 2.2.1.1.1. <strong>结构化开发方法</strong></h5><p>用户至上，自顶向下，逐步分解（求解），严格区分工作阶段，每阶段有任务与成果，强调系统开发过程的整体性和全局性，系统开发过程工程化，文档资料标准化。</p><p><strong>优点</strong>：</p><p>理论基础严密，它的指导思想是用户需求在系统建立之前就能被充分了解和理解。由此可见，结构化方法注重开发过程的整体性和全局性。</p><p><strong>缺点</strong>：</p><p>开发周期长；文档、设计说明繁琐，工作效率低；要求在开发之初全面认识系统的信息需求，充分预料各种可能发生的变化，但这并不十分现实；若用户参与系统开发的积极性没有充分调动，造成系统交接过程不平稳，系统运行与维护管理难度加大。阶段固化，不善变化，适用于需求明确。</p><h5 id="_2-2-1-1-2-原型法开发方法" tabindex="-1"><a class="header-anchor" href="#_2-2-1-1-2-原型法开发方法" aria-hidden="true">#</a> 2.2.1.1.2. <strong>原型法开发方法</strong></h5><p>适用于<strong>需求不明确</strong>的开发，按功能分-水平原型（界面）、垂直原型（复杂算法），按最终结果分-抛弃式原型、演化式原型。原型法的特点在于原型法对用户的需求是动态响应、逐步纳入的，系统分析、设计与实现都是随着对一个工作模型的不断修改而同时完成的，相互之间并无明显界限，也没有明确分工。系统开发计划就是一个反复修改的过程。适于用户需求开始时定义不清、管理决策方法结构化程度不高的系统开发，开发方法更宜被用户接受；但如果用户配合不好，盲目修改，就会拖延开发过程。</p><p><strong>抛弃型原型</strong>(Throw-It-Away Prototype)，此类原型在系统真正实现以后就放弃不用了。</p><p><strong>进化型原型</strong>(Evolutionary Prototype)，此类原型的构造从目标系统的一个或几个基本需求出发，通过修改和追加功能的过程逐渐丰富，演化成最终系统。</p><h5 id="_2-2-1-1-3-面向对象方法" tabindex="-1"><a class="header-anchor" href="#_2-2-1-1-3-面向对象方法" aria-hidden="true">#</a> 2.2.1.1.3. <strong>面向对象方法</strong></h5><p>最早来源于仿真领域，其特点是系统的描述及信息模型的表示与客观实体相对应，符合人们的思维习惯，有利于系统开发过程中用户与开发人员的交流和沟通，缩短开发周期，提供系统开发的准确性和效率。具有更好的复用性，关键在于建立一个全面、合理、统一的模型，分析、设计、实现三个阶段界限不明确。用面向对象方法开发软件，通常需要建立三种形式的模型：对象模型（描述系统数据结构）、动态模型（描述系统控制结构）、功能模型（描述系统功能）。</p><h6 id="_2-2-1-1-3-1-对象模型" tabindex="-1"><a class="header-anchor" href="#_2-2-1-1-3-1-对象模型" aria-hidden="true">#</a> 2.2.1.1.3.1. <strong>对象模型</strong></h6><p>对象模型表示静态的、结构化的系统的“数据”性质。对象模型是对模拟客观世界实体的对象以及对象彼此间的关系的映射，描述了系统的静态结构。</p><h6 id="_2-2-1-1-3-2-动态模型" tabindex="-1"><a class="header-anchor" href="#_2-2-1-1-3-2-动态模型" aria-hidden="true">#</a> 2.2.1.1.3.2. <strong>动态模型</strong></h6><p>动态模型表示瞬时的、行为化的系统的“控制”性质，规定了对象模型中对象的合法变化序列。即对象的动态行为。用状态图来描绘对象的状态、触发状态转换的事件、以及对象的行为(对事件的响应)。每个类的动态行为用一张状态图来描绘，各个类的状态图通过共享事件合并起来，从而构成系统的动态模型。</p><h6 id="_2-2-1-1-3-3-功能模型" tabindex="-1"><a class="header-anchor" href="#_2-2-1-1-3-3-功能模型" aria-hidden="true">#</a> 2.2.1.1.3.3. <strong>功能模型</strong></h6><p>功能模型表示变化的系统的“功能”性质，它指明了系统应该“做什么”，故更直接反映了用户对目标系统的需求。功能模型也通常由一组数据流程图表示。在面向对象方法中，数据流程图没有在结构化分析中重要，有时可以省略</p><h5 id="_2-2-1-1-4-面向服务的方法" tabindex="-1"><a class="header-anchor" href="#_2-2-1-1-4-面向服务的方法" aria-hidden="true">#</a> 2.2.1.1.4. <strong>面向服务的方法</strong></h5><p>以粗粒度、松散耦合的系统功能为核心，强调系统功能的标准化和构件化，加强了系统的灵活性、可复用性和可演化性。</p><p>从概念上讲，SO 方法有三个主要的抽象级别：操作、服务、业务流程</p><p><strong>操作</strong>：代表单个逻辑工作单元（LUW）的事务。执行操作通常会导致读、写或修改一个或多个持久性数据。SOA 操作可以直接与面向对象 (OO) 的方法相比。它们都有特定的结构化接口，并且返回结构化的响应。完全同方法一样，特定操作的执行可能涉及调用附加的操作。操作位于最底层。</p><p><strong>服务</strong>：代表操作的逻辑分组。例如，如果我们将 CustomerProfiling 视为服务，则按照电话号码查找客户、按照名称和邮政编码列出顾客和 保存新客户的数据就代表相关的操作。</p><p><strong>业务流程</strong>：为实现特定业务目标而执行的一组长期运行的动作或活动。业务流程通常包括多个业务调用。业务流程的例子有： 接纳新员工、 出售产品或服务和完成订单。</p><p><strong>SOAD 分为三个层次：基础设计层（底层服务构件）、应用结构层（服务之间的接口和服务级协定）和业务组织层（业务流程建模和服务流程编排）</strong></p><p><strong>服务建模：分为服务发现、服务规约和服务实现三个阶段</strong></p><h4 id="_2-2-1-2-软件开发模型-⭐⭐⭐⭐⭐" tabindex="-1"><a class="header-anchor" href="#_2-2-1-2-软件开发模型-⭐⭐⭐⭐⭐" aria-hidden="true">#</a> <strong>2.2.1.2.软件开发模型（⭐⭐⭐⭐⭐）</strong></h4><h5 id="_2-2-1-2-1-原型模型" tabindex="-1"><a class="header-anchor" href="#_2-2-1-2-1-原型模型" aria-hidden="true">#</a> 2.2.1.2.1. <strong>原型模型</strong></h5><p>典型的原型开发方法模型。适用于需求不明确的场景，可以帮助用户明确需求。原型的发展方向:</p><figure><img src="'+a+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h5 id="_2-2-1-2-2-瀑布模型" tabindex="-1"><a class="header-anchor" href="#_2-2-1-2-2-瀑布模型" aria-hidden="true">#</a> 2.2.1.2.2. <strong>瀑布模型</strong></h5><p>瀑布模型是将软件生存周期中的各个活动规定为依线性顺序连接的若干阶段的模型，包括需求分析、设计、编码、运行与维护。</p><p>瀑布模型的特点是容易理解，管理成本低，每个阶段都有对应的成果产物，各个阶段有明显的界限划分和顺序要求，一旦发生错误，整个项目推倒重新开始。</p><p>适用于需求明确的项目，一般表述为需求明确、或二次开发，或者对于数据处理类型的项目</p><h5 id="_2-2-1-2-3-增量模型" tabindex="-1"><a class="header-anchor" href="#_2-2-1-2-3-增量模型" aria-hidden="true">#</a> 2.2.1.2.3. <strong>增量模型</strong></h5><p>融合了瀑布模型的基本成分和原型实现的迭代特征，可以有多个可用版本的发布，核心功能往往最先完 成，在此基础上，每轮迭代会有新的增量发布，核心功能可以得到充分测试。强调每一个增量均发布一个可操作的产品。</p><h5 id="_2-2-1-2-4-螺旋模型" tabindex="-1"><a class="header-anchor" href="#_2-2-1-2-4-螺旋模型" aria-hidden="true">#</a> 2.2.1.2.4. <strong>螺旋模型</strong></h5><p>典型特点是引入了风险分析。结合了瀑布模型和演化模型的优点，最主要的特点在于加入了风险分析。它是由制定计划、风险分析、实施工程、客户评估这一循环组成的，它最初从概念项目开始第一个螺旋。属于面向对象开发模型，强调风险引入。</p><h5 id="_2-2-1-2-5-v-模型" tabindex="-1"><a class="header-anchor" href="#_2-2-1-2-5-v-模型" aria-hidden="true">#</a> 2.2.1.2.5. <strong>V 模型</strong></h5><p>强调测试贯穿项目始终，而不是集中在测试阶段。是一种测试的开发模型。</p><h5 id="_2-2-1-2-6-喷泉模型" tabindex="-1"><a class="header-anchor" href="#_2-2-1-2-6-喷泉模型" aria-hidden="true">#</a> 2.2.1.2.6. <strong>喷泉模型</strong></h5><p>典型的面向对象的模型。特点是迭代、无间隙。会将软件开发划分为多个阶段，但各个阶段无明显界限，并且可以迭代交叉。</p><h5 id="_2-2-1-2-7-快速应用开发rad" tabindex="-1"><a class="header-anchor" href="#_2-2-1-2-7-快速应用开发rad" aria-hidden="true">#</a> 2.2.1.2.7. <strong>快速应用开发RAD</strong></h5><p><strong>概念</strong>：RAD 是瀑布模型的一个高速变种，适用比传统生命周期快得多的开发方法，它强调极短的开发周期，通常适用<strong>基于构件</strong>的开发方法获得快速开发。</p><p><strong>过程</strong>：业务建模，数据建模，过程建模，应用生成，测试与交付</p><p><strong>适用性</strong>：RAD 对模块化要求比较高，如果某项功能不能被模块化，则其构件就会出问题；如果高性能是一个指标，且必须通过调整结构使其适应系统构件才能获得，则 RAD 也有可能不能奏效；RAD 要求开发者和客户必须在很短的时间完成一系列的需求分析，任何一方配合不当都会导致失败；RAD 只能用于管理信息系统的开发，不适合技术风险很高的情况。</p><h5 id="_2-2-1-2-8-构件组装模型" tabindex="-1"><a class="header-anchor" href="#_2-2-1-2-8-构件组装模型" aria-hidden="true">#</a> 2.2.1.2.8. <strong>构件组装模型</strong></h5><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h5 id="_2-2-1-2-9-统一过程" tabindex="-1"><a class="header-anchor" href="#_2-2-1-2-9-统一过程" aria-hidden="true">#</a> 2.2.1.2.9. <strong>统一过程</strong></h5><p><strong>（在软考中</strong> <strong>UP、RUP</strong> <strong>都指统一过程）典型特点是用例驱动、以架构为中心、迭代和增量</strong>。统一过程把一个项目分为四个不同的阶段：</p><p><strong>构思阶段（初始/初启阶段）</strong>：包括用户沟通和计划活动两个方面，强调定义和细化用例，并将其作为主要模型。</p><p><strong>细化阶段（精化阶段）</strong>：包括用户沟通和建模活动，重点是创建分析和设计模型，强调类的定义和体系结构的表示。</p><p><strong>构建阶段</strong>：将设计转化为实现，并进行集成和测试。</p><p><strong>移交阶段</strong>：将产品发布给用户进行测试评价，并收集用户的意见，之后再次进行迭代修改产品使之完善。</p><h5 id="_2-2-1-2-10-敏捷开发" tabindex="-1"><a class="header-anchor" href="#_2-2-1-2-10-敏捷开发" aria-hidden="true">#</a> 2.2.1.2.10. <strong>敏捷开发</strong></h5><p>敏捷开发是一种以人为核心、迭代、循序渐进的开发方法，适用于小团队和小项目，具有小步快跑的思想。常见的敏捷开发方法有极限编程法、水晶法、并列争球法和自适应软件开发方法。</p><p><strong>极限编程</strong> <strong>XP</strong> 是一种轻量级的开发方法，它提出了四大价值观：沟通、简单、反馈、勇气。五大原则：快速反馈、简单性假设、逐步修改、提倡更改、优质工作。十二个最佳实践：计划游戏、隐喻、小型发布、简单设计、测试先行、重构、结对编程、集体代码所有制、持续集成、每周工作 40 小时、现场客户和编码标准。</p><p><strong>水晶法</strong>强调经常交付，认为每一种不同的项目都需要一套不同的策略、约定和方法论。<strong>并列争球法</strong>的核心是迭代、增量交付，按照 30 天进行迭代开发交付可实际运行的软件。</p><p><strong>自适应软件开发(ASD</strong> **方法)**的核心是三个非线性的，重迭的开发阶段：猜测、合作、学习。</p><p><strong>开放式源码</strong>，这里提到的开放式源码指的是开放源码界所用的一种运作方式。开放式源码项目有一个特别之处，就是程序开发人员在地域上分布很广，这使得它和其他敏捷方法不同，因为一般的敏捷方法都强调项目组成员在同一地点工作。开放源码的一个突出特点就是查错排障(debug)的高度并行性，任何人发现了错误都可将改正源码的“补丁”文件发给维护者。然后由维护者将这些“补丁”或是新增的代码并入源码库。</p><p><strong>Coad 的功用驱动开发方法(FDD-Feature Driven Development)</strong></p><p>FDD 是由Jeff De Luca 和大师Peter Coad 提出来的。像其他方法一样，它致力于短时的迭代阶段和可见可用的功能。在 FDD 中，一个迭代周期一般是两周。</p><p>在 FDD 中，编程开发人员分成两类：首席程序员和“类”程序员(class owner)。首席程序员是最富有经验的开发人员，他们是项目的协调者、设计者和指导者，而“类”程序员则主要做源码编写。</p><h4 id="_2-2-1-3-逆向工程-⭐" tabindex="-1"><a class="header-anchor" href="#_2-2-1-3-逆向工程-⭐" aria-hidden="true">#</a> <strong>2.2.1.3.逆向工程（⭐）</strong></h4><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="'+g+'" alt="" loading="lazy"></td></tr></tbody></table><p>实现级：包括程序的抽象语法树、符号表、过程的设计表示</p><p>结构级：包括反映程序分量之间相互依赖关系的信息，例如调用图、结构图、程序和数据结构功能级：包括反映程序段功能及程序段之间关系的信息，例如数据和控制流模型</p><p>领域级：包括反映程序分量或程序诸实体与应用领域概念之间对应关系的信息，例如实体关系模型</p><h4 id="_2-2-1-4-净室工程" tabindex="-1"><a class="header-anchor" href="#_2-2-1-4-净室工程" aria-hidden="true">#</a> <strong>2.2.1.4.净室工程</strong></h4><p>净室即无尘室、洁净室。也就是一个受控污染级别的环境。</p><p>使用盒结构规约（或形式化方法）进行分析和设计建模，并且强调将正确性验 证，而不是测试，作为发现和消除错误的主要机制。</p><p>使用统计的测试来获取认证被交付的软件的可靠性所必需的出错率信息。</p><h3 id="_2-2-2-需求工程" tabindex="-1"><a class="header-anchor" href="#_2-2-2-需求工程" aria-hidden="true">#</a> <strong>2.2.2.需求工程</strong></h3><h4 id="_2-2-2-1-概述" tabindex="-1"><a class="header-anchor" href="#_2-2-2-1-概述" aria-hidden="true">#</a> <strong>2.2.2.1.概述</strong></h4><p>软件需求是指用户对系统在功能、行为、性能、设计约束等方面的期望。</p><p>软件需求是指用户解决问题或达到目标所需的条件或能力，是系统或系统部件要满足合同、标准、规范或其他正式规定文档所需具有的条件或能力，以及反映这些条件或能力的文档说明。</p><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_2-2-2-2-需求开发" tabindex="-1"><a class="header-anchor" href="#_2-2-2-2-需求开发" aria-hidden="true">#</a> <strong>2.2.2.2.需求开发</strong></h4><h5 id="_2-2-2-2-1-需求获取" tabindex="-1"><a class="header-anchor" href="#_2-2-2-2-1-需求获取" aria-hidden="true">#</a> 2.2.2.2.1. <strong>需求获取</strong></h5><h6 id="_2-2-2-2-1-1-需求分类" tabindex="-1"><a class="header-anchor" href="#_2-2-2-2-1-1-需求分类" aria-hidden="true">#</a> 2.2.2.2.1.1. <strong>需求分类</strong></h6><p><strong>【需求的层次分类】</strong></p><p><strong>业务需求</strong>：是指反应企业或客户对系统高层次的目标要求，通常来自项目投资人、购买产品的客户、客户单位的管理人员、市场营销部门或产品策划部门等。通过业务需求可以确定项目视图和范围，为以后的开发工作奠定了基础。</p><p><strong>用户需求</strong>：描述的是用户的具体目标，或用户要求系统必须能完成的任务。也就是说，用户需求描述了用户能使用系统来做些什么。</p><p><strong>系统需求</strong>：是从系统的角度来说明软件的需求，<strong>包括功能需求、非功能需求和设计约束</strong>等。</p><p><strong>功能需求</strong>也称为行为需求，它规定了开发人员必须在系统种实现的软件功能，用户利用这些功能来完成任务，满足业务要求。</p><p>**性能需求（非功能需求）**是指系统必须具备的属性或品质，又可细分为软件质量属性和其他非功能需求。<strong>设计约束</strong>也称为限制条件或补充规约，通常是对系统的一些约束说明。</p><p>2.2.2.2.1.1.1. <strong>【需求的 QFD 分类】</strong></p><p>质量功能部署QFD 是一种将用户要求转化成软件需求的技术，其目的是最大限度地提升软件工程过程中用户的满意度。QFD 将软件需求分为三类：</p><p><strong>常规需求（基本需求）</strong>：用户认为系统应该做到的功能或性能，实现越多用户会越满意。</p><p><strong>期望需求</strong>：用户想当然认为系统应具备的功能或性能，但并不能正确描述自己想要得到的这些功能或性能需求。如果期望需求没有得到实现，会让用户感到不满意。</p><p><strong>兴奋需求（意外需求）</strong>：是用户要求范围外的功能或性能，实现这些需求用户会更高兴，但不实现也不影响其购买的决策。</p><h6 id="_2-2-2-2-1-2-需求获取方法" tabindex="-1"><a class="header-anchor" href="#_2-2-2-2-1-2-需求获取方法" aria-hidden="true">#</a> 2.2.2.2.1.2. <strong>需求获取方法</strong></h6><p><strong>用户访谈</strong>：1 对 1-3，有代表性的用户。用户访谈是最基本的一种需求获取手段，其形式包括结构化和非结构化两种。用户访谈是通过 1 对 1（或 1 对 2，1 对 3）的形式与用户面对面进行沟通，以获取用户需求。用户访谈具有良好的灵活性，有较宽广的应用范围。但是，也存在着许多困难，例如，用户经常较忙，难以安排时间；面谈时信息量大，记录较为困难；沟通需要很多技巧，同时需要系统分析师具有足够的领域知识等。另外，在访谈时，还可能会遇到一些对于企业来说比较机密和敏感的话题。因此，这看似简单的技术，也需要系统分析师具有丰富的经验和较强的沟通能力。</p><p><strong>问卷调查</strong>：用户多，无法一一访谈。与用户访谈相比，问卷调查可以在短时间内，以低廉的代价从大量的回答中收集数据；问卷调查允许回答者匿名填写，大多数用户可能会提供真实信息；问卷调查的结果比较好整理和统计。问卷调查最大的不足就是缺乏灵活性。</p><p><strong>现场观摩</strong>：针对较为复杂的流程和操作。想获取系统某些较为复杂的流程和操作过程，则现场观摩方法比较合适。对于一些较为复杂的流程和操作而言，是比较难以用语言和文字进行表达的，对于这种情况，可以采用到客户的工作现场，一边观察，一边听客户讲解，从而更直观的了解客户需求。</p><p><strong>联合需求计划（JRP）</strong>：高度组织的群体会议，各方参与，成本较高。为了提高需求获取的效率，越来越多的企业倾向于使用小组工作会议来代替大量独立的访谈。联合需求计划（Joint Requirement Planning， JRP）是一个通过高度组织的群体会议来分析企业内的问题并获取需求的过程，它是联合应用开发（Joint Application Development，JAD）的一部分。</p><p><strong>情节串联板</strong>：一系列图片，通过这些图片来讲故事。</p><p><strong>收集资料</strong>：把与系统有关的、对系统开发有益的信息收集起来。<strong>参加业务实践</strong>：有效地发现问题的本质和寻找解决问题的办法。<strong>阅读历史文档</strong>：对收集数据性的信息较为有用。</p><p><strong>抽样调查</strong>：降低成本。采样是指从种群中系统地选出有代表性的样本集的过程，通过认真研究所选出的样本集，可以从整体上揭示种群的有用信息。对于信息系统的开发而言，现有系统的文档（文件）就是采样种群。当开始对一个系统做需求分析时，查看现有系统的文档是对系统有初步了解的最好方法。但是，系统分析师应该查看哪些类型的文档，当文档的数据庞大，无法一一研究时，就需要使用采样技术选出有代表性的数据。抽样能够提高需求获取效率，但抽样往往是由系统分析师来抽的，所以会受到他的主观因素影响。</p><p>样本大小＝ɑ*（可信度系数/可接受的错误）2注： ɑ一般取 0.25</p><h5 id="_2-2-2-2-2-需求分析" tabindex="-1"><a class="header-anchor" href="#_2-2-2-2-2-需求分析" aria-hidden="true">#</a> 2.2.2.2.2. <strong>需求分析</strong></h5><h6 id="_2-2-2-2-2-1-结构化需求分析-sa-⭐⭐" tabindex="-1"><a class="header-anchor" href="#_2-2-2-2-2-1-结构化需求分析-sa-⭐⭐" aria-hidden="true">#</a> 2.2.2.2.2.1. <strong>结构化需求分析（SA）（⭐⭐）</strong></h6><p><strong>（1）</strong> <strong>结构化分析过程</strong></p><figure><img src="'+e+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>（2）</strong> <strong>结构化分析工具-数据流图</strong> <strong>DFD</strong></p><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>（3）</strong> <strong>数据流图题答题技巧</strong></p><p><strong>详细分析试题说明</strong></p><p><strong>利用数据平衡原则【父图与子图之间的平衡；子图内平衡】黑洞</strong>：一个加工只有输入数据流而无输出数据流。<strong>奇迹</strong>：一个加工只有输出数据流而无输入数据流。</p><p><strong>灰洞</strong>：若一个加工的输入数据流无法通过加工产生输出流。</p><p><strong>【补充实体】</strong></p><p>人物角色：如 客户、管理员、主管、经理、老师、学生组织机构：如 银行、供应商、慕捐机构</p><p>外部系统：如 银行系统、工资系统、后台数据库（当要开发的是中间件时）</p><p>**【补充存储】**存储的文字方面特征：“**文件”“**表”“**库” “**清单” “**档案”</p><p><strong>【补充数据流】</strong></p><p><strong>数据平衡原则</strong>：顶层图与 0 层图对比，是否有顶层图有，但 0 层图无的数据流，或反之。检查图中每个加工，是否存在只有入没有出，或只有出没有入，或根据输入的数据无法产生对应的输出的情况。</p><p><strong>按题目说明与图进行匹配</strong>：说明中的每一句话，都能与图中有对应关系，当把说明中的实体与数据流标识出来之后，容易缩小对应范围，找出纰漏。</p><p><strong>【补充加工名】</strong></p><p>加工是用于处理数据流的，所以要补充加工名，可以把该加工涉及到的数据流，在说明中标识出来，再在数据流名称所在的句子中，找“动词+名词”的结构，分析是否可作为加工。</p><p>“动词+名词”如：生成报告，发出通知，批改作业，记录分数，当然这只是普遍情况，也有例外，如物流跟踪、用户管理</p><p><strong>（4）</strong> <strong>结构化需求分析-流程分析</strong> <strong>STD-状态转换图</strong></p><figure><img src="'+i+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>（5）</strong> <strong>需求分析-数据分析-E-R</strong> <strong>图--数据库设计解题技巧</strong></p><p><strong>【补充 E-R 图】</strong></p><p>**找实体：**实体一般为名词形式，实体是现实世界中可以区别于其他对象的“事件”或“物体”。在 E-R 图中可根据相关实体间的联系，补充缺失的实体。实体以矩形表示，在矩形框内写明实体名。</p><p><img src="'+h+'" alt="" loading="lazy"><strong>找联系</strong>：在 E-R 模型中，联系用菱形表示，通常菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标注上联系的类型（1:1、1:n、n:m）。根据题干描述找出对应实体间存在的联系。</p><p>注：三元联系：对于题干描述中，一个联系涉及到 3 个实体的情况，我们称之为三元联系。以菱形表示联系，以无向边分别连接对应的实体。</p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>【补充关系模式】</strong></p><p>根据题干描述，找遗漏属性；</p><p>题干描述已完善，根据联系归并找参照属性，通常将联系归并到实体端时，需要补充另一端实体的主键，如果联系本身存在属性，归并后也需要列出。</p><p><strong>【判断主键和外键】</strong></p><p><strong>找主键</strong>：候选码/候选键：若关系中的某一属性或属性组的值能唯一地标识一个元组，则城管属性</p><p>或属性组为候选码。</p><p><strong>主码/主键：选择一个候选码作为主键。如果题干描述明确指出可以唯一标识元组的属性，则可以直接判断为主键。</strong></p><p>全码：关系模型的所有属性组是这个关系模式的候选码，称为全码。</p><p><strong>找外键</strong>：如果关系模式R 中的属性或属性组非该关系的码，但它是其他关系的码，那么该属性集对关系模式R 而言是外码。（一般而言不用排除本关系的码，在建表时，只要是其他关系的主</p><p>键，都会构建参照关系，也就是外键）</p><p>2.2.2.2.2.1.1. <strong>【扩展题型】</strong></p><p><strong>增加实体</strong>：根据题干描述添加实体，注意新实体与其他实体之间的联系。</p><p><strong>完整性约束相关</strong>：了解主键、外键相关的概念，根据题干，做出相关判断。</p><p><strong>规范化理论相关</strong>：了解规范化理论相关的概念，对于规范化程度没有达到 3NF 时，一般认为会存在数据冗余、修改异常、插入异常、删除异常问题。对于相关问题的解决，一般是将表进行模式分解，从而提高其规范化程度至 3NF。</p><p><strong>关于反规范化理论的考查</strong>。</p><p><strong>关于分布式数据库考查</strong>。</p><p><strong>关于NoSQL</strong> <strong>的考查。</strong></p><p><strong>关于事务、缓存等技术结合考查。</strong></p><h6 id="_2-2-2-2-2-2-面向对象需求分析-⭐⭐⭐⭐⭐" tabindex="-1"><a class="header-anchor" href="#_2-2-2-2-2-2-面向对象需求分析-⭐⭐⭐⭐⭐" aria-hidden="true">#</a> 2.2.2.2.2.2. <strong>面向对象需求分析（⭐⭐⭐⭐⭐）</strong></h6><p><strong>（1）</strong> <strong>面向对象基本概念</strong></p><p><strong>对象</strong>：属性（数据）+方法（操作）+对象 ID</p><p><strong>类</strong>（实体类/控制类/边界类）<strong>继承与泛化</strong>：复用机制</p><p><strong>封装</strong>：隐藏对象的属性和实现细节,仅对外公开接口<strong>多态</strong>：不同对象收到同样的消息产生不同的结果 <strong>接口</strong>：一种特殊的类，他只有方法定义没有实现</p><p><strong>重载</strong>：一个类可以有多个同名而参数类型不同的方法<strong>消息和消息通信</strong>：消息是异步通信的</p><p><strong>（2）</strong> <strong>UML</strong> <strong>图概念</strong></p><figure><img src="'+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>UML 包括两组公共分类，分别是类与对象（类表示概念，而对象表示具体的实体）、接口与实现（接口用来定义契约，而实现就是具体的内容）</p><p>**结构事物：**结构事物在模型中属于最静态的部分，代表概念上或物理上的元素。UML 有七种结构事物，分别是类、接口、协作、用例、活动类、构件和节点。<strong>类</strong>是描述具有相同属性、方法、关系和语义的对象的集合，一个类实现一个或多个接口；<strong>接口</strong>是指类或构件提供特定服务的一组操作的集合，接口描述了类或构件的对外的可见的动作；<strong>协作</strong>定义了交互的操作，是一些角色和其它事物一起工作，提供一些合作的动作，这些动作比事物的总和要大；<strong>用例</strong>是描述一系列的动作，产生有价值的结果。在模型中用例通常用来组织行为事物。用例是通过协作来实现的；活动类的对象有一个或多个进程或线程。<strong>活动类</strong>和类很相 似，只是它的对象代表的事物的行为和其他事物是同时存在的；<strong>构件</strong>是物理上或可替换的系统部分，它实现了一个接口集合；<strong>节点</strong>是一个物理元素，它在运行时存在，代表一个可计算的资源，通常占用一些内存和具有处理能力。一个构件集合一般来说位于一个节点，但有可能从一个节点转到另一个节点。</p><p><strong>行为事物：<strong>行为事物是UML 模型中的动态部分，代表时间和空间上的动作。UML 有两种主要的行为事物。第一种是交互（内部活动），<strong>交互</strong>是由一组对象之间在特定上下文中，为达到特定目的而进行的一系列消息交换而组成的动作。交互中组成动作的对象的每个操作都要详细列出，包括消息、动作次序（消息产生的动作）、连接（对象之间的连接）；第二种是</strong>状态机</strong>，状态机由一系列对象的状态组成。</p><p><strong>分组事物</strong>：分组事物是UML 模型中组织的部分，可以把它们看成是个盒子，模型可以在其中进行分解。 UML 只有一种分组事物，称为包。<strong>包</strong>是一种将有组织的元素分组的机制。与构件不同的是，包纯粹是一种概念上的事物，只存在于开发阶段，而构件可以存在于系统运行阶段。</p><p><strong>注释事物</strong>：注释事物是UML 模型的解释部分。</p><p><strong>（3）</strong> <strong>UML</strong> <strong>图分类</strong></p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>类图（class</strong> <strong>diagram）</strong>:类图描述一组类、接口、协作和它们之间的关系。</p><p><strong>对象图（object</strong> <strong>diagram）</strong>:对象图描述一组对象及它们之间的关系。对象图描述了在类图中所建立的事物实例的静态快照。</p><p><strong>构件图（component</strong> <strong>diagram）</strong>。构件图描述一个封装的类和它的接口、端口，以及由内嵌的构件和连接件构成的内部结构。构件图用于表示系统的静态设计实现视图。对于由小的部件构建大的系统来说，构件图是很重要的。构件图是类图的变体。一个封装的类和它的接口</p><p><strong>部署图（deployment</strong> <strong>diagram）</strong>。部署图描述对运行时的处理节点及在其中生存的构件的配置。部署图给出</p><p>了架构的静态部署视图，通常一个节点包含一个或多个部署图。软硬件之间映射制品图：系统的物理结构</p><p>包图：由模型本身分解而成的组织单元，以及他们之间的依赖关系组合结构图</p><p><strong>用例图</strong>：系统与外部参与者的交互</p><p><strong>顺序图（sequence diagram，序列图）</strong>：顺序图是一种交互图（interaction diagram），它强调对象之间消息发送的顺序，同时显示对象之间的交互。强调按时间顺序。</p><p><strong>通信图（communication</strong> <strong>diagram）</strong>。协作图。通信图也是一种交互图，它强调收发消息的对象或参与者的结构组织。顺序图和通信图表达了类似的基本概念，但它们所强调的概念不同，顺序图强调的是时序，通信图强调的是对象之间的组织结构（关系）。</p><p>定时图：强调实际时间交互概览图</p><p><strong>状态图（state</strong> <strong>diagram）</strong>。状态图描述一个状态机，它由状态、转移、事件和活动组成。状态图给出了对象的动态视图。它对于接口、类或协作的行为建模尤为重要，而且它强调事件导致的对象行为，这非常有助于对反应式系统建模。状态转换变迁</p><p><strong>活动图（activity</strong> <strong>diagram）</strong>。活动图将进程或其他计算结构展示为计算内部一步步的控制流和数据流。活</p><p>动图专注于系统的动态视图。它对系统的功能建模和业务流程建模特别重要，并强调对象间的控制流程。类似程序流程图，并行行为</p><p><strong>（4）</strong> <strong>UML</strong> <strong>图关系</strong></p><p><strong>用例关系包括：包含关系、扩展关系、泛化关系。</strong></p><p><strong>包含关系</strong>：其中这个提取出来的公共用例称为抽象用例，而把原始用例称为基本用例或基础用例系：当可以从两个或两个以上的用例中提取公共行为时，应该使用包含关系来表示它们。</p><p><strong>扩展关系</strong>：如果一个用例明显地混合了两种或两种以上的不同场景，即根据情况可能发生多种分支，则可以将这个用例分为一个基本用例和一个或多个扩展用例，这样使描述可能更加清晰。</p><p><strong>泛化关系</strong>：当多个用例共同拥有一种类似的结构和行为的时候，可以将它们的共性抽象成为父用例，其他的用例作为泛化关系中的子用例。在用例的泛化关系中，子用例是父用例的一种特殊形式，子用例继承了父用例所有的结构、行为和关系。</p><p><strong>类图/对象图关系：</strong></p><p><strong>依赖关系</strong>：一个事物发生变化影响另一个事物。<strong>泛化关系</strong>：特殊/一般关系</p><p><strong>关联关系</strong>：描述了一组链，链是对象之间的连接。</p><p>• <strong>聚合关系</strong>：整体与部分生命周期不同。</p><p>• <strong>组合关系</strong>：整体与部分生命周期相同。</p><p><strong>实现关系</strong>：接口与类之间的关系</p><p><strong>（5）</strong> <strong>常见UML</strong> <strong>图考查用例图常见考查形式：</strong></p><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>补充参与者</strong>：参与者一般为外部实体，可以是人，也可以是外部系统。</p><p><strong>补充用例</strong>：根据题干描述补充缺失的用例，在补充过程中需要参照用例图中用例间的关系。（用例名从题干中直接获取或提炼）</p><p><strong>分析用例间的关系</strong></p><p><strong>其他</strong>：可能会出现其他题型，比如添加新的用例等。</p><p><strong>类图/对象图常见考查形式（常与其他 UML 图结合考查）</strong></p><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>补充类名/对象名</strong>：一般为名词，来源于题干描述。</p><p><strong>补充多重度</strong>：多重度体现类与类或对象与对象之间的对应关系，有 0…1，1..1，1…<em>/n，</em>…*/m…n。</p><p><strong>分析类与类或对象与对象之间的关系。顺序图常见考查形式</strong></p><figure><img src="'+b+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>补充类名/对象名补充消息</strong></p><p><strong>活动图常见考查形式</strong></p><figure><img src="'+x+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>补充动作名称</strong> <strong>补充监护表达式分析并发关系</strong></p><p><strong>活动图与状态图对比，活动图与进程图关系。状态图常见考查形式</strong></p><figure><img src="'+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>补充状态</strong></p><p><strong>补充触发事件、监护条件、动作与状态模式结合考查</strong></p><p><strong>通信图常见考查形式</strong></p><figure><img src="'+y+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>补充对象名补充消息</strong></p><p><strong>（6）“4+1”视图（<strong>⭐⭐</strong>）</strong></p><figure><img src="'+z+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>UML 采用 4+1 视图来描述软件和软件开发过程：</p><p><strong>逻辑视图</strong>：以问题域的语汇组成的类和对象集合。</p><p><strong>进程视图</strong>：可执行线程和进程作为活动类的建模，它是逻辑视图的一次执行实例，描绘了所设计的并发与同步结构。</p><p><strong>实现视图</strong>：对组成基于系统的物理代码的文件和组件进行建模。</p><p><strong>部署视图</strong>：把构件部署到一组物理的、可计算的节点上，表示软件到硬件的映射及分布结构。<strong>用例视图</strong>：最基本的需求分析模型。</p><p><strong>（7）</strong> <strong>OOA</strong> <strong>需求建模</strong></p><figure><img src="'+D+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h5 id="_2-2-2-2-3-需求定义" tabindex="-1"><a class="header-anchor" href="#_2-2-2-2-3-需求定义" aria-hidden="true">#</a> 2.2.2.2.3. <strong>需求定义</strong></h5><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="'+L+'" alt="" loading="lazy"></td></tr></tbody></table><h5 id="_2-2-2-2-4-需求验证" tabindex="-1"><a class="header-anchor" href="#_2-2-2-2-4-需求验证" aria-hidden="true">#</a> 2.2.2.2.4. <strong>需求验证</strong></h5><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="'+A+'" alt="" loading="lazy"></td></tr></tbody></table><h4 id="_2-2-2-3-需求管理-⭐⭐⭐" tabindex="-1"><a class="header-anchor" href="#_2-2-2-3-需求管理-⭐⭐⭐" aria-hidden="true">#</a> <strong>2.2.2.3.需求管理（⭐⭐⭐）</strong></h4><h5 id="_2-2-2-3-1-定义需求基线" tabindex="-1"><a class="header-anchor" href="#_2-2-2-3-1-定义需求基线" aria-hidden="true">#</a> 2.2.2.3.1. <strong>定义需求基线</strong></h5><figure><img src="'+R+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h5 id="_2-2-2-3-2-需求跟踪" tabindex="-1"><a class="header-anchor" href="#_2-2-2-3-2-需求跟踪" aria-hidden="true">#</a> 2.2.2.3.2. <strong>需求跟踪</strong></h5><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="'+M+'" alt="" loading="lazy"></td></tr></tbody></table><h5 id="_2-2-2-3-3-变更控制—见第-6-章项目管理" tabindex="-1"><a class="header-anchor" href="#_2-2-2-3-3-变更控制—见第-6-章项目管理" aria-hidden="true">#</a> 2.2.2.3.3. <strong>变更控制—见第</strong> <strong>6</strong> <strong>章项目管理</strong></h5><p>带有风险的做法：无足够用户参与，忽略了用户分类，用户需求的不断增加，模棱两可的需求，不必要的特性，过于精简的SRS，不准确的估算。</p><figure><img src="'+U+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_2-2-3-系统建模过程" tabindex="-1"><a class="header-anchor" href="#_2-2-3-系统建模过程" aria-hidden="true">#</a> <strong>2.2.3.系统建模过程</strong></h3><figure><img src="'+C+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_2-2-4-系统设计" tabindex="-1"><a class="header-anchor" href="#_2-2-4-系统设计" aria-hidden="true">#</a> <strong>2.2.4.系统设计</strong></h3><h4 id="_2-2-4-1-系统设计过程" tabindex="-1"><a class="header-anchor" href="#_2-2-4-1-系统设计过程" aria-hidden="true">#</a> <strong>2.2.4.1.系统设计过程</strong></h4><h5 id="_2-2-4-1-1-概要设计" tabindex="-1"><a class="header-anchor" href="#_2-2-4-1-1-概要设计" aria-hidden="true">#</a> 2.2.4.1.1. <strong>概要设计</strong></h5><p>总体设计</p><p>总体布局设计</p><p>网络拓扑结构设计资源配置设计</p><p>模块化结构设计划分功能模块</p><p>模块功能和职责 模块间的调用关系模块间的信息传递</p><h5 id="_2-2-4-1-2-详细设计" tabindex="-1"><a class="header-anchor" href="#_2-2-4-1-2-详细设计" aria-hidden="true">#</a> 2.2.4.1.2. <strong>详细设计</strong></h5><p>**代码设计：**是信息分类和编码的工作，是将系统中有某些共同属性或特征的信息归并在一起，并利用便于计算机和人识别和处理的符号来表示这些信息的设计工作。</p><p><strong>数据库设计</strong>：构建既能客观、准确地反映外部世界，又便于人类大脑认识的概念模型，并在此基础上对数据进行建模，转化为数据库管理系统所支持的数据模型；选择合适的存储结构和存储方法，最终完成数据库的设计工作。</p><p><strong>输入/输出设计</strong>：输入/输出设计主要是对以记录为单位的各种输入输出报表格式的描述。另外，对人机对话格式的设计和输入输出装置的选择也在这一步完成。</p><p><strong>用户界面设计</strong>：用户界面设计是指用户与系统之间架起一座桥梁，主要内容包括：定义界面形式、定义基本的交互控制形成、定义图形和符号、定义通用的功能键和组合键的含义及其操作内容、定义帮助策略 等。</p><p><strong>处理过程设计</strong>：定义每个模块的内部执行过程，包括数据的组织、控制流、每一步的具体加工要求和实施细节。</p><h4 id="_2-2-4-2-人机界面设计-⭐" tabindex="-1"><a class="header-anchor" href="#_2-2-4-2-人机界面设计-⭐" aria-hidden="true">#</a> <strong>2.2.4.2.人机界面设计（⭐）</strong></h4><p><img src="'+F+'" alt="" loading="lazy">用户界面设计是指用户与系统之间架起一座桥梁，主要内容包括：定义界面形式、定义基本的交互控制形成、定义图形和符号、定义通用的功能键和组合键的含义及其操作内容、定义帮助策略等。</p><h4 id="_2-2-4-3-结构化设计-⭐" tabindex="-1"><a class="header-anchor" href="#_2-2-4-3-结构化设计-⭐" aria-hidden="true">#</a> <strong>2.2.4.3.结构化设计（⭐）</strong></h4><p><strong>特点：抽象化、自顶而下、逐步求精、信息隐蔽、模块独立（高内聚、低耦合）</strong></p><p><strong>（1）</strong> <strong>功能模块设计的原则</strong></p><p><strong>模块大小适中</strong>：50~100 行，最多不超过 500 行</p><p><strong>适宜的系统深度和宽度比例，尽可能减少调用的深度</strong></p><p><strong>适度控制模块的扇入扇出</strong>：扇出 3~4 一般不超过 7，扇入越大越好</p><p><strong>单入口，单出口</strong></p><p><strong>模块的作用域应该在模块之内功能应该是可预测的</strong></p><p><strong>高内聚低耦合</strong> <strong>系统分解有层次较小的数据冗余</strong></p><p><strong>（2）</strong> <strong>模块独立性的度量</strong></p><p><strong>聚合：衡量模块内部各元素结合的紧密程度</strong></p><p>偶然聚合：模块完成的动作之间没有任何关系，或者仅仅是一种非常松散的关系。</p><p>逻辑聚合：模块内部的各个组成在逻辑上具有相似的处理动作，但功能用途上彼此无关。时间聚合：模块内部的各个组成部分所包含的处理动作必须在同一时间内执行。</p><p>过程聚合：模块内部各个组成部分所要完成的动作虽然没有关系，但必须按特定的次序执行。通信聚合：模块的各个组成部分所完成的动作都使用了同一个数据或产生同一输出数据。</p><p>顺序聚合：模块内部的各个部分，前一部分处理动作的最后输出是后一部分处理动作的输入。</p><p>功能聚合：模块内部各个部分全部属于一个整体，并执行同一功能，且各部分对实现该功能都比不可少</p><p><strong>耦合：度量不同模块间互相依赖的程度</strong></p><p>非直接耦合：两个模块之间没有直接关系，它们的联系完全是通过主模块的控制和调用来实现的。数据耦合：两个模块彼此间通过数据参数交换信息。</p><p>标记耦合：一组模块通过参数表传递记录信息，这个记录是某一个数据结构的子结构，而不是简单变量。控制耦合：两个模块彼此间传递的信息中有控制信息。</p><p>外部耦合：一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息。</p><p>公共耦合：两个模块之间通过一个公共的数据区域传递信息。内容耦合：一个模块需要涉及到另一个模块的内部信息。</p><h4 id="_2-2-4-4-面向对象设计-⭐⭐⭐⭐⭐" tabindex="-1"><a class="header-anchor" href="#_2-2-4-4-面向对象设计-⭐⭐⭐⭐⭐" aria-hidden="true">#</a> <strong>2.2.4.4.面向对象设计（⭐⭐⭐⭐⭐）</strong></h4><h5 id="_2-2-4-4-1-过程" tabindex="-1"><a class="header-anchor" href="#_2-2-4-4-1-过程" aria-hidden="true">#</a> 2.2.4.4.1. <img src="'+S+'" alt="" loading="lazy"><strong>过程</strong></h5><p><strong>设计原则</strong></p><p>单一职责原则：设计目的单一的类</p><p>开放-封闭原则：对扩展开放，对修改封闭李氏(Liskov)替换原则：子类可以替换父类</p><p>依赖倒置原则：要依赖于抽象，而不是具体实现；针对接口编程，不要针对实现编程接口隔离原则：使用多个专门的接口比使用单一的总接口要好</p><p>组合重用原则：要尽量使用组合，而不是继承关系达到重用目的</p><p>迪米特(Demeter)原则(最少知识法则)：一个对象应当对其他对象有尽可能少的了解</p><h5 id="_2-2-4-4-2-设计模式概念" tabindex="-1"><a class="header-anchor" href="#_2-2-4-4-2-设计模式概念" aria-hidden="true">#</a> 2.2.4.4.2. <strong>设计模式概念</strong></h5><p><strong>架构模式</strong>：软件设计中的高层决策，例如 C/S 结构就属于架构模式，架构模式反映了开发软件系统过程中所作的基本设计决策</p><p><strong>设计模式</strong>：主要关注软件系统的设计，与具体的实现语言无关</p><p><strong>惯用法</strong>：是最低层的模式，关注软件系统的设计与实现，实现时通过某种特定的程序设计语言来描述构件与构件之间的关系。每种编程语言都有它自己特定的模式，即语言的惯用法。例如引用-计数就是C++语言中的一种惯用法</p><h5 id="_2-2-4-4-3-设计模式分类" tabindex="-1"><a class="header-anchor" href="#_2-2-4-4-3-设计模式分类" aria-hidden="true">#</a> 2.2.4.4.3. <strong>设计模式分类</strong></h5><p><strong>创建型模式</strong>：与对象的创建有关，抽象了实例化过程，它们帮助一个系统独立于如何创建、组合和表示它的那些对象。一个类创建型模式使用继承改变被实例化的类，而一个对象创建型模式将实例化委托给另一个对象。</p><p><strong>结构型模式</strong>：处理类或对象的组合，结构型设计模式涉及如何组合类和对象以获得更大的结构。结构型类模式采用继承机制来组合接口或实现。结构型对象模式不是对接口和实现进行组合，而是描述了如何对一些对象进行组合，从而实现新功能的一些方法。</p><p><strong>行为型模式</strong>：涉及算法和对象间职责的分配。行为模式不仅描述对象或类的模式，还描述它们之间的通信模式。行为型类模式使用继承机制在类间分配行为，这里包括模板类模式和解释器类模式。行为对象模式使用对象复合而不是继承。一些行为对象模式描述了一组对等的对象怎样相互协作以完成其中任一对象都无法单独完成的任务。</p><figure><img src="'+j+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>设计模式适用场景创建型模式</strong></p><figure><img src="'+P+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>结构型模式</strong></p><figure><img src="'+E+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>行为型模式</strong></p><figure><img src="'+v+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_2-2-5-软件测试-⭐⭐⭐⭐⭐" tabindex="-1"><a class="header-anchor" href="#_2-2-5-软件测试-⭐⭐⭐⭐⭐" aria-hidden="true">#</a> <strong>2.2.5.软件测试（⭐⭐⭐⭐⭐）</strong></h3><h4 id="_2-2-5-1-概念和目标" tabindex="-1"><a class="header-anchor" href="#_2-2-5-1-概念和目标" aria-hidden="true">#</a> <strong>2.2.5.1.概念和目标</strong></h4><p>（1） 概念：为了发现错误而执行程序的过程</p><p>（2） 目标（《软件测试的艺术》）是为了发现错误而执行程序的过程</p><p>好的测试方案能够发现迄今为止尚未发现的错误成功的测试将发现至今尚未发现的错误</p><h4 id="_2-2-5-2-软件测试原则" tabindex="-1"><a class="header-anchor" href="#_2-2-5-2-软件测试原则" aria-hidden="true">#</a> <strong>2.2.5.2.软件测试原则</strong></h4><p>（1） 应尽早并不断地进行测试</p><p>（2） 程序员避免测试自己设计的程序：测试工作应避免由原开发软件的人或小组来承担（单元测试除外）</p><p>（3） 不仅要包括合理、有效的输入条件，也要包括不合理、失效的输入条件</p><p>（4） 不仅要确定输入数据，而且要从系统的功能出发确定输出的结果</p><p>（5） 不仅要检测程序是否做了该做的事，还要检测是否做了不该做的事</p><p>（6） 修改后应进行回归测试</p><p>（7） 尚未发现的错误数量与该程序已发现的错误数成正比。</p><p>（8） 充分重视测试中的群集现象</p><p>（9） 所有的测试都应追溯到用户需求</p><p>（10） 穷举测试是不可能的</p><p>（11） 严格按照测试计划来进行，避免随意性</p><p>（12） 妥善保存测试计划、测试用例、作为软件</p><h4 id="_2-2-5-3-基本测试活动" tabindex="-1"><a class="header-anchor" href="#_2-2-5-3-基本测试活动" aria-hidden="true">#</a> <strong>2.2.5.3.基本测试活动</strong></h4><p>（1） 拟定测试计划，制定系统测试计划</p><p>在拟定测试计划时，要充分考虑整个项目的开发时间和开发进度以及一些人为因素和客观条件等，使得测试计划是可行的。测试计划的内容主要有：测试的内容、进度安排、测试所需的环境和条件（包括设备、被测项目、人员等）、测试培训安排等。</p><p>（2） 编制测试大纲</p><p>测试大纲是测试的依据。其明确详尽地规定了在测试中针对系统的每一项功能或特性所必须完成的基本测试项目和测试完成的标准。</p><p>（3） 设计和生成测试用例</p><p>根据测试大纲，设计和生成测试用例。在设计测试用例时，可综合利用前面介绍的测试用例设计技术，产生测试设计说明文档，其内容主要有：被测项目、输入数据、测试过程、预期输出结果等等。</p><p>（4） 执行系统测试，实施测试</p><p>测试的实施阶段是由一系列的测试周期组成的。在每个测试周期中，测试人员和开发人员将依据预先编制好的测试大纲和准备好的测试用例，对被测软件或设备进行完整的测试。</p><p>（5） 缺陷管理与改错，生成测试报告</p><p>测试完成后要形成相应的测试报告，主要对测试进行概要说明，列出测试的结论，指出缺陷和错误。</p><h4 id="_2-2-5-4-测试阶段和分类" tabindex="-1"><a class="header-anchor" href="#_2-2-5-4-测试阶段和分类" aria-hidden="true">#</a> <strong>2.2.5.4.测试阶段和分类</strong></h4><figure><img src="'+B+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+J+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h5 id="_2-2-5-4-1-单元测试" tabindex="-1"><a class="header-anchor" href="#_2-2-5-4-1-单元测试" aria-hidden="true">#</a> 2.2.5.4.1. <strong>单元测试</strong></h5><p>概念：又称模块测试，是通过对每个最小的软件模块进行测试，对照模块的功能说明，检查各个程序模块是否正确地实现了规定的功能，确保其能正常工作。</p><p>测试主体：单元测试由开发人员执行</p><p>测试内容：模块接口测试、局部数据结构测试、路径测试、错误处理测试、边界测试（模块测试，模块功能、性能、接口等）。</p><h5 id="_2-2-5-4-2-集成测试" tabindex="-1"><a class="header-anchor" href="#_2-2-5-4-2-集成测试" aria-hidden="true">#</a> 2.2.5.4.2. <strong>集成测试</strong></h5><p>概念：在单元测试的基础上，需要将所有模块按照概要设计说明书和详细设计说明书的要求进行组装。主要目的是验证组成软件系统的各模块的接口和交换作用。（模块间的接口）</p><p>组装时需要考虑的问题：在把各个模块连接起来的时候，穿越模块接口的数据是否会丢失</p><p>一个模块的功能是否会对另一个模块的功能产生不利的影响；各个子功能组合起来，能否达到预期要求的父功能；全局数据结构是否有问题；单个模块的误差累积起来，是否会放大，以致达到不能接受的程度 <strong>模块组装方式</strong></p><figure><img src="'+w+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>一次性组装方式</strong>：其结果：发现有错误，却茫然找不到原因；查错和改错都会遇到困难。</p><p><strong>自顶向下的增殖方式</strong>：优点：在测试过程中较早地验证了主要的控制和判断点；功能可行性较早地得到证实，还能增强开发者和用户成功的信心。缺点：导致过多的回归测试；增加建桩模块的复杂度，导致增加附加测试</p><p><strong>自底向上的增殖方式</strong>：优点：可以把容易出问题的部分在早期解决；缺点：对主要的控制直到最后才接触到；可以实施多个模块的并行测试，提高测试效率。</p><p>**混合增殖方式，**完成的标志：成功地执行了测试计划中规定的所有集成测试；修正了所发现的错误（与用户就剩余错误的修改计划达成一致）；测试结果通过了专门小组的评审</p><p><strong>（1）</strong> **“冒烟测试”（英文：smoke testing）**这一术语源自硬件行业。对一个硬件或硬件组件进行更改或修复后，直接给设备加电。如果没有冒烟，则该组件就通过了测试。</p><h5 id="_2-2-5-4-3-确认测试" tabindex="-1"><a class="header-anchor" href="#_2-2-5-4-3-确认测试" aria-hidden="true">#</a> 2.2.5.4.3. <strong>确认测试</strong></h5><p>概念：又称合格性测试，用来检验软件是否符合用户的需求。一般采用黑盒测试法，通过一系列证明软件功能和要求的测试来实现。确认测试着重考虑软件是否满足合同规定的所有功能和性能、文档资料是否完整。确认人机界面和其他方面（如可移植性、兼容性、错误恢复能力和可维护性等）是否令用户满意确认测试过程的重要环节就是配置审查工作。配置审查的文件资料包括用户手册、操作手册和设计资料。其目的在于确保软件的所有文件资料均已编写齐全，用于支持日后软件的维护工作。（验证软件与需求的一致性。内部确认测试、Alpha 测试、Beta 测试，验收测试）</p><h5 id="_2-2-5-4-4-系统测试" tabindex="-1"><a class="header-anchor" href="#_2-2-5-4-4-系统测试" aria-hidden="true">#</a> 2.2.5.4.4. <strong>系统测试</strong></h5><p>概念：系统测试真实环境下，验证完整的软件配置项能否和系统正确连接。将软件与整个系统的硬件、外设、支持软件、数据和人员等结合起来，以需求规格说明为依据，在实际运行环境下进行测试。检验其是否有不符合系统说明书的地方。</p><p>系统测试过程分为计划与准备、执行、返工与回归测试 3 个阶段</p><p>内容：系统测试一般要完成功能测试、性能测试、恢复测试、安全测试、强度测试以及其他限制条件的测试。</p><h5 id="_2-2-5-4-5-验收测试" tabindex="-1"><a class="header-anchor" href="#_2-2-5-4-5-验收测试" aria-hidden="true">#</a> 2.2.5.4.5. <strong>验收测试</strong></h5><p>概念：在测试组的协调下，由用户代表执行。检验系统说明书的各项功能与性能是否实现和满足要求。验收测试完全采用黑盒测试技术，其主要任务是文档资料的审查验收、软件系统的功能测试、性能测试、强化测试、性能降级执行方式测试、检查系统的余量要求、安装测试以及用户操作测试。</p><h5 id="_2-2-5-4-6-回归测试" tabindex="-1"><a class="header-anchor" href="#_2-2-5-4-6-回归测试" aria-hidden="true">#</a> 2.2.5.4.6. <strong>回归测试</strong></h5><p>测试软件变更之后，变更部分的正确性对变更需求的符合性。</p><h5 id="_2-2-5-4-7-α与β测试" tabindex="-1"><a class="header-anchor" href="#_2-2-5-4-7-α与β测试" aria-hidden="true">#</a> 2.2.5.4.7. <strong>α与β测试</strong></h5><p><strong>Alpha</strong> <strong>测试</strong>：是在开发环境下进行的测试，由用户/内部用户模拟实际操作环境下进行的受控测试。目的是评价软件产品的功能、可使用性、可靠性、性能和支持。尤其要注重产品的界面和特色。</p><p><strong>Beta</strong> <strong>测试</strong>：是用户在实际使用环境下进行的测试。</p><h5 id="_2-2-5-4-8-白盒测试" tabindex="-1"><a class="header-anchor" href="#_2-2-5-4-8-白盒测试" aria-hidden="true">#</a> 2.2.5.4.8. <strong>白盒测试</strong></h5><p>概念：根据内部结构和逻辑来设计测试用例，对程序路径和过程进行测试。</p><p><strong>【方法】</strong></p><p><strong>语句覆盖（SC）</strong>：设计足够的测试用例，使得使被测试程序中每条语句至少执行一次。</p><p><strong>判定覆盖（DC）</strong>:设计足够的测试用例，使得使程序中的每个判定至少都获得一次“真值”或“假值”。又称分支覆盖：使程序中的每一个取“真”分支和取“假”分支至少经历一次。</p><p><strong>条件覆盖（CC）</strong>：设计足够的测试用例，使得使得每一判定语句中每个逻辑条件的可能值至少满足一次。<strong>条件判定组合覆盖（CDC）</strong>：设计足够的测试用例，使得使得判定中每个条件的所有可能（真/假）至少出现一次，并且每个判定本身的结果（真/假）也至少出现一次。</p><p><strong>多条件覆盖（MCC）</strong>：设计足够的测试用例，使得使得每个判定中条件的各种可能组合都至少出现一次。<strong>修正判定条件覆盖（MCDC）</strong>：设计足够的测试用例，使得每一程序模块的入口和出口点都要考虑至少被调用一次，每个程序的判定到所有可能的结果值要至少转换一次；程序的判定被分解为通过逻辑操作符（and or）连接的bool 条件，每个条件判定的结果值是独立的。</p><p>**路径覆盖：**设计足够的测试用例，使得被测试程序中的所有可能路径至少被执行一次。</p><h5 id="_2-2-5-4-9-黑盒测试" tabindex="-1"><a class="header-anchor" href="#_2-2-5-4-9-黑盒测试" aria-hidden="true">#</a> 2.2.5.4.9. <strong>黑盒测试</strong></h5><p>概念：黑盒测试基于产品功能规格说明书，从用户角度针对产品特定的功能和特性进行验证活动，确认每个功能是否得到完整实现，用户能否正常使用这些功能。</p><p>黑盒测试在不知道系统或组件内部结构的情况下进行，不考虑内部逻辑结构，着眼于程序外部结构，在软件接口处进行测试。</p><p>试图发现的错误：功能不正确或遗漏；界面错误；数据库访问错误；性能错误；初始化和终止错误等</p><p>**方法：等价类划分法；边界值分析法；因果图法；<strong>判定表驱动法</strong>；<strong>正交试验设计法</strong>；错误推测法 ；**功能图法。</p><p><strong>等价类划分法</strong></p><p>原则：在输入条件规定了取值范围或值的个数的情况下，可以确定一个有效等价类和两个无效等价类:在输入条件规定了输入值得集合或者规定了“必须如何”的条件的情况下，可以确立一个有效等价类和一个无效等价类；在输入条件是一个布尔量的情况下，可确定一个有效等价类和一个无效等价类；在规定了输入数据的一组值（假定 n 个），并且程序要对每一个输入值分别处理的情况下，可确定 n 个有效等价类和一个无效等价类；在规定了输入数据必须遵守的规则的情况下，可确定一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）；在确知已划分的等价类中，各元素在程序处理中的方式不同的情况下，则应再将该等价类进一步地划分为更小的等价类</p><p>过程：根据软件的功能说明，对每一个输入条件确定若干个有效等价类和若干个无效等价类，并为每个有效等价类和无效等价类编号。设计一个测试用例，使其覆盖尽可能多的尚未被覆盖的有效等价类。重复这一步，直至所有的有效等价类均被覆盖。设计一个测试用例，使其覆盖一个尚未被覆盖的无效等价类。重复这一步，直至所有的无效等价类均被覆盖。</p><p>应当特别注意，无效等价类是用来测试非正常的输入数据的，因此每个无效等价类都有可能查出软件中的错误，所以要为每个无效等价类设计一个测试用例。</p><p><strong>边界值分析</strong></p><p>经验表明，软件在处理边界情况时最容易出错。设计一些测试用例，使软件恰好运行在边界附近，暴露出软件错误的可能性会更大一些。通常，每一个等价类的边界，都应该着重测试，选取的测试数据应该恰好等于、稍小于或稍大于边界值。</p><h5 id="_2-2-5-4-10-静态测试" tabindex="-1"><a class="header-anchor" href="#_2-2-5-4-10-静态测试" aria-hidden="true">#</a> 2.2.5.4.10. <strong>静态测试</strong></h5><p>从测试的类型来看，可以分为动态测试和静态测试。所谓动态测试就是实际的将软件运行。而静态测试它就不运行软件测试的程序，而是采用人工检测、计算机分析辅助静态分析的手段来对程序进行检测。动态测试可以分为黑盒测试、白盒测试和灰盒测试。白盒测试也称为结构性测试，黑盒测试也称为功能性测 试。灰盒测试是二者的结合。静态测试的方法主要有桌前检查、代码走查、代码审查。</p><p><strong>桌前检查</strong>：由程序员检查自己编写的程序。程序员在程序通过编译之后，进行单元测试设计之前，对源程序代码进行分析和检验，并补充相关的文档，目的是发现程序中的错误。检查项目包括检查变量的交叉引用表；检查标号的交叉引用表；检查子程序、宏、函数；等值性检查；常量检查；标准检查；风格检查；比较控制流；选择、激活路径；对照程序的规格说明，详细阅读源代码；补充文档。</p><p><strong>代码审查</strong>：代码审查是由若干程序员和测试人员组成一个会审小组，通过阅读、讨论和争议，对程序进行</p><p>静态分析的过程。代码审查的过程可以分为两个步骤：第一步，小组负责人提前把设计规格说明书、控制流程图、程序文本及有关要求、规范等分发给小组成员，作为评审的依据。小组成员在充分阅读这些材料之后，进入审查的第二步。第二步，召开程序审查会。在会上，首先由程序员逐句讲解程序的逻辑。在此过程中，程序员或其他小组成员可以提出问题，展开讨论，审查是否存在错误。实践表明，程序员在讲解过程中能发现许多原来自己没有发现的错误，而讨论和争议则促进了问题的暴露。</p><p>在会前，应当给会审小组每个成员准备一份常见错误的清单（通常称为检查单或检查表），把以往所有可能发生的常见错误罗列出来，供与会者对照检查，以提高会审的效率。检查单把程序中可能发生的各种错误进行分类，对每一类列举出尽可能多的典型错误，然后把它们制成表格，供在会审时使用。</p><p><strong>代码走查</strong>：代码走查与代码审查基本相同，其过程也分为两个步骤： 第一步，把材料先发给走查小组每个成员，让他们认真研究程序，然后再开会。第二步，开会的程序与代码会审不同，不是简单地读程序和对照错误检查单进行检查，而是让与会者“充当”计算机。即首先由测试组成员为被测程序准备一批有代表性的测试用例，提交给走查小组。走查小组开会，集体扮演计算机角色，让测试用例沿程序的逻辑运行一遍，随时记录程序的踪迹，供分析和讨论使用。</p><h5 id="_2-2-5-4-11-狭义性能测试分类" tabindex="-1"><a class="header-anchor" href="#_2-2-5-4-11-狭义性能测试分类" aria-hidden="true">#</a> 2.2.5.4.11. <strong>狭义性能测试分类</strong></h5><p><strong>负载测试</strong>：确定在各种工作负载下系统的性能，目标是测试当负载逐渐增加时，系统各项性能指标的变化情况。</p><p><strong>压力测试</strong>：通过确定一个系统的瓶颈或不能接受的性能点，来获得系统能提供的最大服务级别的测试。<strong>强度测试</strong>：在系统资源特别低的情况下考查软件系统运行情况。</p><p><strong>并发测试</strong>：并发测试也称为容量测试，主要用来确定系统可处理的同时在线的最大用户数。</p><h4 id="_2-2-5-5-面向对象的测试" tabindex="-1"><a class="header-anchor" href="#_2-2-5-5-面向对象的测试" aria-hidden="true">#</a> <strong>2.2.5.5.面向对象的测试</strong></h4><p><strong>算法层（单元测试）</strong>：包括等价类划分测试、组合功能测试（基于判定表的测试）、递归函数测试和多态消息测试。（方法层次）</p><p><strong>类层（模块测试）</strong>：包括不变式边界测试、模态类测试和非模态类测试<strong>模板层/类树层（集成测试）</strong>：包括多态服务测试和展平测试</p><p><strong>系统层（系统测试）</strong></p><h3 id="_2-2-6-软件调试-⭐" tabindex="-1"><a class="header-anchor" href="#_2-2-6-软件调试-⭐" aria-hidden="true">#</a> <strong>2.2.6.软件调试（<strong>⭐</strong>）</strong></h3><h4 id="_2-2-6-1-软件调试方法" tabindex="-1"><a class="header-anchor" href="#_2-2-6-1-软件调试方法" aria-hidden="true">#</a> <strong>2.2.6.1.软件调试方法</strong></h4><p>（1） 蛮力法：主要思想是“通过计算机找错”，低效，耗时</p><p>（2） 回溯法：从出错处人工沿控制流程往回追踪，直至发现出错的根源。复杂程序由于回溯路径多，难以实施（适合于小型程序）</p><p>（3） 原因排除法：主要思想是演绎和归纳，用二分法实现</p><p>（4） 试探法：调试人员分析错误的症状，猜测问题的位置所在，利用在程序中设置输出语句，分析寄存器、存储器的内容等手段来获得错误的线索，通过一步步的试探和分析来找到错误所在。</p><p>效率低、适合于结构较简单的程序</p><p>（5） 归纳法：是从测试所暴露的错误出发，收集所有正确或不正确的数据，分析它们之间的关系，提出假想的错误原因，用这些数据来证明或反驳，从而查出错误所在。</p><p>（6） 演绎法：根据测试结果，列出所有可能的错误原因。分析已有的数据，排除不可能和彼此矛盾的原因，对余下的原因选择可能性最大的，利用已有的数据完善该假设，使假设更具体。</p><p>（7） 对分查找法：这种方法主要用来缩小错误的范围。如果已经知道了程序中的变量在若干位置的预期正确取值，可以在这些位置上用赋值语句或输入语句，给这些变量以正确值，运行程序观察输出结果。如果没有发现问题，则说明从给变量的正确值开始到输出结果之间的程序没有出错。然后对剩下部分的程序再依次进行直到把故障范围缩小到比较容易诊断为止。</p><h4 id="_2-2-6-2-软件调试与测试的区别" tabindex="-1"><a class="header-anchor" href="#_2-2-6-2-软件调试与测试的区别" aria-hidden="true">#</a> <strong>2.2.6.2.软件调试与测试的区别</strong></h4><p>测试的目的是找出存在的错误，而调试的目的是定位错误并修改程序以修正错误调试是测试之后的活动，测试和调试在目标、方法和思路上都有所不同</p><p>测试从一个已知的条件开始，使用预先定义的过程，有预知的结果；调试从一个未知的条件开始，结束的过程不可预计</p><p>测试过程可以事先设计，进度可以事先确定；调试不能描述过程或持续时间</p><h3 id="_2-2-7-系统运行与软件维护" tabindex="-1"><a class="header-anchor" href="#_2-2-7-系统运行与软件维护" aria-hidden="true">#</a> <strong>2.2.7.系统运行与软件维护</strong></h3><h4 id="_2-2-7-1-系统转换计划-⭐⭐⭐" tabindex="-1"><a class="header-anchor" href="#_2-2-7-1-系统转换计划-⭐⭐⭐" aria-hidden="true">#</a> <strong>2.2.7.1.系统转换计划（⭐⭐⭐）</strong></h4><h5 id="_2-2-7-1-1-遗留系统演化策略" tabindex="-1"><a class="header-anchor" href="#_2-2-7-1-1-遗留系统演化策略" aria-hidden="true">#</a> 2.2.7.1.1. <strong>遗留系统演化策略</strong></h5><figure><img src="'+N+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>淘汰策略</strong>：遗留系统的技术含量较低，且具有较低的业务价值。对遗留系统的完全淘汰是企业资源的根本浪费，系统分析师应该善于“变废为宝”，通过对遗留系统功能的理解和借鉴，可以帮助新系统的设计，降低新系统开发的风险。</p><p><strong>继承策略</strong>：遗留系统的技术含量较低，已经满足企业运作的功能或性能要求，但具有较高的商业价值，目前企业的业务尚紧密依赖该系统。对这种遗留系统的演化策略为继承。在开发新系统时，需要完全兼容遗留系统的功能模型和数据模型。为了保证业务的连续性，新老系统必须并行运行一段时间，再逐渐切换到新系统上运行。</p><p><strong>改造策略</strong>：遗留系统具有较高的业务价值，基本上能够满足企业业务运作和决策支持的需要。这种系统可能建成的时间还很短，对这种遗留系统的演化策略为改造。改造包括系统功能的增强和数据模型的改造两个方面。系统功能的增强是指在原有系统的基础上增加新的应用要求，对遗留系统本身不做改变；数据模型的改造是指将遗留系统的旧的数据模型向新的数据模型的转化。</p><p><strong>集成策略</strong>：遗留系统的技术含量较高，但其业务价值较低，可能只完成某个部门（或子公司）的业务管 理。这种系统在各自的局部领域里工作良好，但对于整个企业来说，存在多个这样的系统，不同的系统基于不同的平台、不同的数据模型，形成了一个个信息孤岛，对这种遗留系统的演化策略为集成。</p><h5 id="_2-2-7-1-2-新旧系统转换策略" tabindex="-1"><a class="header-anchor" href="#_2-2-7-1-2-新旧系统转换策略" aria-hidden="true">#</a> 2.2.7.1.2. <strong>新旧系统转换策略</strong></h5><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="'+O+'" alt="" loading="lazy"></td></tr></tbody></table><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="'+W+'" alt="" loading="lazy"></td></tr></tbody></table><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="'+k+'" alt="" loading="lazy"></td></tr></tbody></table><p><strong>直接转换</strong>：接转换是在原有系统停止运行的某一时刻，新系统立即投入运行，中间没有过度阶段。采用这种方式时，人力和费用最省，适用于系统不太复杂或现有系统完全不能使用的场合。但是这种方式风险 高。</p><p><strong>并行转换</strong>：并行转换就是新系统和旧系统并行工作一段时间，经过这段时间的试运行后，再用新系统正式替换下现有系统。那么这种方式，它的好处就是风险很小。在转换期间还可以同时比较新旧两套系统的性能，而且能够让操作人员得到全面的培训，所以对于一些比较大的信息系统，或者处理过程比较复杂，数据比较重要的系统。并行转换是一种最常用的转换方式。那么这种转换方式也有缺点，缺点就在于两套系统并行期间。要有两套人马，或者两套处理方式同时并存，在人力和费用消耗比较大，转换的周期比较 长，而且难以控制新旧系统当中数据的变化。所以这就要求要做好转换计划，并且要加强管理。</p><p><strong>分段转换</strong>：这是直接转换和并行转换的接合，也就是分期分批、逐步转换。一般比较大的系统可以采用这种方式比较合适，他能够保证软件平稳运行，费用也不太高，就是将大的系统分成多个子系统，每成熟一个子系统就切换一个子系统，主要是分期分批。这种分段转换的策略，它的优点就是成熟一个子系统就转换一个子系统。这种新旧转换，震动比较小，用户比较容易接受。但是由于采取的是渐进的方式，会导致新旧系统的转换周期比较长。</p><p><strong>（1）数据转换与迁移（<strong>⭐</strong>）</strong></p><figure><img src="'+I+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_2-2-7-2-系统维护-⭐" tabindex="-1"><a class="header-anchor" href="#_2-2-7-2-系统维护-⭐" aria-hidden="true">#</a> <strong>2.2.7.2.系统维护（<strong>⭐</strong>）</strong></h4><p>（1） 概念</p><p>软件维护是生命周期的一个完整部分。可以将软件维护定义为需要提供软件支持的全部活动，这些活动包括在交付前完成的活动，以及交付后完成的活动。交付前完成的活动包括交付后运行的计划和维护计划 等；交付后的活动包括软件修改、培训、帮助资料等。</p><p>（2） 分类</p><p><strong>正确性维护</strong>：指改正在系统开发阶段已发生而系统测试阶段尚未发现的错误。</p><p><strong>适应性维护</strong>：指使应用软件适应信息技术变化和管理需求变化而进行的修改。企业的外部市场环境和管理需求的不断变化也使得各级管理人员不断提出新的信息需求。</p><p><strong>完善性维护</strong>：扩充功能和改善性能而进行的修改。对已有的软件系统增加一些在系统分析和设计阶段中没有规定的功能与性能特征。</p><p><strong>预防性维护</strong>：为了改进应用软件的可靠性和可维护性，为了适应未来的软硬件环境的变化，应主动增加预防性的新的功能，以使用系统适应各类变化而不被淘汰。如将专用报表功能改成通用报表生成功能，以适应将来报表格式的变化。</p><h3 id="_2-2-8-软件开发环境与工具-⭐" tabindex="-1"><a class="header-anchor" href="#_2-2-8-软件开发环境与工具-⭐" aria-hidden="true">#</a> <strong>2.2.8.软件开发环境与工具（<strong>⭐</strong>）</strong></h3><figure><img src="'+T+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_2-2-8-1-环境机制" tabindex="-1"><a class="header-anchor" href="#_2-2-8-1-环境机制" aria-hidden="true">#</a> <strong>2.2.8.1.环境机制</strong></h4><p>（1） 环境信息库。环境信息库是软件开发环境的核心，用以存储与系统开发有关的信息，并支持信息的交流与共享。环境信息库中主要存储两类信息，一类是开发过程中产生的有关被开发系统的信息，例如，分析文档、设计文档和测试报告等；另一类是环境提供的支持信息，例如，文档模板、系统配置、过程模型和可复用构件等。</p><p>（2） 过程控制与消息服务器。过程控制与消息服务器是实现过程集成和控制集成的基础。过程集成是按照具体软件开发过程的要求进行工具的选择与组合，控制集成使各工具之间进行并行通信和协同工作。</p><p>（3） 环境用户界面。环境用户界面包括环境总界面和由它实行统一控制的各环境部件及工具的界面。统一的、具有一致性的用户界面是软件开发环境的重要特征，是充分发挥环境的优越性、高效地使用工具并减轻用户的学习负担的保证。</p><h4 id="_2-2-8-2-工具" tabindex="-1"><a class="header-anchor" href="#_2-2-8-2-工具" aria-hidden="true">#</a> <strong>2.2.8.2.工具</strong></h4><p>在软件生命周期中，要使用很多软件工具，从其功能上进行划分，可以分为<strong>软件开发工具、软件维护工具、软件管理和支持工具三类。</strong></p><p>（1） <strong>软件开发工具</strong>。软件开发工具用来辅助开发人员进行软件开发活动，包括需求分析工具、设计工具、编码与排错工具等。</p><p>（2） <strong>软件维护工具</strong>。软件维护工具用来辅助维护人员对软件代码及其文档进行各种维护活动，包括版本管理工具、文档分析工具、开发信息库工具、逆向工程工具和再工程工具等。</p><p>（3） <strong>软件管理和支持工具</strong>。软件管理和支持工具用来辅助管理人员和软件支持人员的管理活动和支持活动，以确保软件高质量的完成。包括项目管理工具、配置管理工具和软件评价工具等。</p><h2 id="_2-3-章节问答" tabindex="-1"><a class="header-anchor" href="#_2-3-章节问答" aria-hidden="true">#</a> <strong>2.3.章节问答</strong></h2><h3 id="_1-演化模型跟螺旋模型-增量模型-原型法开发的关系" tabindex="-1"><a class="header-anchor" href="#_1-演化模型跟螺旋模型-增量模型-原型法开发的关系" aria-hidden="true">#</a> <strong>（1）演化模型跟螺旋模型，增量模型，原型法开发的关系？</strong></h3><p>答：首先是原型化，原型化又可以分为两种，抛弃式原型和演化式原型，其中 最终演化成一个产品的就演变成为演化模型。螺旋模型式是通过演化模型和瀑布模型的结合所产生的，并且螺旋模型强调了风险管理。增量模型是原型模型和瀑布模型所结合而产生的。其中螺旋模型和增量模型的区别：螺旋模型他是一直旋下去，旋到最后才是一个产品，而增量模型每一个增量都发布了一个可操作的产品，这是它的一个细微的区别</p><h3 id="_2-面向对象方法中的分析模型、设计模型有哪些" tabindex="-1"><a class="header-anchor" href="#_2-面向对象方法中的分析模型、设计模型有哪些" aria-hidden="true">#</a> <strong>（2）面向对象方法中的分析模型、设计模型有哪些？</strong></h3><p>答：面向对象的分析模型主要由顶层架构图、用例与用例图、领域概念模型构成；设计模型则包含以包图表示的软件体系结构图、以交互图表示的用例实现图、完整精确的类图、针对复杂对象的状态图和用以描述流程化处理过程的活动图等。</p><h3 id="_3-结构化方法中的设计模型有哪些" tabindex="-1"><a class="header-anchor" href="#_3-结构化方法中的设计模型有哪些" aria-hidden="true">#</a> <strong>（3）结构化方法中的设计模型有哪些？</strong></h3><p>答：结构化设计包括了概要设计和详细设计。模型主要是用数据流图表示功能模型，用状态转换图表示行为模型，用 E-R 图表示数据模型。</p><h3 id="_4-自顶向下开发方法的优缺点" tabindex="-1"><a class="header-anchor" href="#_4-自顶向下开发方法的优缺点" aria-hidden="true">#</a> <strong>（4）自顶向下开发方法的优缺点？</strong></h3><p>答：自顶向下方法的优点是：可为企业或机构的重要决策和任务实现提供信息；支持企业信息系统的整体性规划，并对系统的各子系统的协调和通信提供保证；方法的实践有利于提高企业人员整体观察问题的能力，从而有利于寻找到改进企业组织的途径。</p><p>自顶向下方法的缺点是：对系统分析和设计人员的要求较高；开发周期长，系统复杂，一般属于一种高成本、大投资的工程；对于大系统而言自上而下的规划对于下层系统的实施往往缺乏约束力；从经济角度来看，很难说自顶向下的做法在经济上是合算的。</p><h3 id="_5-为什么自顶向下的单元测试中不需要另外编写驱动模块" tabindex="-1"><a class="header-anchor" href="#_5-为什么自顶向下的单元测试中不需要另外编写驱动模块" aria-hidden="true">#</a> <strong>（5）为什么自顶向下的单元测试中不需要另外编写驱动模块？</strong></h3><p>答：对于模块的划分，上层为驱动模块（驱动模块用来调用被测模块），下层为桩模块（桩模块用来模拟被测模块所调用的子模块）。自顶向下测试时，调用模块已经写完，不需要另写驱动模块，但是需要用桩模块来帮助测试。自底向上测试时，底层模块已经写完，不需要另写桩模块，但是需要用驱动模块来帮助测试。</p><h3 id="_6-构件模型在使用上的局限性和缺点有哪些" tabindex="-1"><a class="header-anchor" href="#_6-构件模型在使用上的局限性和缺点有哪些" aria-hidden="true">#</a> <strong>（6）构件模型在使用上的局限性和缺点有哪些？</strong></h3><p>答：优点：这大大提高了软件开发的效率，而且构件模型允许多个项目同时开发，降低了费用，提高了可维护性。</p><p>缺点：由于存在多种构件标准，缺乏通用的构件组装结构标准，如果自行定义标准的话，会引入较大的风险；构件可重用性和软件系统高效性之间不易协调，需要权衡。</p><h3 id="_7-设计模式要求掌握到什么程度" tabindex="-1"><a class="header-anchor" href="#_7-设计模式要求掌握到什么程度" aria-hidden="true">#</a> <strong>（7）设计模式要求掌握到什么程度？</strong></h3><p>答：设计模式有一定难度。对于设计模式要求掌握如下内容：1、各设计模式中英文拼写；2、设计模式分类；</p><p>3、各设计模式的适用场景，可见上文列出的关键字表格进行记忆。如有余力，可了解相关类图（类图不作具体要求）。</p>',467),K=[Y];function Q(V,q){return r(),n("div",null,K)}const H=t(X,[["render",Q],["__file","软件工程.html.vue"]]);export{H as default};
