import{_ as t}from"./plugin-vue_export-helper-x3n3nnut.js";import{o,c as e,d as i}from"./app-AuAuVshg.js";const s="/assets/Debug全局预览-sJA-O2Z2.png",r="/assets/调用method2-0hR75twC.png",n="/assets/回到method1-v_xXj8k9.png",g="/assets/重新执行到下一个断点-EJc-hZcc.png",a="/assets/回到某一个方法调用处-p7BJr2hl.png",p={},c=i('<p>点击<strong>Reset Frame</strong>按钮后，你将<mark><strong>返回到当前方法的调用处</strong></mark>（程序会回到method1()中）重新执行，并且所有上下文变量的值也回到那个时候。只要调用链中还有上级方法，可以跳到其中的任何一个方法。</p><p><strong>回到某一行代码查看或设置变量的方法可用这种方式实现：</strong></p><p><strong>如果当前行是在调用的方法体中，需要返回代码行N时：</strong></p><ol><li><strong>在代码行N处打上断点</strong></li><li><strong>然后点击Reset Frame</strong></li><li><strong>最后按F8即可到达这一行</strong></li></ol><p>该技巧适用于方法嵌套比较多的场景。项目进入断点，由于人为原因断点过去了，<strong>想回过头看看刚才的变量值</strong>，如果不知道该技巧，只能再跑一遍。</p><figure><img src="'+s+'" alt="Debug全局预览" tabindex="0" loading="lazy"><figcaption>Debug全局预览</figcaption></figure><p>参考上图，method1方法调用method2，当前断点的位置j=101</p><figure><img src="'+r+'" alt="调用method2" tabindex="0" loading="lazy"><figcaption>调用method2</figcaption></figure><p>点击上图红色箭头位置的<strong>Drop Frame图标，新版为Reset Frame</strong>后，时间穿越了，断点又奇迹般的回到了method1中。</p><figure><img src="'+n+'" alt="回到method1" tabindex="0" loading="lazy"><figcaption>回到method1</figcaption></figure><p>重新执行到下一个断点</p><figure><img src="'+g+'" alt="重新执行到下一个断点" tabindex="0" loading="lazy"><figcaption>重新执行到下一个断点</figcaption></figure><figure><img src="'+a+'" alt="回到某一个方法调用处" tabindex="0" loading="lazy"><figcaption>回到某一个方法调用处</figcaption></figure><p>**总结就是：**该方法只能跳回到当前方法的调用处，同时上一个方法的变量值是不会随着下一个方法的执行而变化，但是下一个方法重新执行的话，值就会累计，比如：method1返回dropFrameDebug 则执行 method1后 i累计，method2 返回method1则执行 method2后 j累计。</p>',14),m=[c];function d(_,l){return o(),e("div",null,m)}const u=t(p,[["render",d],["__file","Debug回到某一行代码.html.vue"]]);export{u as default};
