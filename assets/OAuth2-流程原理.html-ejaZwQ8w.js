import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as i,o as p,c as r,a as t,b as e,e as s,d as o}from"./app-AuAuVshg.js";const l="/assets/OAuth1-RffjzF0T.png",c="/assets/OAuth2-AgfrQaIW.png",d="/assets/OAuth3-f-cyGPBZ.png",u="/assets/OAuth4-iopz2ZT4.png",h="/assets/OAuth5-k39JI_d3.png",g="/assets/OAuth6-Ja4xa8U5.png",_="/assets/OAuth7-UI84bG3i.png",f="/assets/OAuth8-ot2-xGLy.png",m={},k=o('<h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介" aria-hidden="true">#</a> 简介</h2><p><strong>说明</strong></p><p>本文介绍OAuth2的使用场景、流程、原理。</p><p>OAuth2用于第三方授权。比如，用户在使用A网站，想获得B网站的数据，这时就需要B网站提供oauth2的授权功能让A网站获取B网站信息。</p><p><strong>OAuth2流程</strong></p><p>OAuth2流程其实很简单：</p><ol><li><p>网站A想获得B网站数据，A先让用户确认。</p></li><li><p>用户确认后，A访问B的token管理服务器，获得一个临时token。</p></li><li><p>A使用B给的临时token去B的资源服务器上获取数据。</p></li></ol><p><strong>官网</strong></p><p>draft-ietf-oauth-v2-31</p><p><strong>示例</strong></p><p>例1：有某个流程图网站，支持将流程图存入百度云盘或者从百度云盘读出。</p><p>例2：在登录百度时，可以选择第三方账号登录（微信、钉钉等）。如下图所示：</p><figure><img src="'+l+'" alt="IMG_256" tabindex="0" loading="lazy"><figcaption>IMG_256</figcaption></figure><p>如果使用QQ：可以扫描二维码登录，也可以选择电脑QQ已经登录的账号：</p><figure><img src="'+c+'" alt="IMG_257" tabindex="0" loading="lazy"><figcaption>IMG_257</figcaption></figure><p>如果使用微信：则会展示二维码，让你微信扫描二维码登录：</p><figure><img src="'+d+'" alt="IMG_258" tabindex="0" loading="lazy"><figcaption>IMG_258</figcaption></figure><p>这个登录二维码是一次性的，下次点击进来会生成新的。</p><p><strong>第三方认证为什么要用</strong>OAuth2**？**</p><p>假设有某个流程图网站，支持将流程图存入百度云盘或者从百度云盘读出。最简单的办法就是百度云盘直接将用户的账号密码给流程图网站，但这样有如下问题：</p><ol><li><p>&quot;流程图网站&quot;为了后续的服务，会保存用户的密码，这样很不安全。</p></li><li><p>&quot;流程图网站&quot;拥有了获取用户储存在百度云盘所有资料的权力，用户没法限制&quot;流程图网站&quot;获得授权的范围和有效期。</p></li><li><p>用户只有修改密码，才能收回赋予&quot;流程图网站&quot;的权力。</p></li><li><p>只要有一个第三方应用程序被破解，就会导致用户密码泄漏，以及所有被密码保护的数据泄漏。</p></li></ol><p>使用OAuth2可以很完美的解决这些问题，后边会介绍详细流程。</p><p><strong>OAuth2介绍</strong></p><p>OAuth2.0是一种允许第三方应用程序使用资源所有者的<strong>凭据</strong>获得对资源有限访问权限的一种授权协议。</p><p>例如通过微信登录百度，相当于微信允许百度作为第三方应用程序在经过微信用户授权后，通过<strong>微信颁发的授权凭证</strong>有限地访问用户的微信头像、手机号，性别等资源，从而来构建自身的登录逻辑。</p><p>在OAuth2.0协议中第三方应用程序获取的凭证并不是资源拥有者的用户名和密码。OAuth2允许用户提供一个令牌（token）给第三方网站，一个令牌对应一个特定的第三方网站，且该令牌只能在特定的时间内访问特定的资源。</p><p><strong>OAuth1.0与OAuth2.0</strong></p><p><strong>OAuth1.0的问题</strong></p><ol><li><p>开发的流程复杂。因为需要反复的签名。</p></li><li><p>授权流程过于单一化。</p></li><li><p>没有引入回跳地址的判断，导致回跳可能会篡改，这样授权码和Token会被Hack掉（1.0a的时候修复了这个漏洞）。</p></li></ol><h2 id="认证流程" tabindex="-1"><a class="header-anchor" href="#认证流程" aria-hidden="true">#</a> 认证流程</h2><h3 id="oauth2-0的角色" tabindex="-1"><a class="header-anchor" href="#oauth2-0的角色" aria-hidden="true">#</a> OAuth2.0的角色</h3><p><strong>OAuth2.0协议中定义了以下四个角色：</strong></p><ol><li><p><strong>resource owner（资源拥有者）</strong></p><ol><li><p>拥有某个资源的<strong>人</strong>。</p></li><li><p>例如我们使用通过微信账号登录百度，而微信账号信息的资源拥有者就是微信用户。</p></li></ol></li><li><p><strong>client（客户端）</strong></p><ol><li><p>用户直接访问到的程序。</p></li><li><p>例如我们使用通过微信账号登录百度，客户端就是百度。</p></li></ol></li><li><p><strong>authorization server（授权服务器）</strong></p><ol><li><p>资源服务器这家公司提供，专门用来处理认证授权</p></li><li><p>例如我们使用通过微信账号登录百度，授权服务器就是微信开放平台提供的用于认证的服务器，用于给resource server管理第三方授权。</p></li></ol></li><li><p><strong>resource server（资源服务器）</strong></p><ol><li><p>存放资源的服务器。</p></li><li><p>接收使用访问令牌对受保护资源的请求并响应，它与授权服务器可以是同一服务器，也可以是不同服务器。</p></li><li><p>例如我们使用通过微信账号登录百度，资源服务器就是微信服务器。</p></li></ol></li></ol><p><strong>总结</strong></p><p>以用户通过微信来登录百度为例，用户这个人是resource owner，拥有微信账号；</p><p>百度平台是client，是用户想访问的平台；</p><p>微信账号是resource server，存放着用户的微信数据；</p><p>微信开放平台是authorization server，用于给resource server管理第三方授权。可以发现，authorization server和resource server一般是同一家公司。</p><h3 id="流程图-oauth2官网" tabindex="-1"><a class="header-anchor" href="#流程图-oauth2官网" aria-hidden="true">#</a> <strong>流程图：OAuth2官网</strong></h3>',39),b={href:"https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-31##section-1.2",target:"_blank",rel:"noopener noreferrer"},A=o('<figure><img src="'+u+'" alt="IMG_259" tabindex="0" loading="lazy"><figcaption>IMG_259</figcaption></figure><h2 id="授权模式及其流程" tabindex="-1"><a class="header-anchor" href="#授权模式及其流程" aria-hidden="true">#</a> 授权模式及其流程</h2><p>授权模式是指client获取access_token的方式，官方给了4种，</p><ol><li><p>authorization code。授权码模式</p></li><li><p>implicit。隐藏模式。</p></li><li><p>resource owner password。用户的账号密码方式</p></li><li><p>client。client的id授权方式</p></li></ol><p>当然，也可以自由扩展，能认证返回access_token就行。</p><h3 id="授权码模式" tabindex="-1"><a class="header-anchor" href="#授权码模式" aria-hidden="true">#</a> 授权码模式</h3><h4 id="简介-1" tabindex="-1"><a class="header-anchor" href="#简介-1" aria-hidden="true">#</a> 简介</h4><p><mark><strong>功能最完整、流程最严密的授权模式</strong></mark>。</p><p>首先用户让微信给一个code给client，client拿着code找微信换一个access_token，以后就用access_token获取用户的唯一id。</p><p>石墨文档(client)需要在微信开放平台(authorization)注册，获取appId和appSecret。这组凭证是石墨自己访问微信开放平台的。access_token则是代表用户本人，注意区别。</p><h4 id="流程" tabindex="-1"><a class="header-anchor" href="#流程" aria-hidden="true">#</a> 流程</h4><figure><img src="'+h+'" alt="IMG_260" tabindex="0" loading="lazy"><figcaption>IMG_260</figcaption></figure><p><strong>第1步：用户通过浏览器访问石墨文档，然后点击微信登录按钮</strong></p><p>浏览器请求石墨微信登录回调地址，石墨后台返回302，response有location头， 浏览器重定向跳转到微信二维码认证页面。</p><figure><img src="'+g+'" alt="IMG_261" tabindex="0" loading="lazy"><figcaption>IMG_261</figcaption></figure><p>location的值为：</p><p>https://open.weixin.qq.com/connect/qrconnect?appid=wx5a67899f4af8b0b1&amp;redirect_uri=https%3A%2F%2Fshimowendang.com%2Flizard-api%2Fauth%2Fwechat%2Flogin_callback&amp;response_type=code&amp;scope=snsapi_login&amp;state=ee257de2-91af-411e-9f2a-ef2b802bebfb##wechat_redirect</p><p><strong>参数</strong></p><ul><li><p>appid: 石墨文档作为client在微信开发平台的凭证id</p></li><li><p>redirect_uri: 认证通过后，微信开放平台添加一个code参数到这个url后面，然后浏览器重定向到这个url。这个url是石墨文档后台接收code的接口。</p></li><li><p>response_type: code。固定值。</p></li><li><p>scope: 授权范围，想获取用户哪些资料的api。网页登录为snsapi_login</p></li><li><p>state: 防刷的，防止csrf跨站请求伪造攻击。微信认证成功后，回调的时候会原样返回给石墨(client)。如果没这个，client接收参数就只有code，别人就是随意伪造碰撞code。而石墨生成了一次性token作为state，回调接口只有一次有效期。这里石墨用的uuid.</p></li></ul><p><strong>第2步：用户扫描微信二维码，允许通过微信登录</strong></p><p>用户微信点击了确认，就代表了授权通过了，允许石墨获取access_token。浏览器微信二维码页面收到code，将code作为参数拼接redirect的url，浏览器重定向到石墨后台。 <img src="'+_+`" alt="IMG_262" loading="lazy"></p><p>请求的url为：</p><p>https://shimowendang.com/lizard-api/auth/wechat/login_callback?code=0412xLkl2HION745rIml2UNUng12xLkQ&amp;state=ee257de2-91af-411e-9f2a-ef2b802bebfb</p><p><strong>参数</strong></p><ul><li><p>code：微信开放平台(authorization server)颁发给石墨文档(client)的code。</p></li><li><p>state：石墨平台用于检测是否有效。</p></li></ul><p>石墨文档后台会校验<strong>state</strong>是否有效，然后拿<strong>code</strong>和appId、appSecret去访问微信接口获取用户信息。</p><ol><li><p>这一步是在石墨文档后台进行的。浏览器看不到access_token。</p></li><li><p>对于上一步生成的code，即便有人拿到code，它已经失效了。</p></li><li><p>code和state都是一次性的有效期。这样保证了access_token的安全性。</p></li></ol><p>石墨文档后台访问的微信接口：</p><p>https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code</p><p>返回值：</p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code><span class="token punctuation">{</span>
<span class="token property">&quot;access_token&quot;</span><span class="token operator">:</span><span class="token string">&quot;ACCESS_TOKEN&quot;</span><span class="token punctuation">,</span>
<span class="token property">&quot;expires_in&quot;</span><span class="token operator">:</span><span class="token number">7200</span><span class="token punctuation">,</span>
<span class="token property">&quot;refresh_token&quot;</span><span class="token operator">:</span><span class="token string">&quot;REFRESH_TOKEN&quot;</span><span class="token punctuation">,</span>
<span class="token property">&quot;openid&quot;</span><span class="token operator">:</span><span class="token string">&quot;OPENID&quot;</span><span class="token punctuation">,</span>
<span class="token property">&quot;scope&quot;</span><span class="token operator">:</span><span class="token string">&quot;SCOPE&quot;</span><span class="token punctuation">,</span>
<span class="token property">&quot;unionid&quot;</span><span class="token operator">:</span> <span class="token string">&quot;o6_bmasdasdsad6_2sgVt7hMZOPfL&quot;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>第3步：石墨文档登录</strong></p><p>石墨文档获取到用户唯一id（unionid字段）后，根据后台用户账号的绑定关系，确认当前登录用户登录。</p><h3 id="隐藏模式" tabindex="-1"><a class="header-anchor" href="#隐藏模式" aria-hidden="true">#</a> 隐藏模式</h3><h4 id="简介-2" tabindex="-1"><a class="header-anchor" href="#简介-2" aria-hidden="true">#</a> 简介</h4><p>针对纯web前端应用，没有后台，令牌只能放在前端。这种也叫client side，又称为User Agent Flow。access_token会进行网络传输，并不安全，很少使用这种方案。</p><p>client直接请求authorization server获取access_token，请求参数是client id和redirect url, 最后认证返回后拼接##access_code。</p><h4 id="流程-1" tabindex="-1"><a class="header-anchor" href="#流程-1" aria-hidden="true">#</a> 流程</h4><figure><img src="`+f+'" alt="IMG_264" tabindex="0" loading="lazy"><figcaption>IMG_264</figcaption></figure><p>QQ互联提供了这样的接口：使用Implicit_Grant方式获取Access_Token --- QQ互联WIKI</p><p><strong>第1步：获得access_token</strong></p><p><strong>请求地址</strong>：</p><p>PC网站： https://graph.qq.com/oauth2.0/authorize</p><p><strong>请求方法</strong>：</p><p>GET</p><p><strong>请求参数</strong>：</p><p>请求参数请包含如下内容：</p>',47),q=t("thead",null,[t("tr",null,[t("th",null,[t("em",null,[t("strong",null,"*参数*")])]),t("th",null,[t("em",null,[t("strong",null,"*是否必须*")])]),t("th",null,[t("em",null,[t("strong",null,"*含义*")])])])],-1),v=t("tr",null,[t("td",null,"response_type"),t("td",null,"必须"),t("td",null,"授权类型，此值固定为“token”。")],-1),E=t("tr",null,[t("td",null,"client_id"),t("td",null,"必须"),t("td",null,"申请QQ登录成功后，分配给应用的appid。")],-1),x=t("tr",null,[t("td",null,"redirect_uri"),t("td",null,"必须"),t("td",null,"成功授权后的回调地址，必须是注册appid时填写的主域名下的地址，建议设置为网站首页或网站的用户中心。注意需要将url进行URLEncode。")],-1),O=t("td",null,"scope",-1),I=t("td",null,"可选",-1),y={href:"https://wiki.connect.qq.com/api%E5%88%97%E8%A1%A8",target:"_blank",rel:"noopener noreferrer"},B=t("tr",null,[t("td",null,"state"),t("td",null,"可选"),t("td",null,"client端的状态值。用于第三方应用防止CSRF攻击，成功授权后回调时会原样带回。")],-1),z=t("tr",null,[t("td",null,"display"),t("td",null,"可选"),t("td",null,"仅****PC网站****接入时使用。 用于展示的样式。不传则默认展示为PC下的样式。 如果传入“mobile”，则展示为mobile端下的样式。")],-1),C=o(`<hr><p>**第2步：回调 **</p><p>1.如果用户成功登录并授权，则会跳转到指定的回调地址，并在URL后加&quot;##&quot;号，带上Access Token以及expires_in等参数。如果请求参数中传入了state，这里会带上原始的state值。如果redirect_uri地址后已经有&quot;##&quot;号，则加&quot;&amp;&quot;号，带上相应的返回参数。如： PC网站：</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code>http://graph.qq.com/demo/index.jsp?#access_token=FE04************************CCE2&amp;expires_in=7776000&amp;state=test
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>说明：expires_in是该access token的有效期，单位为秒。</p><p>Tips：</p><ol><li><p>可通过js方法：window.location.hash来获取URL中##后的参数值。</p></li><li><p>建议用js设置cookie存储token。</p></li></ol><p>2. 如果用户在登录授权过程中取消登录流程，对于PC网站，登录页面直接关闭；</p><p><strong>错误码说明</strong>：</p>`,9),G={href:"https://wiki.connect.qq.com/%E5%85%AC%E5%85%B1%E8%BF%94%E5%9B%9E%E7%A0%81%E8%AF%B4%E6%98%8E##100000-100031.EF.BC.9APC.E7.BD.91.E7.AB.99.E6.8E.A5.E5.85.A5.E6.97.B6.E7.9A.84.E5.85.AC.E5.85.B1.E8.BF.94.E5.9B.9E.E7.A0.81",target:"_blank",rel:"noopener noreferrer"},w=t("h3",{id:"账号密码模式",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#账号密码模式","aria-hidden":"true"},"#"),e(" 账号密码模式")],-1),F=t("p",null,"需要用户把微信账号和密码给石墨文档，石墨拿着去微信换token。这种方式不需要了解，不可能使用。",-1),M=t("h3",{id:"客户端模式",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#客户端模式","aria-hidden":"true"},"#"),e(" 客户端模式")],-1),P=t("p",null,"纯后台方案。client拿着client_id和secret去换access_token。通常就是我们后台服务调用的时候用到。比如使用aws的s3或者阿里云的oss上传文件。我们需要通过ak，sk认证，获取一个token，拿token去上传文件。这个流程写起来挺麻烦，一般都会封装好客户端给我们用。",-1);function Q(T,L){const n=i("ExternalLinkIcon");return p(),r("div",null,[k,t("p",null,[e("网址："),t("a",b,[e("draft-ietf-oauth-v2-31"),s(n)])]),A,t("table",null,[q,t("tbody",null,[v,E,x,t("tr",null,[O,I,t("td",null,[e("请求用户授权时向用户显示的可进行授权的列表。 可填写的值是"),t("a",y,[e("API列表"),s(n)]),e("中列出的接口，以及一些动作型的授权（目前仅有：do_like），如果要填写多个接口名称，请用逗号隔开。 例如：scope=get_user_info,list_album,upload_pic,do_like 不传则默认请求对接口get_user_info进行授权。 建议控制授权项的数量，只传入必要的接口名称，因为授权项越多，用户越可能拒绝进行任何授权。")])]),B,z])]),C,t("p",null,[e("接口调用有错误时，会返回code和msg字段，以url参数对的形式返回，value部分会进行url编码（UTF-8）。 PC网站接入时，错误码详细信息请参见："),t("a",G,[e("100000-100031：PC网站接入时的公共返回码"),s(n)]),e("。")]),w,F,M,P])}const U=a(m,[["render",Q],["__file","OAuth2-流程原理.html.vue"]]);export{U as default};
