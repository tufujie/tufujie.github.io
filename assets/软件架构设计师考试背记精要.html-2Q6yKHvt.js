const e=JSON.parse('{"key":"v-56a893bb","path":"/study/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%80%83%E8%AF%95%E8%83%8C%E8%AE%B0%E7%B2%BE%E8%A6%81.html","title":"软件架构设计师考试背记精要","lang":"zh-CN","frontmatter":{"title":"软件架构设计师考试背记精要","description":"4.1.数据流风格 适合于分阶段做数据处理，交互性差，包括：批处理序列、管理过滤器。 4.2.调用/返回风格 一般系统都要用到，包括：主程序/子程序，面向对象，层次结构（分层越多，性能越差）。 4.3.独立构件风格 构件是独立的过程，连接件是消息传递。包括：进程通信，事件驱动系统（隐式调用）。应用场景，通过事件触发操作。 4.4.虚拟机风格","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/study/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%80%83%E8%AF%95%E8%83%8C%E8%AE%B0%E7%B2%BE%E8%A6%81.html"}],["meta",{"property":"og:site_name","content":"Jef Blog"}],["meta",{"property":"og:title","content":"软件架构设计师考试背记精要"}],["meta",{"property":"og:description","content":"4.1.数据流风格 适合于分阶段做数据处理，交互性差，包括：批处理序列、管理过滤器。 4.2.调用/返回风格 一般系统都要用到，包括：主程序/子程序，面向对象，层次结构（分层越多，性能越差）。 4.3.独立构件风格 构件是独立的过程，连接件是消息传递。包括：进程通信，事件驱动系统（隐式调用）。应用场景，通过事件触发操作。 4.4.虚拟机风格"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://mister-hope.github.io/"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-01-28T12:29:12.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"软件架构设计师考试背记精要"}],["meta",{"property":"article:author","content":"Jef"}],["meta",{"property":"article:modified_time","content":"2024-01-28T12:29:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"软件架构设计师考试背记精要\\",\\"image\\":[\\"https://mister-hope.github.io/\\"],\\"dateModified\\":\\"2024-01-28T12:29:12.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Jef\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"4.1.数据流风格","slug":"_4-1-数据流风格","link":"#_4-1-数据流风格","children":[]},{"level":2,"title":"4.2.调用/返回风格","slug":"_4-2-调用-返回风格","link":"#_4-2-调用-返回风格","children":[]},{"level":2,"title":"4.3.独立构件风格","slug":"_4-3-独立构件风格","link":"#_4-3-独立构件风格","children":[]},{"level":2,"title":"4.4.虚拟机风格","slug":"_4-4-虚拟机风格","link":"#_4-4-虚拟机风格","children":[]},{"level":2,"title":"4.5.仓库风格（以数据为中心的风格）","slug":"_4-5-仓库风格-以数据为中心的风格","link":"#_4-5-仓库风格-以数据为中心的风格","children":[]},{"level":2,"title":"4.6.闭环控制架构（过程控制）","slug":"_4-6-闭环控制架构-过程控制","link":"#_4-6-闭环控制架构-过程控制","children":[]},{"level":2,"title":"4.7.MVC","slug":"_4-7-mvc","link":"#_4-7-mvc","children":[]},{"level":2,"title":"4.8.SOA","slug":"_4-8-soa","link":"#_4-8-soa","children":[]},{"level":2,"title":"4.9.ESB","slug":"_4-9-esb","link":"#_4-9-esb","children":[]},{"level":2,"title":"4.10.REST 的 5 大原则","slug":"_4-10-rest-的-5-大原则","link":"#_4-10-rest-的-5-大原则","children":[]},{"level":2,"title":"4.11.微服务特点","slug":"_4-11-微服务特点","link":"#_4-11-微服务特点","children":[]},{"level":2,"title":"4.12.微服务优势","slug":"_4-12-微服务优势","link":"#_4-12-微服务优势","children":[]},{"level":2,"title":"4.13.微服务与 SOA 对比","slug":"_4-13-微服务与-soa-对比","link":"#_4-13-微服务与-soa-对比","children":[]},{"level":2,"title":"4.14.ADL 的三个基本元素","slug":"_4-14-adl-的三个基本元素","link":"#_4-14-adl-的三个基本元素","children":[]},{"level":2,"title":"4.15.DSSA 基本活动","slug":"_4-15-dssa-基本活动","link":"#_4-15-dssa-基本活动","children":[]},{"level":2,"title":"4.16.DSSA 角色","slug":"_4-16-dssa-角色","link":"#_4-16-dssa-角色","children":[]},{"level":2,"title":"4.17.DSSA 三层次模型","slug":"_4-17-dssa-三层次模型","link":"#_4-17-dssa-三层次模型","children":[]},{"level":2,"title":"4.18.ABSD 方法","slug":"_4-18-absd-方法","link":"#_4-18-absd-方法","children":[]},{"level":2,"title":"4.19.ABSD 方法有三个基础","slug":"_4-19-absd-方法有三个基础","link":"#_4-19-absd-方法有三个基础","children":[]},{"level":2,"title":"4.20.ABSD 开发过程","slug":"_4-20-absd-开发过程","link":"#_4-20-absd-开发过程","children":[]},{"level":2,"title":"4.21.架构评审四大质量属性","slug":"_4-21-架构评审四大质量属性","link":"#_4-21-架构评审四大质量属性","children":[]},{"level":2,"title":"4.22.风险点","slug":"_4-22-风险点","link":"#_4-22-风险点","children":[]},{"level":2,"title":"4.23.基本场景的评估方法","slug":"_4-23-基本场景的评估方法","link":"#_4-23-基本场景的评估方法","children":[]},{"level":2,"title":"4.24.架构评估方法","slug":"_4-24-架构评估方法","link":"#_4-24-架构评估方法","children":[]},{"level":2,"title":"4.25.ATAM 四大阶段","slug":"_4-25-atam-四大阶段","link":"#_4-25-atam-四大阶段","children":[]},{"level":2,"title":"4.26.SAAM 五个步骤","slug":"_4-26-saam-五个步骤","link":"#_4-26-saam-五个步骤","children":[]},{"level":2,"title":"4.27.产品线技术应用场景","slug":"_4-27-产品线技术应用场景","link":"#_4-27-产品线技术应用场景","children":[]},{"level":2,"title":"4.28.建立产品线的四种方式","slug":"_4-28-建立产品线的四种方式","link":"#_4-28-建立产品线的四种方式","children":[]},{"level":2,"title":"4.29.产品线实施成功的决定因素","slug":"_4-29-产品线实施成功的决定因素","link":"#_4-29-产品线实施成功的决定因素","children":[]},{"level":2,"title":"4.30.构件、对象、模块的对比","slug":"_4-30-构件、对象、模块的对比","link":"#_4-30-构件、对象、模块的对比","children":[]},{"level":2,"title":"4.31.构件系统架构","slug":"_4-31-构件系统架构","link":"#_4-31-构件系统架构","children":[]},{"level":2,"title":"4.32.构件的复用","slug":"_4-32-构件的复用","link":"#_4-32-构件的复用","children":[]},{"level":2,"title":"4.33.在构件组装阶段失配问题","slug":"_4-33-在构件组装阶段失配问题","link":"#_4-33-在构件组装阶段失配问题","children":[]},{"level":2,"title":"4.34.中间件","slug":"_4-34-中间件","link":"#_4-34-中间件","children":[]},{"level":2,"title":"4.35.中间件功能","slug":"_4-35-中间件功能","link":"#_4-35-中间件功能","children":[]},{"level":2,"title":"4.36.采用中间件技术的优点","slug":"_4-36-采用中间件技术的优点","link":"#_4-36-采用中间件技术的优点","children":[]},{"level":2,"title":"4.37.主要的中间件","slug":"_4-37-主要的中间件","link":"#_4-37-主要的中间件","children":[]},{"level":2,"title":"4.38.中间件技术-Corba(公共对象请求代理体系结构)（代理模式）","slug":"_4-38-中间件技术-corba-公共对象请求代理体系结构-代理模式","link":"#_4-38-中间件技术-corba-公共对象请求代理体系结构-代理模式","children":[]},{"level":2,"title":"4.39.典型应用架构--J2EE","slug":"_4-39-典型应用架构-j2ee","link":"#_4-39-典型应用架构-j2ee","children":[]},{"level":2,"title":"4.40.Bean 的分类","slug":"_4-40-bean-的分类","link":"#_4-40-bean-的分类","children":[]},{"level":2,"title":"4.41.重量级与轻量级区别","slug":"_4-41-重量级与轻量级区别","link":"#_4-41-重量级与轻量级区别","children":[]},{"level":2,"title":"4.42.典型应用架构--.Net","slug":"_4-42-典型应用架构-net","link":"#_4-42-典型应用架构-net","children":[]},{"level":2,"title":"4.43.WEB 设计维度","slug":"_4-43-web-设计维度","link":"#_4-43-web-设计维度","children":[]},{"level":2,"title":"4.44.集群","slug":"_4-44-集群","link":"#_4-44-集群","children":[]},{"level":2,"title":"4.45.负载均衡技术","slug":"_4-45-负载均衡技术","link":"#_4-45-负载均衡技术","children":[]},{"level":2,"title":"4.46.有状态和无状态","slug":"_4-46-有状态和无状态","link":"#_4-46-有状态和无状态","children":[]},{"level":2,"title":"4.47.XML 与 JSON","slug":"_4-47-xml-与-json","link":"#_4-47-xml-与-json","children":[]},{"level":2,"title":"4.48.缓冲 Redis 和 Memcache 对比","slug":"_4-48-缓冲-redis-和-memcache-对比","link":"#_4-48-缓冲-redis-和-memcache-对比","children":[]},{"level":2,"title":"4.49.REST 概念","slug":"_4-49-rest-概念","link":"#_4-49-rest-概念","children":[]},{"level":2,"title":"4.50.REST 的五个原则","slug":"_4-50-rest-的五个原则","link":"#_4-50-rest-的五个原则","children":[]},{"level":2,"title":"4.51.响应式 Web 设计","slug":"_4-51-响应式-web-设计","link":"#_4-51-响应式-web-设计","children":[]},{"level":2,"title":"4.52.业务中台和数据中台区分","slug":"_4-52-业务中台和数据中台区分","link":"#_4-52-业务中台和数据中台区分","children":[]},{"level":2,"title":"4.53.MDA(Model Driven Architecture)","slug":"_4-53-mda-model-driven-architecture","link":"#_4-53-mda-model-driven-architecture","children":[]}],"git":{"createdTime":1706347936000,"updatedTime":1706444952000,"contributors":[{"name":"tufujie","email":"jef.tu@foxmail.com","commits":1},{"name":"tufujie","email":"tufj@hua-cloud.com.cn","commits":1}]},"readingTime":{"minutes":12.1,"words":3629},"filePathRelative":"study/系统架构设计师/核心知识点/软件架构设计师考试背记精要.md","localizedDate":"2024年1月27日","excerpt":"<h2> <strong>4.1.数据流风格</strong></h2>\\n<p>适合于分阶段做数据处理，交互性差，包括：批处理序列、管理过滤器。</p>\\n<h2> <strong>4.2.调用/返回风格</strong></h2>\\n<p>一般系统都要用到，包括：主程序/子程序，面向对象，层次结构（分层越多，性能越差）。</p>\\n<h2> <strong>4.3.独立构件风格</strong></h2>\\n<p>构件是独立的过程，连接件是消息传递。包括：进程通信，事件驱动系统（隐式调用）。应用场景，通过事件触发操作。</p>\\n<h2> <strong>4.4.虚拟机风格</strong></h2>","autoDesc":true}');export{e as data};
